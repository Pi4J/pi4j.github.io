[{"uri":"https://pi4j.com/about/","title":"About","tags":[],"description":"","content":"Project Status/Summary Pi4J V2+ is a complete re-write and does not maintain API compatibility with previous versions. It is not intended to be a drop-in replacement for previous versions of Pi4J. Pi4J V2+ is a completely new design bringing modern conventions, development practices, extensibility support and simplified integration experience for Pi4J users.\nThis website aims to be the source of documentation for all things Java on Raspberry Pi. As such, you will not only find info on Pi4J, but also getting started examples for basic Java Pi4J projects, JavaFX user interface applications, FXGL games, etc.\nThis is a true open-source project, meaning it can only evolve, grow and improve by the support of the community. Any idea, documentation improvement, bug fix\u0026hellip; is greatly welcomed through the normal GitHub flow!\n"},{"uri":"https://pi4j.com/architecture/about-the-code/","title":"Project source structure","tags":[],"description":"","content":"To ensure the Pi4J V2+ project is easy to maintain, there is a clear separation between the core functions and isolated test, example and plugin projects.\nOn this page we want to give you an overview of the projects which are part of the GitHub Pi4J Project.\nPi4J V2+ Main project github.com/Pi4J/pi4j This is the main Pi4J V2 project providing all (basic) I/O functionalities. Pi4J Parent POM /pom.xml This is \u0026ldquo;the grandparent POM\u0026rdquo; and the place to build the entire project. Pi4J Libraries /libraries/* This folder contains (JNI native) libraries that Pi4J or Pi4J plugins may require for runtime. Libraries are not Pi4J extension, plugins, providers, platforms, etc. At this moment only a PiGpio library is included, but could be extended in the future. By isolation the native functions in libraries, the underlying I/O interface can easily be replaced later without breaking the core library. Pi4J Libraries Parent POM /libraries/pi4j-library/pom.xml Base library to be used when creating a new library. Contains the parent pom.xml-file for all library implementations. Pi4J PiGPIO JNI Wrapper Library /libraries/pi4j-library-pigpio This library is a Java library to wrap the PiGPIO API and implement the JNI layer to facilitate use of PiGPIO in Java. There is no Pi4J specific API or code in this library. This PiGPIO wrapper can be used directly without using the Pi4J-core but in that case your application highly depends on the methods of PiGPIO and will be very hard to refactor if you need to use another wrapper. Pi4J Core Library /pi4j-core This is the Pi4J V2 API and core implementation of the framework and runtime. Doesn\u0026rsquo;t contain any actual I/O providers, platforms or IO/platform implementation \u0026ndash;\u0026gt; those are all provided via extensions/plugins. Pi4J Unit/Integration Test /pi4j-test This is intended to be a place for unit and integration tests to test the APIs and features. It only performs tests using MOCK I/O via the Mock IO Provider (plugin). It should not attempt to perform any real I/O testing. Pi4J Plugins: the actual I/O providers, platforms and implementations /plugins/* This folder contains any plugins for use with Pi4J such as IO providers, platforms, or extensions. Plugins must implement the Pi4J Plugin Interface (com.pi4j.extension.Plugin) and declare the implementation class using the \u0026ldquo;provides\u0026rdquo; directive in the module info class. See for an example in /plugins/pi4j-plugin-mock/src/main/java/module-info.java Pi4J Libraries Parent POM /plugins/pi4j-plugin/pom.xml* Base library to be used when creating a new plugin. Contains the parent pom.xml-file for all plugin implementations. Pi4J LinuxFS Provider /plugins/pi4j-plugin-linuxfs This plugin is intended to implement I/O Providers for Linux file system operations such as SERIAL, SPI, I2C and perhaps basic GPIO. This plugin is mostly empty at this moment. Goal is to have an I/O Provider which is totally independant of an underlying program. Pi4J Mock Platform \u0026amp; Provider /plugins/pi4j-plugin-mock This plugin implements both a Mock Platform and Mock I/O Providers for every I/O type supported by Pi4J. This Mock plugin is used by the unit and integration testing project. Pi4J PiGPIO Provider /plugins/pi4j-plugin-pigpio This plugin implements I/O Providers for every I/O type supported by the PiGPIO library. At this moment, this single plugin supports both ** local/native connectivity to PiGPIO ** remote (TCP) connectivity to PiGPIO ** TO BE DISCUSSED: Perhaps this should be separated into two plugins? Or moved to a separate \u0026ldquo;remote connectivity project\u0026rdquo;? Pi4J RaspberryPi Platform \u0026amp; Provider /plugins/pi4-plugin-raspberrypi This plugin is intended to implement the Provider for the Raspberry Pi models and declare the default I/O providers for each of the I/O types supported by each RPi model. Pi4J WiringPi Provider NOT IN THE PROJECT CODE This plugin was intended to implement I/O Providers for use with the WiringPi library, similar to the PiGPIO provider. However with the WiringPi project no longer being maintained publicly, this plugin was not implemented Stand-alone projects Pi4J Test Harness github.com/Pi4J/pi4j-test-harness This project contains the source code (both Java library and Arduino code) for the hardware test harness which has been created to eventually perform hardware testing at the physical layer to help speed up verification for each RPI hardware model Current state is very rough but functional. This project has been moved outside of the core project as this is only used for the validation test cycle before releasing a new version. For more info, see \u0026ldquo;Hardware testing\u0026rdquo; Pi4J Example projects Pi4J Minimal example github.com/Pi4J/pi4j-example-minimal Example project only showing the use of a digital input and output with minimal code but a lot of comments Pi4J Examples github.com/Pi4J/pi4j-examples This project contains numerous code examples to demonstrate how to use Pi4J Certain functions have examples to reach the same goal with different use types, e.g. initialization of a DigitalInput with code, properties and annotations. Pi4J Telegraph example github.com/Pi4J/pi4j-example-telegraph Example project demonstrated during Oracle Code One 2019 "},{"uri":"https://pi4j.com/kotlin/kotlin-examples/getting-started/","title":"Basic Project Setup","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/RoboticsLife/Lesson01-Gpio-Kotlin-Pi4J\nIn this video we go through the process of setting up the project in IntelliJIDEA to be able to do remote debugging between PC and a Raspberry Pi.\n"},{"uri":"https://pi4j.com/kotlin/kotlin-examples/useful-tips/","title":"Useful Tips","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/RoboticsLife/Lesson02-Gpio-Kotlin-Pi4J\n"},{"uri":"https://pi4j.com/prepare/","title":"Prepare a Raspberry Pi","tags":[],"description":"","content":"The Raspberry Pi is a powerful machine with many use-cases. A lot of this power is based on the operating system you use. In all the documentation here for Pi4J, we use the official Raspberry Pi Operating System (formerly known as \u0026ldquo;Raspbian OS\u0026rdquo;). But there is a long list of other possibilities which is listed, for example, on the \u0026ldquo;Awesome Raspberry Pi\u0026rdquo; list on GitHub.\nDo you already have a Raspberry Pi with an up-to-date Operating System, and Java 11 or newer? Then you are good to go and can skip forward to the Getting Started with Pi4J section! The information given in this part of our website is mainly focusing on anyone starting with Java on the Raspberry Pi.\nWhat Do We Need? The Raspberry Pi doesn\u0026rsquo;t come with a hard disk like typical computers. The operating system needs to be \u0026ldquo;burned\u0026rdquo; onto an SD Card.\nInstead of an SD Card you can use an NVMe SSD disk. This requires an additional connection cable or hat, for instance, the Raspberry Pi SSD Kit. The advantage of such a system is a faster startup and disc access, but is not required for any of the examples explained on this website.\nMaterial list This is the list of materials needed to get you started:\nRaspberry Pi (4, 5, or Pi Zero 2 is recommended, but older versions also work with Java and Pi4J!) Micro SD card, minimally 16Gb PC (or other Raspberry Pi) with an SD card slot (maybe you will need an SD card adapter) Power supply (5V, a Raspberry Pi 5 needs one that can provide 5A = 25W) Monitor, keyboard, mouse Step-by-step First step: take your new Raspberry Pi out of the box of course :-)\nTake a good look at it, what you are holding in your hands is a true masterpiece. A wonder of technical engineering with a perfect mix of powerful yet inexpensive components.\nBut be aware! This is also a sensitive piece of electronics! It\u0026rsquo;s always a good idea to first touch the grounding pin of a power outlet to make sure your body is not electrically charged which could damage one of the components on the board.\nThe following steps:\nWrite OS to SD card The First Boot Install Java and Tools Install Visual Studio Code After these steps, you can continue to the Getting Started with Pi4J section for your first experiments with Java and electronic components.\nPi4J OS In the past, we had our own Pi4J OS, based on Raspberry Pi OS with some extra preparations to make it easier to use with Pi4J. But because it became incompatible with the Raspberry Pi 5 and was difficult to maintain, we no longer will update that Pi4J OS.\nYou can still find it on GitHub: https://github.com/Pi4J/pi4j-os\n"},{"uri":"https://pi4j.com/prepare/sd-card/","title":"Write OS to SD card","tags":[],"description":"","content":"The SD card will hold the operating system. On the Raspberry Pi website, on the download page, you can find the Imager tool. Select the version for your computer, download, and install it.\nStart the Imager and follow these steps:\nPut the SD Card in your computer Click \u0026ldquo;Choose Device\u0026rdquo; and select your type of board Click \u0026ldquo;Choose OS\u0026rdquo; \u0026gt; \u0026ldquo;Raspberry Pi OS (64-bit)\u0026rdquo; (or 32-bit for an older board) Click \u0026ldquo;Choose Storage\u0026rdquo; and select your SD card Click \u0026ldquo;Next\u0026rdquo; In the \u0026ldquo;Use OS customisation?\u0026rdquo; screen, click \u0026ldquo;Edit Settings\u0026rdquo; In \u0026ldquo;General\u0026rdquo;, fill in a name for your board, login, password, wifi settings, etc. In \u0026ldquo;Services\u0026rdquo;, enable SSH with password authentication In \u0026ldquo;Options\u0026rdquo; you can disable telemetry. Back in the \u0026ldquo;Use OS customisation?\u0026rdquo; screen, click \u0026ldquo;Yes\u0026rdquo; Confirm with \u0026ldquo;Yes\u0026rdquo; that all data on the SD Card can be overwritten Wait until \u0026ldquo;Writing\u0026rdquo; and \u0026ldquo;Verifying\u0026rdquo; are finished You can now take the SD Card out of your computer, and put it in the Raspberry Pi Imager start screen\nSelecting the device\nSelecting the operating system\nSelecting the SD card\nCustomisation start screen\nCustomisation: General settings\nCustomisation: Services\nCustomisation: Options\nWriting to the SD card\nVerifying the SD card\nImager is finished\n"},{"uri":"https://pi4j.com/prepare/first-boot/","title":"The First Boot","tags":["Pi4J OS"],"description":"","content":"Put the SD Card with the operating system into the Raspberry Pi, connect a keyboard, mouse, and screen, and power it up!\nIf you configured the login, password, WiFi, and SSH settings in the \u0026ldquo;Use OS customisation?\u0026rdquo; part of the Imager tool, you can connect to the Raspberry Pi from another PC via SSH with the username and hostname you filled in: ssh USERNAME@HOSTNAME.local.\nUpdate the System Yes, even when you just created the SD Card with the latest OS provided by the Imager tool, it is possible that there are updates available.\nEverything on this (and the next) page can be done with one command! It will download a script from the Pi4J OS GitHub project and execute all the different steps automatically. Execute this: shell curl -sL https://raw.githubusercontent.com/Pi4J/pi4j-os/main/script/prepare-for-java.sh | bash.\nRun the following commands in the terminal to make sure your system is fully up-to-date. The output in this example will most probably be different on your system:\n$ sudo apt update Hit:1 http://deb.debian.org/debian bookworm InRelease Get:2 http://deb.debian.org/debian-security bookworm-security InRelease [48.0 kB] ... 13 packages can be upgraded. Run \u0026#39;apt list --upgradable\u0026#39; to see them. $ sudo apt upgrade Reading package lists... Done Building dependency tree... Done ... Need to get 275 MB of archives. After this operation, 9,003 kB of additional disk space will be used. Do you want to continue? [Y/n] y Configuration Changes To use the Raspberry Pi for electronic experiments, we need to configure some settings. You can do these one-by-one with the raspi-config tool, but this is a full list of commands to do this for you. Copy the whole block, and paste it in the terminal.\nsudo raspi-config nonint do_i2c 0 sudo raspi-config nonint do_ssh 0 sudo raspi-config nonint do_serial_hw 0 sudo raspi-config nonint do_serial_cons 1 sudo raspi-config nonint do_onewire 0 sudo systemctl disable hciuart echo \u0026#34;dtoverlay=disable-bt\u0026#34; | sudo tee -a /boot/firmware/config.txt Keep your Raspberry Pi up-to-date It\u0026rsquo;s a good idea to run the following commands from time to time to make sure the system makes use of all the latest improvements.\nsudo apt update sudo apt full-upgrade Raspberry Pi OS is based on Debian - one of the largest Linux distributions. When running these commands regularly, you will keep your installation up to date for the particular major Raspberry Pi OS release you are using (e.g. Debian V9, aka Stretch). It will not update from one major release to another, for example, Stretch (V9) to Buster (V10).\n"},{"uri":"https://pi4j.com/prepare/install-java/","title":"Install Java and Tools","tags":["Pi4J OS","Java","JavaFX","JBang","Maven","SDKMAN"],"description":"","content":"Our Raspberry Pi has started for the first time and we are now ready to add some Java to it!\nAs described on the previous page \u0026ldquo;The First Boot\u0026rdquo;, a script can be executed that will do all this at once: curl -sL https://raw.githubusercontent.com/Pi4J/pi4j-os/main/script/prepare-for-java.sh | bash.\nAdd Missing Dependencies Let\u0026rsquo;s start with some helper tools that will be useful later.\n$ sudo apt install -y i2c-tools vim git java-common libxi6 libxrender1 libxtst6 i2c-tools: Tool to help you with I2C commands. vim: Text editor like nano, preferred by some, hated by others ;-) git: Tool to interact with a Git repository, like GitHub. java-common libxi6 libxrender1 libxtst6: Dependencies of the JDK Debian package. Install Java There are many ways you can install Java. The easiest way to make Java available for both normal use and as root user (sudo), is the following approach which downloads one of the many distributions that are available.\nWith the following commands you can get Java 21 installed. Starting from Pi4J V3, this is the minimal required version. If you are using a previous version of Pi4J, you can still use Java 11.\n$ cd ~/Downloads $ wget https://cdn.azul.com/zulu/bin/zulu21.38.21-ca-jdk21.0.5-linux_arm64.deb $ sudo dpkg -i zulu21.38.21-ca-jdk21.0.5-linux_arm64.deb $ rm zulu21.38.21-ca-jdk21.0.5-linux_arm64.deb This approach only works on a 64-bit system as you can see from the arm64 in the file name. For more info about running Java on a 32-bit system, check Java for ARMv6/7/8.\nTest Java Installation Now you should be able to check the Java version with the following command:\n$ java -version openjdk version \u0026#34;21.0.5\u0026#34; 2024-10-15 LTS OpenJDK Runtime Environment Zulu21.38+21-CA (build 21.0.5+11-LTS) OpenJDK 64-Bit Server VM Zulu21.38+21-CA (build 21.0.5+11-LTS, mixed mode, sharing) Install JavaFX If you want to use JavaFX on your Raspberry Pi, you have a few choices:\nInstall a JDK with JavaFX included from a download, e.g. Azul Zulu. Install a JDK with JavaFX included with SDKMAN, e.g. with sdk install java 21.0.5.fx-zulu. Use a script to download the JavaFX runtime from Gluon, e.g. from the GitHub project pi4j-example-javafx \u0026gt; download_openjfx.bat or download_openjfx.sh script. Install SDKMAN, Maven, and JBang For some of the examples, Maven and/or JBang are used. The easiest way to install these, is by using SDKMAN:\n# Install SDKMAN $ curl -s \u0026#34;https://get.sdkman.io\u0026#34; | bash $ source \u0026#34;$HOME/.sdkman/bin/sdkman-init.sh\u0026#34; # Install Maven $ sdk install maven # Install JBang $ sdk install jbang # Update SDKMAN to the latest version, whenever needed sdk update # Checked the installed versions $ sdk version SDKMAN! script: 5.18.2 native: 0.4.6 $ mvn -v Apache Maven 3.9.9 (8e8579a9e76f7d015ee5ec7bfcdc97d260186937) Maven home: /home/pi4j/.sdkman/candidates/maven/current Java version: 21.0.5, vendor: Azul Systems, Inc., runtime: /usr/lib/jvm/zulu-21-arm64 Default locale: en_GB, platform encoding: UTF-8 OS name: \u0026#34;linux\u0026#34;, version: \u0026#34;6.6.51+rpt-rpi-v8\u0026#34;, arch: \u0026#34;aarch64\u0026#34;, family: \u0026#34;unix\u0026#34; $ jbang --version 0.119.0 "},{"uri":"https://pi4j.com/prepare/install-vsc-ide/","title":"Install Visual Studio Code","tags":["Visual Studio Code"],"description":"","content":"You can develop Java applications on any computer and transfer the code or the compiled JAR-file to a Raspberry Pi to execute it. But Raspberry Pi 4 and 5 are definitely powerful enough to run an Integrated Development Environment (IDE)!\nVisual Studio Code Visual Studio Code (VSC) is the free IDE (Integrated Developer Environment) by Microsoft. It\u0026rsquo;s designed as a universal tool that you can use for multiple programming languages with extensions.\nInstalling Visual Studio Code You can download VSC directly from the website, but it\u0026rsquo;s also available as a Raspberry Pi OS apt package. Use the following commands to install it from the terminal:\n$ sudo apt update $ sudo apt install code -y Adding Extensions When VSC is installed, start it from \u0026ldquo;Start \u0026gt; Programming \u0026gt; Visual Studio Code\u0026rdquo;. There are many extensions available to make it the perfect IDE for many programming languages and other tasks. Make sure to install the following ones to make it your perfect Java-companion:\nJava Extension Pack by Microsoft JBang Download page for VSC\nVSC in the list of programming tools\nVSC running on the Raspberry Pi with Maven and Java Extension Pack\n"},{"uri":"https://pi4j.com/examples/crowpi/develop-crowpi-with-intellij/","title":"Develop with Intellij IDEA","tags":["Pi4J OS","CrowPi","IntelliJ IDEA"],"description":"","content":"The CrowPi example project contains settings to make it easy to develop on a PC with IntelliJ IDEA and execute the application on the CrowPi. The articles, instructions and pictures are created accordingly. IntelliJ IDEA is from available Jetbrains in different versions. The community version has enough functionality for development with the CrowPi and is available for Windows, MacOS and Linux, but NOT for Raspberry Pi. The download can be found here.\nThe subsequent setup of IntelliJ IDEA is identical on all platforms.\nClone the repository As soon as we have installed the development environment, it is time to clone the entry-level project for the CrowPi. The source code can be found on GitHub. In order to clone the repository, the corresponding link must be copied on GitHub and then imported into IntelliJ IDEA. Now step-by-step in pictures a more detailed instruction.\nVisit CrowPi on GitHub and copy the link to clone as described in the picture.\nCrowPi source link\nImport the project In the start window of IntelliJ is the option Get from VCS available. This must be selected so that the code can be cloned directly from GitHub. Then you can simply paste the link that was previously copied from GitHub. By confirming with Clone the process is started and any necessary authentication of the user is carried out. Simply follow the instructions of the tool.\nImport from VCS\nInsert import from VCS link\nAs soon as the project has been completely cloned on the local computer, the project opens automatically in the development environment. A small dialog pops up at the bottom right. This must be confirmed so that the repository can be properly initialized. Maven is a software project management tool, more information can be found in the Apache Maven Project. Basically, however, nothing needs to be changed. The CrowPi project already offers a complete setup and is easy to use.\nImport Maven Project\nImporting the Maven project triggers a security warning at IntelliJ. Click on \u0026ldquo;Trust project\u0026rdquo; to confirmed when you downloaded the soruces from the official Pi4J CrowPi repository.\nTrust Project confirmation\nNow a last import step. To be able to better research errors or understand how the code of the dependencies works, the \u0026ldquo;Maven Sources and Documentation\u0026rdquo; must be downloaded. This can be done with a few clicks. Open the Maven project menu on the far right. Click on \u0026ldquo;Download Sources and/or Documentation\u0026rdquo;. Then in the context menu \u0026ldquo;Download Sources and Documentation\u0026rdquo;. Now all used libraries are locally available and visible.\nDownload Dependencies and Sources\nNow only the start configuration of the project is missing, which is described in the next section.\nSetting the run configuration The CrowPi project uses 3 run configurations. These define which parts of the code are executed and how. However, there is no need to worry, because most of it is already predefined and all you have to do is enter the IP address of your Raspberry Pi to push and run the code from your PC to the Pi. The following configurations are used:\ncrowpi-examples [install] crowpi-examples [debug] Remote Debug With \u0026ldquo;crowpi-examples [install]\u0026rdquo; the current code is copied to the Raspberry Pi. This works via a combination of SSH/SCP. The copied code is then started on the Raspberry Pi. \u0026ldquo;crowpi-examples [debug]\u0026rdquo; does the same, but other options are selected during the connection, and a debugger is waiting until the application is actually executed. \u0026ldquo;Remote Debug\u0026rdquo; provides exactly this debugger. This connects to the Raspberry Pi and troubleshooting can begin.\nTo make everything work smoothly, the IP address of the Raspberry Pi must first be configured. To do this, click here and select \u0026ldquo;Edit Configurations\u0026rdquo;. As explained before, the IP address of the Raspberry Pi is displayed on the background image of CrowPi.\nSelect configuration menu\nThe dialog for setting the configurations now opens. A little hint: wherever the IP address of the Raspberry Pi is required, there is already a placeholder \u0026ldquo;Add CrowPi IP here\u0026rdquo;.\nDepending on the configuration of your Raspberry Pi, you may need to define one of this available properties:\ncrowpi.remote.port, default 22 crowpi.remote.username, default pi crowpi.remote.password, default pi crowpi.remote.target, default ??? crowpi.launcher.class, default ??? crowpi.launcher.args, default ??? crowpi.remote.host specifies the IP/hostname of the CrowPi, defaults to empty crowpi.remote.port defaults to 22 and specifies the SSH server port crowpi.remote.username defaults to pi crowpi.remote.password defaults to crowpi (this deviates from the Raspberry Pi OS default which is raspberry) crowpi.remote.target is the destination folder on the CrowPi where the compiled JAR files are copied to before execution and defaults to /home/pi/deploy (auto-created if missing) crowpi.launcher.class is the class path which should get launched by the JVM, defaults to com.pi4j.crowpi/com.pi4j.crowpi.Launcher and should not be changed (warranty void if you do so :wink:) crowpi.launcher.args are the arguments passed to the application launched by the JVM, specified as a string, passed through as-is without quoting, so e.g. BuzzerApp to launch that directly. Defaults to empty / no args.\nThe first five are only needed for remote deployments. Leaving crowpi.remote.host empty triggers local deployment.\nThere is also crowpi.remote.jvmOptions if you want to add any custom JVM options, defaults to empty or options for remote debug if Maven profile debug is used (edited)\nThe three configurations\nFirst we configure \u0026ldquo;crowpi-examples [debug]\u0026rdquo;. For this, as in the picture, go to the tab \u0026ldquo;Runner\u0026rdquo; open and double click on \u0026ldquo;Add CrowPi IP here\u0026rdquo;. The dialog window to provide the IP address opens. Confirm with \u0026ldquo;OK\u0026rdquo; and press \u0026ldquo;Apply\u0026rdquo; to save.\nSettings debug\nNow we can configure \u0026ldquo;crowpi-examples [install]\u0026rdquo;. This works exactly the same as \u0026ldquo;crowpi-examples [debug]\u0026rdquo;. The same setting is required. Again use \u0026ldquo;Apply\u0026rdquo; to save.\nSettings Install\nNow the last configuration for \u0026ldquo;Remote Debug\u0026rdquo;. The menu is a bit different here. However, it is easier to use than the previous ones. Add the IP Address in the \u0026ldquo;Host\u0026rdquo; field. With \u0026ldquo;OK\u0026rdquo; the setting is finished.\nRemote Debug Settings\nFirst test run Everything is set up to start the CrowPi project for the first time directly from the development environment. Select the run configuration \u0026ldquo;crowpi-examples [install]\u0026rdquo;. Then start the application by pressing the green play button.\nStart the application\nIt immediately opens the \u0026ldquo;Run\u0026rdquo; window in IntelliJ IDEA. It takes a moment, and some text is displayed on the command line. After a few seconds the output stops, and it looks like this:\nRun Output in IntelliJ\nA number can now be typed in here according to the displayed list (+ Enter). The corresponding sample application is then executed. If there are still error messages in the command line, it is worth checking the network connection of the computer and the Raspberry Pi again.\n"},{"uri":"https://pi4j.com/architecture/about-the-code/download-sources/","title":"Download/Install","tags":[],"description":"","content":"You can build the project from sources available on GitHub.\nCheckout the project pi4j Use a JDK version 21 or newer, e.g. sdk use java 21.0.6-zulu In the root of pi4j run mvn clean install [INFO] Executed tasks [INFO] ------------------------------------------------------------------------ [INFO] Reactor Summary for Pi4J :: Parent POM 2.0-SNAPSHOT: [INFO] [INFO] Pi4J :: Parent POM ................................. SUCCESS [ 0.972 s] [INFO] Pi4J :: DOCKER :: Docker Parent POM .............. SUCCESS [ 0.290 s] [INFO] Pi4J :: TESTING :: Arduino Test Harness ........... SUCCESS [ 1.832 s] [INFO] Pi4J :: LIBRARY :: Libraries Parent POM ........... SUCCESS [ 0.064 s] [INFO] Pi4J :: LIBRARY :: JNI Wrapper for PIGPIO Library . SUCCESS [ 6.615 s] [INFO] Pi4J :: LIBRARY :: Java Library (CORE) ............ SUCCESS [ 6.260 s] [INFO] Pi4J :: PLUGIN :: Plugins Parent POM ............. SUCCESS [ 0.061 s] [INFO] Pi4J :: PLUGIN :: Mock Platform \u0026amp; Providers ...... SUCCESS [ 0.683 s] [INFO] Pi4J :: PLUGIN :: PIGPIO I/O Providers ........... SUCCESS [ 2.084 s] [INFO] Pi4J :: PLUGIN :: RaspberryPi Platform \u0026amp; Providers SUCCESS [ 0.447 s] [INFO] Pi4J :: TESTING :: Unit/Integration Tests ......... SUCCESS [ 2.350 s] [INFO] Pi4J :: EXAMPLE :: Sample Code .................... SUCCESS [ 0.632 s] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ Example application Building the example application Checkout the project Pi4J V2+ - Telegraph Demo Project Select JDK 21, e.g. sdk use java 21.0.6-zulu In the root of pi4j-demo-telegraph run mvn clean install Check the directory target\\distribution \u0026ndash;\u0026gt; this contains all the files to be copied to the Raspberry Pi /target/distribution/pi4j-core-2.0-SNAPSHOT.jar /target/distribution/pi4j-demo-telegraph-1.0-SNAPSHOT.jar /target/distribution/pi4j-library-pigpio-2.0-SNAPSHOT.jar /target/distribution/pi4j-plugin-pigpio-2.0-SNAPSHOT.jar /target/distribution/pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar /target/distribution/run.sh /target/distribution/slf4j-api-2.0.0-alpha0.jar /target/distribution/slf4j-simple-2.0.0-alpha0.jar Running on the Raspberry Pi After copying all files from target/distribution to a Raspberry Pi, start ./run.sh "},{"uri":"https://pi4j.com/getting-started/","title":"Getting Started With Pi4J","tags":[],"description":"","content":"You have a Raspberry Pi? And you want to use Java as your programming language to build performant, easy-to-maintain and powerful applications? This is the place to be!!!\nThe pages in this chapter explain you how to get started in different steps. The full documentation for the library, with more in-depth and technical info, can be found in the \u0026ldquo;Documentation\u0026rdquo; chapter.\nFirst, prepare a Raspberry Pi as described here and the follow these steps to get started with your first Pi4J projects:\nUnderstanding the GPIO pins Electrical Engineering Java development with VSC Developing on a remote PC Minimal example application Minimal example as FAT JAR User interface with JavaFX Game development with FXGL JavaFX GUI and MVC template Learn more... "},{"uri":"https://pi4j.com/about/info-v1/","title":"Info about V1","tags":[],"description":"","content":"The original library which started in 2012 and got a last release in 2021. Up till version 1.3.0 the library targets Java 8, while version 1.4.0 relies on Java 11.\nArchived Sources The sources of V1 can be found in the read-only GitHub repository pi4j/pi4j-v1.\nRelease Notes V1.X Pi4J Version 1.4 - 2021-03-03 Support for JDK/JRE 11 and 64-bit ARM platforms This release is the final release for the Pi4J Version 1.x codebase The Pi4J project is now prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform Changed project to Apache License, Version 2.0 Removed pi4j-device and pi4j-gpio-extension library Removed platform support for Odroid, BananaPi, BPi, NanoPi, OrangePi Various improvements and bug fixes listed here: GitHub Issues (v1.4) Not using Java-modules yet, this will be part of the V2 Documentation website V1.4 Pi4J Version 1.3 - 2021-01-29 Added support for Raspberry Pi 4B, 400, and Compute Module 4 Various improvements and bug fixes listed here: GitHub Issues (v1.3) Based on JDK8 Documentation website V1.3 Pi4J Version 1.2 - 2019-02-26 Based on Java 8 Documentation website V1.2 Pi4J Version 1.1 - 2016-07-26 Documentation webiste V1.1 Pi4J Version 1.0 - 2015-04-18 Documentation website V1.0 "},{"uri":"https://pi4j.com/about/info-v2/","title":"What&#39;s New in V2","tags":[],"description":"","content":"As of versions 2.X.X, Pi4J no longer includes support for peripheral devices and add-on chipsets/boards as part of the core project. A new plugin model has been introduced in version 2.0 that helps to enable third-party development and support third-party add-ons which can be developed and maintained independently of the core Pi4J project.\nV2-versions of Pi4J require Java 11 or higher.\nWhat\u0026rsquo;s New in V2? Pi4J V2 brings with it many new features, and an entirely new architecture that focuses on extensibility, simplified integration and a modern Java API including the following:\nFluent APIs/Interfaces Immutable Runtime Context Extensible Provider/Platform/Plug-in Architecture Builder-patterns for creating new I/O instances Well-documented source code Hardware PWM Support Java 11 Future plans:\nDependency Injection via Pi4J Annotations Remote I/O Support (via TCP/IP) In addition to the features listed above, Pi4J version 2.0 also abandons the old WiringPi pin numbering scheme in favor of the more traditional and commonly used Broadcom pin numbering scheme. This pin numbering scheme has been a source of confusion for a number of years, especially with beginners and is somewhat cumbersome to maintain as new Raspberry Pi models are introduces with differing or added GPIO pins. Moving forward, Pi4J will only use the Broadcom (BCM) pin numbering scheme.\nThe WiringPi project has now been deprecated (see wiringpi.com/wiringpi-deprecated/). Pi4J version 2.0 will no longer be based on WiringPi and has moved to using the PIGPIO library (http://abyz.me.uk/rpi/pigpio/) internally for low level integation. With this move, we will also support the remote I/O features (via TCP socket) offered by the PIGPIO daemon (http://abyz.me.uk/rpi/pigpio/pigpiod.html).\nWhat are the differences compared to V1? Starting with the Pi4J 2.0 builds, the Pi4J project is prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform. Earlier versions of Pi4J were perhaps too ambitious in scope and that led to significant project bloat to the point that the project was becoming unsustainable. The goal moving forward is to limit scope to that of the raw I/O capabilities of the Raspberry Pi platform and provide timely updates and releases for bug fixed and new RaspberryPi model introductions. Reducing the scope of the project should better serve the Java community for basic I/O access by reducing complexity.\nThe following features have been removed from the Pi4J library:\nIO Expanders \u0026ndash; IO expansion is still supported but concrete implementations should be provided outside the core Pi4J core project such that they can be maintained and extended independently. Other Platforms \u0026ndash; Other platforms such as Odroid, BananaPi, NanoPi, OrangePi, etc. have been removed and will no longer be supported. The challenge with supporting these additional platforms is that Pi4J depends on the underlying WiringPi project and WiringPi ports for these other platforms is not well supported by the various SoC vendors or community. The various WiringPi ports for these other platforms are also inconsistent causing inconsistent features and functionality of Pi4J. Additionally, regression testing of bug fixes and new features in Pi4J is compounded with each additional supported platform. Components \u0026amp; Devices \u0026ndash; Pi4J originally provided higher level interfaces for components and devices that provided an abstraction layer between real world devices (things) and lower-level I/O interfaces. While a noble goal, unfortunately this part of the project never received the attention and time that it deserved and never gained much adoption by the community. We are removing these to allow Pi4J to focus solely on the raw I/O supported by the Raspberry Pi platform. Sources The Pi4J V2+ source code is available in this GitHub repository: pi4j/pi4j GitHub Repository\ngit clone https://github.com/Pi4J/pi4j Pi4J V2 had the first release in August 2021. Rework from V1 to V2 took quit some time and will never be finished, but we are confident this is a great library to develop Java application on the Raspberry Pi. Any remarks and contributions are welcome as either bug reports or discussions in the GitHub repository.\n"},{"uri":"https://pi4j.com/about/info-v3/","title":"What&#39;s New in V3","tags":[],"description":"","content":"Versions 3.0.1 is based on 2.8.0 (released in January 2025), but bumps the Java version to 21!\nWe asked our users which minimal Java version we should use, but there was no one clear answer, as expected ;-)\nThe current/latest Long Term Support (LTS) version of Java is version 21. So it makes sense to jump forward from 11 to 21. This will also prepare us for the next LTS, which will be Java 25 in September 2025. Bumping to the latest LTS makes it possible to make use of many newer Java language and runtime improvements, simplify parts of the code, etc.\nWe would like to move to Java 22 as this would allow us to easier call C code to interact with the GPIOs, thanks to JEP 454: Foreign Function \u0026amp; Memory API. Unfortunately, 22, is not a LTS, so it would force us to bump the version every six months with each new release, up till 25.\nWhat\u0026rsquo;s New in V3? The first V3-release of Pi4J, version 3.0.1, is a continuation of 2.8.0, but bumps the minimal Java version to 21 and includes some improvements, see the release notes.\nSources The Pi4J V3 source code is available in this GitHub repository: pi4j/pi4j GitHub Repository\ngit clone https://github.com/Pi4J/pi4j "},{"uri":"https://pi4j.com/examples/jbang/","title":"JBang Examples","tags":["JBang"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-jbang\nWant to get started with Java programming on the Raspberry Pi?\nJBang is a great way to create your first program to control electronic components connected to the GPIO pins. What is JBang?\nWhat is JBang? As described on their website:\nJBang lets Students, Educators and Professional Developers create, edit and run self-contained source-only Java programs with unprecedented ease.\nWant to learn, explore or use Java instantly without setup? Do you like Java but use python, groovy, kotlin or similar languages for scripts, experimentation and exploration? Ever wanted to just be able to run Java from anywhere without any or very minimal setup? Ever tried out Java 11+ support for running .java files directly in your shell but felt it was a bit too cumbersome? JBang lets you do all this!\nGet Started with JBang on Raspberry Pi Prerequisites A Raspberry Pi with recent Raspberry Pi OS. Install JBang as described on jbang.dev/download. JBang will install Java if it\u0026rsquo;s not installed yet. # Install JBang $ curl -Ls https://sh.jbang.dev | bash -s - app setup # Check JBang by requesting its version $ jbang --version 0.109.0 OPTIONAL: Use Visual Studio Code, the free IDE. # Install Visual Studio Code $ sudo apt install code OPTIONAL: Install the following extensions in Visual Studio Code: Language Support for Java(TM) by Red Hat JBang Example scripts The Pi4J JBang project on GitHub contains several examples to demonstrate both JBang and Pi4J. Each java-file is a full-containing runnable JBang application. This means you don\u0026rsquo;t need Maven, Gradle, or other Java build tool.\nTo tell JBang that it must handle the file as a Java application and do some upfront preparation work, the first line in each file is: ///usr/bin/env jbang \u0026quot;$0\u0026quot; \u0026quot;$@\u0026quot; ; exit $?.\nWhen an application needs dependencies, they are defined inside the file itself in a line starting with //DEPS. For instance, to use the Pi4J Core library: //DEPS com.pi4j:pi4j-core:2.3.0.\nEach of the provided examples contains more information about the wiring inside the file itself and are also explained here on the Pi4J website.\nGet the Examples from GitHub You can clone the project with the examples to your Raspberry Pi in the terminal with the following commands:\n$ git clone https://github.com/Pi4J/pi4j-jbang $ cd pi4j-jbang Detailed Info of Each Example The examples in the GitHub project are explained on these pages:\nMinimal Example 8x8 LED Matrix BME280 Sensor Pixelblaze Output Expander Controlling a LED Matrix LED strip with a JavaFX UI Video Demo This approach to demonstrate Pi4J with JBang has been explained and demonstrated on Voxxed Days Brussels on May 23th, 2023.\n"},{"uri":"https://pi4j.com/architecture/about-the-code/build-instructions/","title":"Build Instructions","tags":[],"description":"","content":"Building the Pi4J Project is simple and requires minimal effort. Pi4J is primarily built using Apache Maven and Java 21. Pi4J can be built directly on your host computer or inside a Docker container where all toolchains and dependencies are already installed, configured and cached.\nIf you wish to build using a Docker container, please skip ahead to the Building with Docker topic.\nPrerequisites In order to build Pi4J, the host system must have the following toolchains pre-installed.\nName Version URL Java Development Kit (JDK) 11.0.7 (or newer) https://openjdk.java.net/ Apache Maven 3.6.3 (or newer) https://maven.apache.org/download.cgi Build Environment The JAVA_HOME system environment variable must be configiured to point to the JDK installed path.\nBuilding with Maven To build the Pi4J project, use the following Maven comand from the parent Pi4J directory.\nmvn clean install If you prefer to skip all unit/integration testing, use the folllowing Maven command:\nmvn clean install -DskipTests Building with Docker Alternatively, the Pi4J project can be entirely compiled inside a prebuilt Pi4J Builder Docker container. This eliminates the need/requirement to install the build toolchains and configure your system to build Pi4J. To build the Pi4J project using Docker, run the following shell script from the parent Pi4J directory.\n./build-docker.sh The project which provides these Docker images can be found on GitHub \u0026gt; Pi4J/pi4j-docker and includes an extensive README with the full info on how to build and use these images.\nExtract from the README:\nThis project contains the Dockerfiles and build scripts to create the Pi4J builder\ndocker images used for compiling/building the Pi4J projects. The Pi4J builder images include the following:\nPi4J Base Builder pi4j/pi4j-builder-base:latest : This is the base image used by all the other builder images. It's based on Ubuntu 18.04 with JDK 11 and Maven pre-installed. This image's entry point is a Bash shell. (https://hub.docker.com/repository/docker/pi4j/pi4j-builder-base)\nPi4J Native Builder pi4j/pi4j-builder-native:latest : This image is derived from pi4j/pi4j-builder-base and adds support for native cross-compilers and build tools for architectures: arm, armhf, aarch64/arm64. This image's entry point is a bash shell attempting to execute the file ./build.sh in the volume mounted under the /build path.\nPi4J v1.4 Builder pi4j/pi4j-builder:1.4 : This image is derived from pi4j/pi4j-builder-native and additionally includes pre-cached Maven build plugins and dependencies for Pi4J v1.4 builds. This image's entry point is a Maven shell. If not explicitly provided, the default maven build arguments will be: clean install -DskipTests -Pall-platforms. This will effectively build all Pi4J projects including the pi4j-native project containing native libraries which will be cross-compiled for RaspberryPi/ARM (32-bit \u0026amp; 64-bit) devices.\nPi4J V2+ Builder pi4j/pi4j-builder:2.0 : This image is derived from pi4j/pi4j-builder-native and additionally includes pre-cached Maven build plugins and dependencies for Pi4J V2+ builds. This image's entry point is a Maven shell. If not explicitly provided, the default maven build arguments will be: clean install -DskipTests -native. This will effectively build all Pi4J projects including the native library projects which will be cross-compiled for RaspberryPi/ARM (32-bit \u0026amp; 64-bit) devices.\nNote: Pi4J versions prior to v1.4 are not currently tested or supported in these Docker images.\nBuilding Pi4J Native Libraries Pi4J V2+ also includes native libraries that will need to be compiled if you are modifying any native code. Most users will never need to compile the native libraries as these artifacts are automatically downloaded when building the Pi4J JARs from Maven repositories. One of the following commands can be used to build the Pi4J JARs and Native Libraries:\nmvn clean install -Pnative mvn clean install -Pnative,docker mvn clean install -Pnative,cross-compile See the custom build profiles in the Custom Build Profiles section for more information about the profiles illustrated in these commands.\nAdditional information about Docker Builds vs Cross-Compiler builds can be found here: https://github.com/Pi4J/pi4j/issues/21#issuecomment-651976487\nCustom Build Profiles The Pi4J Maven build includes a number of custom profiles that can be activated to perform various build steps.\nProfile Description Notes sources Package raw sources for each JAR Only needed when performing a snapshot or release build. javadoc Compile and package JavaDoc for each JAR Only needed when performing a snapshot or release build. native Compile any native libraries included in the build Only needed when modifying native code or performing a snapshot or release build. docker Use docker builder containers to compile native library artifacts Only used when incuding the native profile or performing a snapshot or release build. cross-compile Use cross-compilers on host to compile native library artifacts Only used when incuding the native profile or performing a snapshot or release build. test-hardware Perform hardware integration testing EXPERIMENTAL mac Use docker builder containers to compile native library artifacts (Same as docker profile) Automatically activated when running build from a MacOS host system. windows Use docker builder containers to compile native library artifacts (Same as docker profile) Automatically activated when running build from a Windows host system. transfer Perform SSH/SCP file transfers for each JAR to a remote Raspberry Pi Used for parallel development and testing. You can activate a build profile using the -P{profile-name} argument in the Maven command:\nmvn clean install -Pjavadoc Release/Snapshot Builds Pi4J release and snapshot builds are reserved for the Pi4J Development Team. A release build ensures all JARs, resources, source-bundles, native libraries, and javadoc artifacts are compiled and deployed to the public Maven repositories. You can use the following command to perform all the build steps that would be performed during a release or snapshot build.\nmvn clean install -Drelease-build "},{"uri":"https://pi4j.com/examples/crowpi/crowpi-examples/","title":"CrowPi examples","tags":["Pi4J OS","CrowPi"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-crowpi\nThe CrowPi example code contains examples for the following components. The links in this table will bring you to the German documentation written by the students who created these examples.\nComponent Link 7-Segment Display seven-segment Button button Button Matrix button-matrix Buzzer buzzer Infrared Receiver ir-receiver LCD Display lcd-display LED Matrix led-matrix Light sensor light-sensor PIR Motion Sensor pir-motion-sensor Relais relay RFID rfid Step motor step-motor Servomotor servo-motor Sound Sensor sound-sensor Temperature and humidity sensor humi-temp-sens Tilt Sensor tilt-sensor Touch Sensor touch-sensor Ultrasonic distance sensor ultrasonic-sensor Vibration motor vibration-motor "},{"uri":"https://pi4j.com/documentation/","title":"Documentation","tags":[],"description":"","content":"Pi4J wants to provide the best possible solution for Java development on the Raspberry Pi for two use-cases.\nDo you want to develop an application without the need to touch the internal code of Pi4J? In that case you\u0026rsquo;re at the right place for all the documentation you need! In this section you can find multiple examples to get you started.\nDo you want to go a few steps further and contribute to Pi4J, extend it with additional plugins or understand how it is build? In that case you\u0026rsquo;ll find more information in the Architecture/Design section. Table of contents of the \u0026ldquo;Documentation\u0026rdquo; section Pi4J API JavaDoc Pin numbering Java for ARMv6/7/8 Logging with SLF4J Creating a Pi4J Context Choosing a Platform Raspberry Pi Choosing an I/O Provider GpioD Provider LinuxFS Provider PiGpio Provider Using Board Info Building an I/O Instance I/O Examples Digital Output (GPIO) Digital Input (GPIO) Pulse Width Modulation (PWM) Inter-Integrated Circuit (I²C) I²C Clock Stretching Serial Peripheral Interface (SPI) Serial (UART/RS232) 1-Wire I/O Registry Shutdown (cleanup) Building and running Building with javac Build as a FAT JAR with Maven Build Java modules with Maven Build Java modules with Gradle Running Pi4J with JBang "},{"uri":"https://pi4j.com/examples/","title":"Example Implementations","tags":[],"description":"","content":"The core Pi4J V2+ library doesn\u0026rsquo;t contain any specific support for devices like buttons, motors, LCD\u0026hellip; This was part of V1 but made the project much more difficult to maintain and fully test the library.\nIn this section, we want to provide you example implementations of several devices that are maintained by the community.\nCurrent code providers Provider Link Pi4J JBang examples FHNW University Components FHNW University Electronics with CrowPi Community Implementation Community Implementation Simple Implementation For a simple implementation of a project with one of the components, the recommendation is to use the Template-Project. The Readme.md describes how to get started with the project.\nElectrical Engineering General inputs and help on electrical engineering can be looked up on the Getting started with PI4J / Electrical Engineering page.\nTable of contents of the \u0026ldquo;Example Implementations\u0026rdquo; section JBang Examples Minimal Example 8x8 LED Matrix BME280 Sensor Pixelblaze Output Expander Controlling a LED Matrix LED strip with a JavaFX UI Component Examples Simple Button Simple LED AD Converter ADS1115 Buzzer Camera Joystick Joystick Analog LCD Display LED Button LED Matrix LED Strip Potentiometer ServoMotor Electronics with CrowPi Develop with Intellij IDEA CrowPi examples Community Implementations Prototype Board BMP280 Sensor "},{"uri":"https://pi4j.com/documentation/javadoc/","title":"Pi4J API JavaDoc","tags":[],"description":"","content":"The source code of the Pi4J library is documented with JavaDoc. If you use the library in your IDE, you can download the library sources to have more code hints while coding.\nThanks to APIdia, this documentation is also available online on apidia.net/mvn/com.pi4j/pi4j.\n"},{"uri":"https://pi4j.com/getting-started/understanding-the-pins/","title":"Understanding the GPIO pins","tags":[],"description":"","content":"Connecting electronic components to the Pi is done via one or more of the pins in the so-called header. The number of pins has \u0026ldquo;grown\u0026rdquo; between the different Raspberry Pi board versions, but all recent ones have a 40-pin header. It\u0026rsquo;s of course important to be aware of the correct numbering to not connect components the wrong way.\nType of Pins The pins have different uses\nPower and Ground Both 5V and 3.3V are available as power pins and, of course, also ground pins. Anytime the board is powered you have a fixed power supply available for your components. You have to take into account not to connect devices that need a lot of current, otherwise the Raspberry Pi itself will not behave as expected and reboot for instance.\nDigital GPIO The other ones are \u0026ldquo;General-Purpose Input/Output\u0026rdquo; (GPIO) pins. These pins can be addressed with software to act as input or output for an application. They use 3.3V, meaning an output pin will be set to 0V (low) or 3.3V (high) and an input pin will read 0V as low and 3.3V as high.\nMost of the GPIOs have an internal pull-up or pull-down resistor which can be enabled in software.\nMany electronic components need a different voltage level! For instance, some components created for Arduino, operate on 5V. They will not work reliably with a Raspberry Pi as the GPIOs only provide or expect 3.3V. If you need to connect components with a different voltage, you\u0026rsquo;ll need to use a \u0026ldquo;Level Shifter\u0026rdquo;, for instance: Adafruit QT 3V to 5V Level Booster Breakout.\nOverview The following image gives you an overview of the pins and types of a typical 40-pin header. Note the different numbers being used:\nPIN: 1 to 40 logical order of the pin BCM: the number to be used in your Java code to specify the GPIO to be used. BCM refers to the \u0026ldquo;Broadcom SOC channel\u0026rdquo; number, which is the numbering inside the chip which is used on the Raspberry Pi. These numbers changed between board versions as you can see in the previous tables for the 26-pin header type 1 versus 2, and or not sequential. WPI: WiringPi number which was used by V1 of Pi4J. The WiringPi numbering has a \u0026ldquo;historical reason\u0026rdquo;. When development for the very first Raspberry Pi\u0026rsquo;s was ongoing, only 8 pin-numbers were foreseen. But, when the designs further evolved and more pins were added, the numbering in WiringPi was extended to be able to address the extra pins. "},{"uri":"https://pi4j.com/debugging-failures/","title":"Debugging Failures","tags":["Pi4J OS"],"description":"","content":"Combining software with hardware can fail on many levels. You need the correct version of the Operating Systems, the good version of the Pi4J library, the wiring between the Raspberry Pi and the electronic components must be correct, and so on\u0026hellip;\nStartup Failures Always make sure that you log errors in the terminal or into a file! When the Pi4J library initializes, a lot of useful info is outputted. A successful start looks like this:\nPi4J - New auto context Pi4J - New context builder BoardInfoHelper - Detected OS: Name: Linux, version: 6.6.20+rpt-rpi-v8, architecture: aarch64 BoardInfoHelper - Detected Java: Version: 21.0.2, runtime: 21.0.2+13-LTS, vendor: Azul Systems, Inc., vendor version: Zulu21.32+17-CA BoardInfoHelper - Detected board type MODEL_4_B by code: c03112 DefaultContext - Detected board model: Raspberry Pi 4 Model B DefaultContext - Running on: Name: Linux, version: 6.6.20+rpt-rpi-v8, architecture: aarch64 DefaultContext - With Java version: Version: 21.0.2, runtime: 21.0.2+13-LTS, vendor: Azul Systems, Inc., vendor version: Zulu21.32+17-CA DefaultRuntime - Initializing Pi4J context/runtime... ... DefaultRuntime - Pi4J context/runtime successfully initialized. Error Pi4J provider [xxx-yy] could not be found You can get this error with a new application, or after you upgraded your code base to use Pi4J 2.6.0 or newer.\nFrom version 2.6.0 on, each IO-Type has a single provider loaded. For example, you can no longer have linuxfs-i2c and pigpio-i2c loaded at the same time. When your application starts, you can check the logging output which will show the decisions used to select which providers are loaded. For example:\nDefaultRuntime - Ignoring provider DIGITAL_INPUT RaspberryPi Digital Input (GPIO) Provider with priority 0 as lower priority than GpioD Digital Input (GPIO) Provider which has priority 150 DefaultRuntime - Ignoring provider DIGITAL_OUTPUT RaspberryPi Digital Output (GPIO) Provider with priority 0 as lower priority than GpioD Digital Output (GPIO) Provider which has priority 150 If you encounter this error, and the provider used in your code is not available, edit your `pom.xml to contain the provider you require and remove the other provider of the same IO-Type.\nSee Choosing an I/O Provider for a more complete explanation.\nError GLIBC_2.33 not found When the error GLIBC_2.33 not found is shown in the startup log, you need to update the Operating System as the required dependencies are not available to communicate with the GPIOs.\n[main] ERROR com.pi4j.library.gpiod.util.NativeLibraryLoader - Unable to load [libgpiod.so] using path: [/lib/aarch64/pi4j-gpiod/libgpiod.so] java.lang.UnsatisfiedLinkError: /tmp/libgpiod14998985341386605622.so: /lib/aarch64-linux-gnu/libc.so.6: version GLIBC_2.33\u0026#39; not found (required by /tmp/libgpiod14998985341386605622.so) at java.base/jdk.internal.loader.NativeLibraries.load(Native Method) at java.base/jdk.internal.loader. ... Exception in thread \u0026#34;main\u0026#34; java.lang.UnsatisfiedLinkError: Pi4J was unable to extract and load the native library [/lib/aarch64/pi4j-gpiod/libgpiod.so] from the embedded resources inside this JAR [/home/pi/maven/pi4j-example-minimal/target/distribution/./pi4j-library-gpiod-2.7.0.jar]. to a temporary location on this system. You can alternatively define the \u0026#39;pi4j.library.path\u0026#39; system property to override this behavior and specify the library path. Error pigpio initialisation failed For some Pi4J functionality, root privileges are required. If you get an error like this, you need to execute your application with sudo:\n[main] INFO com.pi4j.util.Console - [main] WARN com.pi4j.library.pigpio.impl.PiGpioNativeImpl - PIGPIO ERROR: PI_INIT_FAILED; pigpio initialisation failed Exception in thread \u0026#34;main\u0026#34; java.lang.reflect.UndeclaredThrowableException ... Caused by: java.lang.reflect.InvocationTargetException ... Caused by: com.pi4j.library.pigpio.PiGpioException: PIGPIO ERROR: PI_INIT_FAILED; pigpio initialisation failed Error: Could not execute cat /proc/cpuinfo | grep 'Revision' | awk '{print $3}' to detect the board model This error occurs in Pi4J version 2.7.0, due to a problem where a shell command is used to detect the board model, but fails with a permission error (IOException: Cannot run program \u0026quot;sh\u0026quot;: error=13, Permission denied).\nSolutions:\nUpgrade to Pi4J Version 2.7.1 or Newer: In version 2.7.1, this issue has been resolved. The /proc/cpuinfo file is read directly in Java without using shell commands, avoiding the permission issue entirely.\nGrant Execution Permission to jspawnhelper: If upgrading is not immediately possible, you can manually fix the issue by ensuring the jspawnhelper utility in the Java runtime has execution permissions. Run the following command:\nchmod +x JAVA_HOME/lib/jspawnhelper Replace JAVA_HOME with the actual path to your Java installation. This ensures that Java can execute shell commands without permission errors.\nUnexpected Results on Electronic Components If your software starts OK, and the log output shows that everything works as expected, but you still don\u0026rsquo;t get the desired result on the connected electronic component, check:\nAre all the required wires connected? Are they connected correctly? Did you check the orientation of the pin numbering, where is pin 1? "},{"uri":"https://pi4j.com/architecture/","title":"Architecture/Design","tags":[],"description":"","content":"The code of Pi4J is based on a layered approach, visualized in the picture below.\nSince Pi4J is a low-level library, it tries to avoid inheriting third-party libraries at all costs. More complex dependency chains make it more difficult for users, especially novice users. Therefor, the only dependency Pi4J V2+ has is SLF4J to provide a standardized and extensible logging framework.\nThe dark grey blocks \u0026ldquo;Annotation Engine\u0026rdquo;, \u0026ldquo;@Register\u0026rdquo; and \u0026ldquo;@Inject\u0026rdquo; are here as a future idea but are not included in the current version.\n"},{"uri":"https://pi4j.com/getting-started/electrical-engineering/","title":"Electrical Engineering","tags":[],"description":"","content":"The goal of the Pi4J project is to combine sofware (Java) with hardware (electronic components). On this page we give you some tips and tricks for the electronics part.\nBreadboard A breadboard is the basic for each experiment. It allows you to easily connect several components to each other and the Raspberry Pi. Here is a video that explains the basics of breadboards:\nBreadboard\nThe red and blue lines on the side show which pins are connected. Be aware that red and blue can also be swapped, because not all suppliers use them in the same position.\nOn some boards these lines are interrupted in the middle (see picture breadboard). This means at this point, the pins are interrupted and not electrically connected.\nResistor Dimensioning Resistors can be used for different effects. One application is to improve the stability of the application with PullUp and PullDown resistors. Another application is to use resistors to protect the PI against voltage peaks or short circuit currents.\nPullUp PullDown In electronic logic circuits, a pull-up resistor or pull-down resistor is a resistor used to ensure a known state for a signal. It is typically used in combination with components such as switches and transistors, which physically interrupt the connection of subsequent components to ground or to VCC. Closing the switch creates a direct connection to ground or VCC, but when the switch is open, the rest of the circuit would be left floating (i.e., it would have an indeterminate voltage).\nFor a switch that is used to connect a circuit to VCC (e.g., if the switch or button is used to transmit a \u0026ldquo;high\u0026rdquo; signal), a pull-down resistor connected between the circuit and ground ensures a well-defined ground voltage (i.e. logical low) across the remainder of the circuit when the switch is open. For a switch that is used to connect a circuit to ground, a pull-up resistor (connected between the circuit and VCC) ensures a well-defined voltage (i.e. VCC, or logical high) when the switch is open.\nThe size of the resistor can vary between 1kOhm and 100kOhm. Here it is necessary to weigh what is useful for the application. The closer the resistor is to 0, the stronger the level is defined, but the greater the current consumption in the open state. The higher the resistance, the less current is consumed in the off state, but the more unstable the signal becomes. For a start value PullUp and PullDown resistors with 10kOhm are to be used.\nPullUp Pull Down Breadboard\nPullUp electrical drawing\nPullDown electrical drawing\nVoltage Divider If components have a lower operating voltage than the 3.3V of the Raspberry Pi, a voltage divider can be used to achieve the desired voltage. For example, a red LED has an operating voltage of 1.8V. This means that 1.5V must drop across a second load. If we assume that the LED needs 20mA of current, this means that we should connect a resistor of 75 Ohm in series to the LED.\nIf the required current and the required voltage of the load are known, the exact required resistance can be calculated here.\nVoltage Divider Breadboard\nVoltage Divider electrical drawing\n3.3V \u0026lt;\u0026ndash;\u0026gt; 5V Level Shifter To protect the Pi from 5V devices, a level shift/conversion can be done with the \u0026ldquo;Adafruit TXB0104 Bi-Directional Level Shifter\u0026rdquo; component. The bi-directional level shifter works for an I2C bus, for a TTL serial connection, for a slow \u0026lt;2MHz SPI connection and any other digital interface both uni- and bidirectional.\nLogic Level Converter\nAdditional Power Supply If one or more large loads are required for the project, it may be necessary to use an additional power supply. A solution for this is the Mini Power Supply Module HW-131 Breadboard Power Module which provides two voltages 3.3V and 5V and a maximum output current of 700mA.\nMini Power Supply Module\nMini Power Supply Module Front Back\nDo not use the USB port of the computer to power the electronics. Errors in the wiring can destroy the USB port of the computer.\nIn case of an additional power supply, the ground of the Raspberry Pi and the ground of the power supply must be connected to each other.\nSoldering Tutorial A video that explains the basics of soldering:\nA video that explains how to remove solder:\nIf a breakout with two pin headers like the TXB0104 is used, the pin headers can be mounted on the breadboard first, then the breakout is placed on the pin headers and finally everything can be soldered. So the pin headers are mounted exactly in 90° angle to the breakout and can be mounted on the breadboard without any problem.\nSoldering Two Pins Part 1\nSoldering Two Pins Part 2\nAutomatic Wire Stripper A video that explains how the automatic wire stripper works:\nAutomatic Wire Stripper\nCrimping Tutorial A video that explains the basics of crimping wires:\nCrimping Tool\nIf the crimp connection does not hold, the following measures can lead to a better connection: - Strip wire to double length, lay on top of each other and twist (see picture below) - The crimping tool is too short, crimp the sleeve twice in different places (see picture below)\nStrip double length\nCrimping step 1\nCrimping step 2\nCrimping step 3\nCrimping step 4\nCrimping Ferrules Tutorial A video that explains the basics of crimping ferrules to wires:\nCrimping Ferrules Tool\n"},{"uri":"https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/","title":"Java development with VSC","tags":["Visual Studio Code"],"description":"","content":"Java on the Raspberry Pi You need Java 21 or newer to use Pi4J V3+. Please check the Prepare a Raspberry Pi and Install Java and Tools instructions. On a board with ARMv7 or ARMv8 you will get this result:\n$ java -version openjdk version \u0026#34;21.0.5\u0026#34; 2024-10-15 LTS OpenJDK Runtime Environment Zulu21.38+21-CA (build 21.0.5+11-LTS) OpenJDK 64-Bit Server VM Zulu21.38+21-CA (build 21.0.5+11-LTS, mixed mode, sharing) Keep in mind this version is only compatible with ARMv7 or higher and doesn\u0026rsquo;t support all Raspberry Pi board versions. If you have a Raspberry Pi A (version 3), B (version 2 or higher), or Compute (version 3 or higher), you are good to go! For all other boards, or if you get the error below, you will need some additional steps that are described on Java for ARMv6/7/8.\n$ java -version Error occurred during initialization of VM Server VM is only supported on ARMv7+ VFP Maven Pi4J is using Maven as build tool, this allows you to compile your code with the required modules into JAR-file thanks to the pom.xml configuration file which you can find in the root of a project. We need to install Maven and can do this with a single command, after which we can immediately check the installation by requesting the version:\n$ sudo apt install maven $ mvn -v Apache Maven 3.6.0 Maven home: /usr/share/maven Visual Studio Code Please check Prepare a Raspberry Pi \u0026gt; Install Visual Studio Code for more info if you want to develop Java code directly on the Raspberry Pi.\n"},{"uri":"https://pi4j.com/architecture/about-the-code/maven-settings/","title":"Maven settings","tags":[],"description":"","content":"To simplify development but not commit sensitive information, you can add personal or PC-specific settings in the Maven settings.xml file. This file is stored or needs to be created in the \u0026ldquo;.m2\u0026rdquo; directory in your home directory:\nWindows: C:\\Users\\YOUR_NAME.m2 Linux: /home/YOUR_NAME/.m2 Mac: /Users/YOUR_NAME/.m2 For more info see this article on Baeldung.\nThis is an example settings file, including settings for compiling of Pi4J and credentials to upload the generated code to a Raspberry Pi.\n\u0026lt;settings xmlns=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd\u0026#34;\u0026gt; \u0026lt;localRepository/\u0026gt; \u0026lt;interactiveMode/\u0026gt; \u0026lt;offline/\u0026gt; \u0026lt;pluginGroups/\u0026gt; \u0026lt;servers/\u0026gt; \u0026lt;mirrors/\u0026gt; \u0026lt;proxies/\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;pi4j\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- Docker compiler settings --\u0026gt; \u0026lt;pi4j.native.compiler\u0026gt;DOCKER-COMPILER\u0026lt;/pi4j.native.compiler\u0026gt; \u0026lt;!-- SSH credentials of your test Raspberry Pi --\u0026gt; \u0026lt;pi4j.dev.transfer\u0026gt;false\u0026lt;/pi4j.dev.transfer\u0026gt; \u0026lt;pi4j.dev.host\u0026gt;192.168.1.1\u0026lt;/pi4j.dev.host\u0026gt; \u0026lt;pi4j.dev.port\u0026gt;22\u0026lt;/pi4j.dev.port\u0026gt; \u0026lt;pi4j.dev.user\u0026gt;pi\u0026lt;/pi4j.dev.user\u0026gt; \u0026lt;pi4j.dev.password\u0026gt;raspberry\u0026lt;/pi4j.dev.password\u0026gt; \u0026lt;pi4j.dev.directory\u0026gt;/home/pi/pi4j-temp\u0026lt;/pi4j.dev.directory\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;activeProfiles\u0026gt; \u0026lt;activeProfile\u0026gt;pi4j\u0026lt;/activeProfile\u0026gt; \u0026lt;/activeProfiles\u0026gt; \u0026lt;/settings\u0026gt; "},{"uri":"https://pi4j.com/documentation/pin-numbering/","title":"Pin numbering","tags":[],"description":"","content":"Pi4J V1 took a pretty opinionated approach to pin numbering as the scheme was based on the underlying WiringPi. This scheme was incompatibility with other pin diagrams and pin numbering used by other development platforms and libraries.\nAs Pi4J V2+ is build as a \u0026ldquo;pass thru library\u0026rdquo;, and uses PiGpio and other tools as the underlying framework. The more well-known BCM numbering is being used now.\nThis drawing shows the different numbers for WiringPi and BCM in a 40-pins Raspberry Pi header:\n"},{"uri":"https://pi4j.com/about/release-notes/","title":"Release Notes","tags":[],"description":"","content":"All releases of Pi4J V2+ are listed on github.com/Pi4J/pi4j/releases.\nV3 Requires Java 21, see What\u0026rsquo;s New in V3 for more info.\n2025-05-20 - V3.0.2 Board model can now be forced to allow the use of Pi4J on other/unrecognized boards. See Overriding the Detected Board for more info. BoardInfoHelper.usesRP1() has been improved as more boards use this RP1 (5, 500, Compute 5), and even more are expected in the future. Issue #455: GpioDDigitalInput may never start monitoring line events. Fixed by simplifying and improving the wait for the input listener loop to exit on shutdown. APIdia badge and link added to README.md Pull request #461: Removal in the core code of the SpiChipSelect to enforce a PiGpio limitation of the values 0, 1, or 2. Thanks to contributions by @ylexus, @taartspi, @eitch, @fdelporte.\nAll changes: https://github.com/Pi4J/pi4j/compare/3.0.1...3.0.2\n2025-03-24 - V3.0.1 This is the first release of Pi4J that requires Java runtime 21 or higher. Check the blog post Pi4J welcomes Java 21 to understand why we needed this change to prepare the project for the future\u0026hellip;\nBecause of a last-minute change to improve the detection of Raspberry Pi 5, 500, and Compute 5, release 3.0.0 has been skipped.\nBump the Java version to 21 and update many dependencies, such as the Maven plugin. Added JNA dependency (needed for Java 21). Added Maven wrapper. Improved lifecycle shutdown handling for registry elements: Updated the Lifecycle interface to clarify shutdown behavior and added tests to ensure proper element recreation after shutdown. These enhancements make the shutdown process more robust and intuitive. Issue #308: Remove serial support from Pi4J. All serial methods are marked as @Deprecated(forRemoval = true). We advise using jSerialComm for all serial communication. Pull request #438: Extra unit test for shutdown and re-creation of a DigitalInput. Issue #439: Allow Specifying GPIO Chip for GpioDContext. For more info on how to use, see Specifying the GPIO Chip. Pull request #449: Fixes a minor bug in DigitalOutput where pulseAsync ignored the given state and always pulsed high. Pull request #452: PWM linuxfs failed if the first interface call was off(). Pull request #453 for issue #296: Generic BoardModels (with and without RP1) have been added, with a new method BoardInfoHelper.current().setBoardModel(BoardModel.GENERIC); to make it possible to use Pi4J on other types of boards, see Overriding the Detected Board. The goal of the Pi4J project is still to focus on the Raspberry Pi. However, this should allow testing the library\u0026rsquo;s compatibility with other boards with similar architecture. We are excited to hear from the community about possible improvements to this approach. Thanks to contributions by @stefanhaustein, @Haruka0522, @mpilone, @dariuszzbyrad, @taartspi, @eitch, @fdelporte.\nAll changes: https://github.com/Pi4J/pi4j/compare/2.8.0...3.0.1\nV2 Requires Java 11, see What\u0026rsquo;s New in V2 for more info.\n2025-01-28 - V2.8.0 Several code and JavaDoc improvements by adding the checkstyle plugin. Improvements in loading the Mock providers to build and test Pi4J on a Raspberry Pi. Issue #421: Unable to detect board type. Several improvements have been integrated in the board detection to prevent errors when reading the board code. Added to BoardModel: Issue #406: Old boards not auto detected. Missing codes have been added for Model 1 boards. The Raspberry Pi Compute 5. Only the board code c04180 for the 4Gb has been confirmed by Jeff Geerling. The other types are not documented yet. We assume they are a04180, b04180, and d04180, similar to the Compute 4, but will adjust whenever more info is available. The Raspberry Pi 500 with the board code d04190, again confirmed by Jeff who received an evaluation device. The Raspberry Pi 5 with 16GB memory with the board code e04171 (thanks again Jeff). Added to BoardReading: Pull request #432: Add Support for Throttled State Parsing and Retrieval Improvements in the LinuxFS provider (for Raspberry Pi 5): Pull Request #433: Enhance LinuxFsI2CBus validation with detailed exception messages and comprehensive Javadocs. Pull Request #434: Add SPI support in LinuxFS. No sudo is needed to use SPI. Thanks to contributions by @mpilone, @cniesen, @geerlingguy, @dariuszzbyrad, @taartspi, @eitch, @fdelporte.\nSpecial thanks to Dariusz Zbyrad for joining the project and improving the Maven builds with a wrapper for more consistency, for example, in the pi4j-example-devices repository, and other contributions. And also special thanks to Mike Pilone for the initial work for LinuxFS SPI.\nAll changes: https://github.com/Pi4J/pi4j/compare/2.7.0...2.8.0\n2025-01-28 - V2.8.0 Several code and JavaDoc improvements by adding the checkstyle plugin. Improvements in loading the Mock providers to build and test Pi4J on a Raspberry Pi. Issue #421: Unable to detect board type. Several improvements have been integrated in the board detection to prevent errors when reading the board code. Added to BoardModel: Issue #406: Old boards not auto detected. Missing codes have been added for Model 1 boards. The Raspberry Pi Compute 5. Only the board code c04180 for the 4Gb has been confirmed by Jeff Geerling. The other types are not documented yet. We assume they are a04180, b04180, and d04180, similar to the Compute 4, but will adjust whenever more info is available. The Raspberry Pi 500 with the board code d04190, again confirmed by Jeff who received an evaluation device. The Raspberry Pi 5 with 16GB memory with the board code e04171 (thanks again Jeff). Added to BoardReading: Pull request #432: Add Support for Throttled State Parsing and Retrieval Improvements in the LinuxFS provider (for Raspberry Pi 5): Pull Request #433: Enhance LinuxFsI2CBus validation with detailed exception messages and comprehensive Javadocs. Pull Request #434: Add SPI support in LinuxFS. No sudo is needed to use SPI. Thanks to contributions by @mpilone, @cniesen, @geerlingguy, @dariuszzbyrad, @taartspi, @eitch, @fdelporte.\nSpecial thanks to Dariusz Zbyrad for joining the project and improving the Maven builds with a wrapper for more consistency, for example, in the pi4j-example-devices repository, and other contributions. And also special thanks to Mike Pilone for the initial work for LinuxFS SPI.\nAll changes: https://github.com/Pi4J/pi4j/compare/2.7.0...2.8.0\n2024-10-03 - V2.7.0 Libraries are loaded depending on the platform, by calling BoardInfoHelper.runningOnRaspberryPi(). BoardModel has been extended with 2Gb Raspberry Pi 5, Raspberry Pi Pico 2, and extra board codes for the Compute Module 4. Allowing configuration of the shutdown hook. It\u0026rsquo;s disabled by default. Issue #354: Gracefully handle UnsatisfiedLinkError on newAutoContext. Issue #368: Mock providers don\u0026rsquo;t seem to be loaded on an non-RPi system. Issue #369: WARN noise in the log about Ignoring providers on every startup. Removed unnecessary String concatenations in logging statements. Reduced log output and reviewed warn levels to reduce to info where more applicable. Issue #383: Increase amount of write bytes to SPI devices over 65535. spiWrite has been modified to write data in chunks of 4096 bytes so it can handle larger messages. Issue #388: I2C writeRead method compares written to writeOffset instead of writeSize. Because of the changes in the loading of the mock providers, if you want to load them on a Raspberry Pi board, you need to use the following context builder:\nvar pi4j = Pi4J.newContextBuilder().autoDetectMockPlugins().autoDetectPlatforms().build(); Thanks to contributions by @ylexus, @mores, @taartspi, @eitch, @fdelporte.\nAll changes: https://github.com/Pi4J/pi4j/compare/2.6.1...2.7.0\n2024-07-29 - V2.6.1 This is a minor bug fix release to allow a smoother integration in a Spring Boot Starter by allowing to run on PC for testing without initialization errors and with reduced logging of the I2C Mock plugin.\nIssue #354: Gracefully handle UnsatisfiedLinkError on newAutoContext when not running on a Raspberry Pi, for instance, when testing on Windows or macOS. Clean up of logs in MockI2C.java. All changes: https://github.com/Pi4J/pi4j/compare/2.6.0...2.6.1\n2024-04-29 - V2.6.0 New hardware PWM provider added to the GpioD plugin, see: Blog: PWM Hardware Support on RPi5. Documentation: I/O Examples: Pulse Width Modulation (PWM). Various improvements in the I2C implementation in both core and plugins, see: Blog: Ongoing I2C Improvements. Dependency bumps in the pom file, see pull request #337. New BoardInfo included to detect type of Raspberry Pi board, providing a lot of info about the board, SoC, pins, etc., see: Documentation: Using Board Info. Example implementation and visualization on api.pi4j.com. Fix for \u0026ldquo;IOBase constructor do not update the fields id, name \u0026amp; description\u0026rdquo;. Issue #257: IOAlreadyExistsException when reopening Serial-connection. Issue #244: Multiple SPI throws IOAlreadyExistsException. Several code improvements and clean-up. Thanks to contributions by @fusetim, @taartspi, @eitch, @fdelporte.\nMake sure to also read the interviews with Robert von Burg and Tom Aarts.\nAll changes: https://github.com/Pi4J/pi4j/compare/2.5.1...2.6.0\n2024-03-18 - V2.5.1 Sorry! Because of a configuration error, the wrong native code is included in 2.5.0 for the new GpioD Provider. But thanks to the lightning fast action of Robert von Burg we have a fixed version for you to enjoy :-)\nAll changes: https://github.com/Pi4J/pi4j/compare/2.5.0...2.5.1\n2024-03-18 - V2.5.0 With over 100 commits from multiple branches, this is a major release with many improvements! With many thanks to the core team (Robert von Burg, Tom Aarts), and a major addition of Alexander Liggesmeyer, Pi4J is again lifted to a higher level!\nYou can find out more about Alexander in this blog post.\nThe new GpioD Provider needs the latest Raspberry Pi OS version (Debian GNU/Linux 12 (bookworm)).\nChanges in 2.5.0 A new GpioD Provider adds support for the Raspberry Pi 5. Issues #321, #320, #317 This new GpioD provider interfaces directly with the Raspberry Pi\u0026rsquo;s gpiochip device, located at /dev/gpiochip.... It leverages the native libgpiod library, which is developed as a part of the Linux kernel. Libgpiod is currently the recommended way to control GPIO pins. Therefore, using this provider is also recommended. This new provider can be used without the need to start a Pi4J application with sudo, so also fixes #212 when you only need DigitalInput and/or DigitalOutput. Better handling of mock Plugins: Plugins can now define if they are mocks, and these are not auto-detected anymore. The default target for the Pi4J library is the Raspberry Pi, and thus auto-detecting mocks on the Pi, which are only for tests is counterintuitive. Extended Providers with a priority: this priority helps to determine which Provider should be loaded, when multiple Providers with the same IOType are being loaded by different plugins. This change enforces that a given IOType can only have one Provider loaded at runtime preventing errors when, for instance, two I2C providers are loaded at the same time, concurrently writing to the I2C bus. Fix for: LinuxFile reused scratch buffers ensuring size was usable. But the limit value cannot be modified so later usage failed as an intended overwrite. Pull request #331, commit ed208f2. Fix for: I2C interface should use a restart between the write and read operation. Pull request #333. Fix for: Shutting down pool executor too early. Commit 7909a2d. ProviderProxyHandler got removed, simplifying provider loading, thus no more reflection on the instances. You can now add and remove IO instances at runtime. You can now easily switch a GPIO from output to an input and vice versa, see issue #26, extending on the work by @MEBoo, in pull request #1. A race condition got fixed in the default runtime registry. Proper life cycle management got added for of all threads in Pi4J. All changes: https://github.com/Pi4J/pi4j/compare/2.4.0...2.5.0\nKnown Issue java.io.IOException: Remote I/O error java.base/java.io.RandomAccessFile.writeBytes(Native Method). Using linuxfs-i2c, dependent upon i2c operations this exception can occur: If the program initially uses read or write, and later uses readRegister or writeRegister there is no exception. However, if the program initially uses readRegister or writeRegister subsequent write or read may encounter this exception. For more info and the temporary fix, check #335. 2023-10-24 - V2.4.0 Extended LinuxFS plugin PWM provider First set of implementations for Digital Input and Output To be further extended, see https://github.com/Pi4J/pi4j/issues/307 Don\u0026rsquo;t re-initialize pigpio twice, thus use singleton Implement blink method in DigitalOutputBase Added testcases for I2CRegisterDataReader, I2CRegisterDataWrite Fix I2C write register: multi byte register may fail with large data Fix mock SPI.transfer() functionality https://github.com/Pi4J/pi4j/issues/298 https://github.com/Pi4J/pi4j/issues/299 https://github.com/Pi4J/pi4j/issues/300 Add readEntireMockBuffer() method to class MockSpi Fix for data read over I2C becomes out of sync over a slower wireless network https://github.com/Pi4J/pi4j/issues/16 https://github.com/Pi4J/pi4j/issues/303 Use Socket#setSoTimeout to timeout read requests of GPIO socket implementation https://github.com/Pi4J/pi4j/issues/305 Thanks to @GeVanCo, @MMMMMNG, @IAmNickNack, @savageautomate, @eitch, @taartspi, @FDelporte.\nAll changes: https://github.com/Pi4J/pi4j/compare/2.3.0...2.4.0\n2023-02-06 - V2.3.0 Improvements for PIGPIO.gpioCfgInterfaces by @bwaldvogel. New i2c interface to support multibyte register address by @taartspi. Fix in LinuxFsI2C byte array offset by @harlanhu. Remove unused JNA references by @taartspi. All changes: https://github.com/Pi4J/pi4j/compare/2.2.1...2.3.0\n2022-10-17 - V2.2.1 Multiple fixes by @taartspi:\nBetter error message when mixing 32- and 64-bit artifacts SPI improvements: Add missing initialization in constructor Track weather the user set the mode or bus config values to improve the use of SPI flags All changes: https://github.com/Pi4J/pi4j/compare/2.2.0...2.2.1\n2022-08-30 - V2.2.0 What an amazing achievement! No major issues were found in the previous release, but several small fixes were added by more people than ever before in the Pi4J-history. This is a real confirmation of the openness of this project and how a community can work together to further improve a project.\nA big thank you to everyone who experimented with Pi4J, took part in the discussions, filed an issue, created a merge request, added examples,\u0026hellip;!\nNew example implementations Thanks to the work of FHNW students and @taartspi, the list of available example implementations has become larger and larger. We even moved them to their own section of this documentation website! Take a look at Example implementations if you need a quick-start to use a buzzer, camera, LED strip, TCA9548, MCP4725,\u0026hellip; or any of the other examples.\nChanges in V2.2.0 Multiple improvements were added in this release (and others are already in progress for the next one!):\nby @taartspi to improve SPI initialization, see #229 by @haumacher regarding the use of ByteBuffers, see #185 by @savageautomate regarding the polarity of digital output, see #93 by @gugrim to ensure positive values are returned from reading unless at end of file, see #164 by @eitch to also export LinuxFS I2C in module-info.java by @eitch to also copy native libs to distribution zip by @hagen to be able to configure sample rate and peripheral in PiGpio by Saskia Bikle to add an implementation of deregistration/shutdown for IO\u0026rsquo;s by @savageautomate to add a new value \u0026ldquo;flags\u0026rdquo; too SPI implementation All the differences can be checked by comparing with the previous release 2.1.1 via this link.\nV1 Up till version 1.3.0 requires Java 8, while version 1.4.0 requires Java 11. See Info about V1 for more info.\n"},{"uri":"https://pi4j.com/getting-started/developing-on-a-remote-pc/","title":"Developing on a remote PC","tags":["Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-maven-archetype\nDeveloping Java Programs Using a Remote PC Workstation Writing your Java program, compiling and running it directly on the Raspberry Pi board as shown in the previous chapter is perfectly fine, of course, but there is an alternative way to arrange your developing laboratory, using a normal desktop computer as Remote Developing Workstation (RDW).\nThis Maven Archetype will give you a tool to generate Pi4J V2+ skeleton Java projects. You can use it for your next Pi4j project and you will be able to develop your program on the remote workstation (RDW), compile them, transmit the executable code on the target Pi board and run it. You can also start a remote debugging session.\nThere are some pros. and cons. in such a developing arrangement:\nPros: Your RDW has much more resources like memory, disk capacity and CPU power than a Raspberry Pi, and this is true for a P4 model too. You can store all your programs in the desktop computer. You do not have to install on the Raspberry Pi the Visual Studio Code (or your preferred IDE program), the Java JDK (JRE it is enough), Maven and the other development tools. You do not need to connect the screen, the keyboard and the mouse to the Raspberry Pi You can use smaller PI models Cons: You can\u0026rsquo;t run Web applications (using a web container like Tomcat or similar) Setting Up Configure the RPi for Headless mode The Headless Mode configuration enables the RPi board to communicate with the RDW over SSH protocol.\nThese are the needed steps:\nCheck if the RDW is equipped with a SSH Client. If the RDW OS is Linux you already have it For Windows you can use putty, MobaXterm or you can enable the (new) OpenSsh Client porting on Windows 10 Connect both the RPi and RDW to your local network Follow this guide to configure your RPi Install the Maven tool on the RDW You should now be able to open a SSH Terminal window on RDW and to remotely login on the RPi board.\nInstall the pi4j-maven-archetype Goto the Github Pi4J Maven Archetype repository and download the project clicking on the green Code button and selecting Download ZIP\nUnzip the archetype file in a FOLDER cd FOLDER/pi4j-maven-archetype-main mvn install Congratulation ! - Now you are ready to generate your first Project Template\nGenerate a new Project Template Let suppose you want to begin the new wonderful PI4J project my-project, to do this follow these steps:\nmkdir my-project cd my-project mvn archetype:generate -DarchetypeCatalog=local answer to the questions the archetype asks you (see below for details) Configuring Your New Project Before starting the new project generation, the archetype asks some configuration data. The list of question and the replies are shown here below:\nChoose archetype: select the pi4j-maven-archetype from the list proposed Define value for property \u0026lsquo;groupId\u0026rsquo;: choose the Maven groupId for your project. (If don\u0026rsquo;t know what is a groupId, don\u0026rsquo;t worry, just type \u0026ldquo;com.example\u0026rdquo; for now) Define value for property \u0026lsquo;artifactId\u0026rsquo;: choose a name for the program executable your project will produce Define value for property \u0026lsquo;version\u0026rsquo;: 1.0-SNAPSHOT: type Enter to accept the default value shown, or type the initial program version, something like 1.0.0 Define value for property \u0026lsquo;package\u0026rsquo;: com.example: type Enter to accept the default value shown The archetype now shows you a summary of the configuration parameters you have just typed in, plus the values proposed for the main-class and package parameters. If the list is ok for you, reply Y to accept, otherwise reply N to change one or more values (you will have to re-type all parameter values \u0026hellip;)\nAfter the list confirmation, the archetype generates a new maven project template for you.\nCongratulations\nYou should be able to open the new project with your preferred java IDE. The IDE should be able to recognize the project as a valid Maven project.\nNote on the Java Runtime If you are not using the default Raspberry Pi OS full edition and/or included Java, you may get this kind of error:\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:3.0.0:run (exec) on project ...: An Ant BuildException has occured: The following error occurred while executing this line: [ERROR] ...\\antrun\\build.xml:166: The following error occurred while executing this line: [ERROR] ...\\antrun\\build.xml:123: Remote command failed with exit status 1 [ERROR] around Ant part ...... @ 9:59 in ...\\antrun\\build-main.xml This can be caused by a mis-configured Java runtime. The default value in raspberry.properties is:\ntarget.remote.jre=/usr/lib/jvm/default-java Check if this value exists and links to your Java runtime, or find the location of your installed JDK with sudo find / -iname java and use the result in your configuration.\nFor instance: a Raspberry Pi Zero (type 1) with ARMv6 requires a specific Java version for this type of processor. This is described more in detail on \u0026ldquo;Java for ARMv6/7/8\u0026rdquo;. If you use Azul Zulu JDK, you will need to change the configuration to:\ntarget.remote.jre=/usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf Explore the New Project Template Feel free to explore the new project familiarizing with the folder structure. These are the most important features:\nThe file README.md contains the intruction to configure the connection(s) to your RPi board(s) and the decription of the Maven commands to build your project, transfer the executable code to the target RPi, run it and also open a debugger session. The pom.xml file already includes the dependencies needed to compile your program with the Pi4J libraries. The platform folder contains an example configuration file for connecting to you RPi board. Read the README.md explanation, open the platform/raspberry.properties file (or copy it to a new file) and edit it to describe how to connect to your RPi Thanks to Adi and Luca Buraggi for this contribution.\n"},{"uri":"https://pi4j.com/about/download/","title":"Pi4J Downloads","tags":[],"description":"","content":"All downloads provided by the project can be found on pi4j.com/download.\nThe compiled artifacts (releases and snapshots) are available in the Sonatype Maven repository.\n"},{"uri":"https://pi4j.com/kotlin/kotlin-dsl/","title":"Pi4J Kotlin DSL","tags":[],"description":"Pi4J Kotlin DSL &amp; API Example &amp; Documentation","content":"Pi4J-Kotlin (aka Pi4K) is an implementation on top of Pi4J to facilitate the development of Kotlin applications for the Raspberry Pi that can interact with the GPIOs.\nKotlin makes extensive use of Domain Specific Language (DSL) to provide APIs that are cleaner, easier to read, and more structured. The DSLs provided here on top of Pi4J make it very easy to use this library in a Kotlin application. These Kotlin DSLs don\u0026rsquo;t introduce added runtime overhead of a new layer when used. DSL builders are always inlined on Compile-Time.\nInstallation Install the Pi4J dependency and pi4j-ktx in your app\u0026rsquo;s build.gradle.ktx file:\ndependencies { implementation(\u0026#34;com.pi4j:pi4j-ktx:2.4.0\u0026#34;) // Kotlin DSL implementation(\u0026#34;com.pi4j:pi4j-core:2.3.0\u0026#34;) implementation(\u0026#34;com.pi4j:pi4j-plugin-raspberrypi:2.3.0\u0026#34;) implementation(\u0026#34;com.pi4j:pi4j-plugin-pigpio:2.3.0\u0026#34;) } If you want to use the Console DSL to log with SLF4J, add the dependency:\nimplementation(\u0026#34;org.slf4j:slf4j-api:1.7.32\u0026#34;) implementation(\u0026#34;org.slf4j:slf4j-simple:1.7.32\u0026#34;) GitHub projects: Kotlin Interface \u0026amp; DSL for Pi4J V2: Pi4J-Kotlin For Pi4J V1 Kotlin Bindings, check Pi4K "},{"uri":"https://pi4j.com/kotlin/","title":"Pi4J with Kotlin","tags":[],"description":"","content":"Java and Kotlin: Similarities and Differences As a software developer, you may be familiar with Java and Kotlin, two popular programming languages used for developing applications on many different platforms. While both languages share some similarities, they also have distinct differences that can impact your coding experience.\nOne of the main similarities between Java and Kotlin is their ability to run on the Raspberry Pi. Both languages are supported by the Pi4J library, which provides a set of APIs for interacting with the GPIOs. This means you can use either language to develop applications that control and interact with the Raspberry Pi\u0026rsquo;s hardware components.\nKotlin DSL: Simplifying Development Kotlin stands out from Java due to its Domain Specific Language (DSL) capabilities. The Pi4J-Kotlin library provides a set of DSLs that simplify the development process by providing cleaner, easier-to-read APIs. These DSLs are inlined at compile-time, eliminating any runtime overhead.\nKotlin Examples Thanks to the examples created by Oleksandr Neiko, a full set of Pi4J + Kotlin examples are available.\nRead More Pi4J Kotlin DSL Minimal Kotlin Pi4J example Kotlin API \u0026amp; DSL Documentation Coroutines Support I²C Kotlin DSL Serial Kotlin DSL Kotlin Examples Basic Project Setup Useful Tips "},{"uri":"https://pi4j.com/kotlin/kotlin-examples/","title":"Kotlin Examples","tags":[],"description":"","content":"Examples created by Oleksandr Neiko, all the videos are available in this YouTube playlist and the sources on GitHub.\n"},{"uri":"https://pi4j.com/kotlin/kotlin-dsl/minimal-kotlin-example/","title":"Minimal Kotlin Pi4J example","tags":[],"description":"Pi4J Kotlin DSL &amp; API Example","content":" Full Example on GitHub: https://github.com/Pi4J/pi4j-kotlin/blob/master/example/src/main/kotlin/MinimalExample.kt\nFor full documentation, visit the Kotlin Docs\nThis is a minimal working example, make sure to check it out from the link above for the full introduction and comments.\nIt does exactly the same functionality of the Minimal Example using the Java API:\nThe application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.\nWiring This minimal example application uses this wiring:\nCode const val PIN_BUTTON = 24 // PIN 18 = BCM 24 const val PIN_LED = 22 // PIN 15 = BCM 22 var pressCount = 0 console { title(\u0026#34;\u0026lt;-- The Pi4J Project --\u0026gt;\u0026#34;, \u0026#34;Minimal Example project\u0026#34;) pi4j { digitalInput(PIN_BUTTON) { id(\u0026#34;button\u0026#34;) name(\u0026#34;Press button\u0026#34;) pull(PullResistance.PULL_DOWN) debounce(3000L) piGpioProvider() }.onLow { pressCount++ +\u0026#34;Button was pressed for the ${pressCount}th time\u0026#34; } } digitalOutput(PIN_LED) { id(\u0026#34;led\u0026#34;) name(\u0026#34;LED Flasher\u0026#34;) shutdown(DigitalState.LOW) initial(DigitalState.LOW) piGpioProvider() }.run { while (pressCount \u0026lt; 5) { +\u0026#34;LED ${state()}\u0026#34; toggle() Thread.sleep((500L / (pressCount + 1))) } } } } } Building \u0026amp; Running the application You can simply run the example app using gradle on the target device (Raspberry Pi for example):\n./gradlew :example:run "},{"uri":"https://pi4j.com/blog/","title":"Blogs","tags":[],"description":"","content":"Some tutorials, experiments, interviews, etc. don\u0026rsquo;t fit in the documentation part of this site. These are shared in this section as blog posts.\nJava 21\u0026#43; Not Working on Zero 2 Starting with a Desktop Icon Pi4J welcomes Java 21 Pi4J presentation for Miami JUG Pi4J in Floss Weekly Maven Downloads Signed versus unsigned values Bosch sensor gas measurement Interview Tom Aarts PWM Hardware Support on RPi5 Interview Robert von Burg Ongoing I2C Improvements LED Matrix with SPI MAX7219 Alexander Liggesmeyer and RPi5 LED strip with Pi4J and JBang Kotlin on the Raspberry Pi Getting Started Template "},{"uri":"https://pi4j.com/kotlin/kotlin-dsl/kotlin-api-docs/","title":"Kotlin API &amp; DSL Documentation","tags":[],"description":"Pi4J Kotlin DSL &amp; API Documentation","content":" Here you can find the provided APIs and the dead-simple DSLs of the Kotlin package.\nComponents Context To create a new Pi4J context, use the pi4j function. It creates a new auto Context object and uses it as a receiver for your lambda:\npi4j { // You have access to a newly created auto context describe() } You don\u0026rsquo;t need to call shutdown(), it\u0026rsquo;s called automatically at the end of the block.\nYou can think of the pi4j block as your entire routine/ program.\nCustom Context You can build a custom context using the buildContext function:\nval ctx = buildContext { +MockPlatform() // add a platform to our context +MockPwmProvider.newInstance() // add a provider to our context +File(\u0026#34;tmp.txt\u0026#34;) // add a file property +(\u0026#34;key\u0026#34; to \u0026#34;value\u0026#34;) // add a String property } You can add other properties the same way like InputStream, Reader, and Properties instances.\nGenerics You can also have access to Context properties using generics and type safe methods:\ncontext.run { hasPlatform\u0026lt;T\u0026gt;() // equivalent to Context::hasPlatform(Type::class.java) hasProvider\u0026lt;T\u0026gt;() // equivalent to Context::hasProvider(Type::class.java) provider\u0026lt;T\u0026gt;() // equivalent to Context::provider(Type::class.java) } I/O You can easily create and configure I/O pins using this DSL\nDigital I/O From any Context object you can create I/O instances using:\ndigitalInput(address = 24) { name(\u0026#34;Button\u0026#34;) pull(PullResistance.PULL_DOWN) debounce(3000L) } digitalOutput(22) { name(\u0026#34;LED Flasher\u0026#34;) initial(DigitalState.LOW) } Using this DSL you get access to convenient functions like:\ndigitalInput(24).run { listen { // listens on state changes val currentState = it.state() } onLow { // fires when state changes to DigitalState.LOW } onHigh { // fires when state changes to DigitalState.High } if (isLow) { // you get isLow property } if (isHigh) { // you get isHigh property } } Also, when you need to specify a provider for the pin you\u0026rsquo;re creating you can use these 2 safe providers:\ndigitalOutput(22) { mockProvider() // uses the mock provider piGpioProvider() // uses the pi_gpio provider } Analog I/O There are common APIs between Analog I/O and Digital I/O like:\nanalogInput(address = 24) { name(\u0026#34;Button\u0026#34;) mockProvider() // uses the mock provider piGpioProvider() // uses the pi_gpio provider }.run { listen { // listens on value changes val currentValue = it.value() } } However, Analog I/O get their own unique treats:\nanalogOutput(24).run { whenInRange(0..5) { // fires when value is in the supplied range } whenOutOfRange(0..5) { // fires when value is not in the supplied range } onMin(0..5) { // fires when value changes to the minimum of the range } onMax(0..5) { // fires when value changes to the maximum of the range } } PWM PWM has its share of love as well:\npwm(address = 24) { frequency(10_000) dutyCycle(40) mockProvider() // uses the mock provider piGpioProvider() // uses the pi_gpio provider } Console Using the console function, you can create a Console object and use it to print output to the console:\nconsole { +\u0026#34;This will be printed as a new line\u0026#34; box(\u0026#34;This will be printed inside a box\u0026#34;) +\u0026#34;Another line because I really like it\u0026#34; } You also get other helper functions found in the Minimal Example like printLoadedPlatforms, printDefaultPlatform , printProviders, and printRegistry.\nPlatform There are some convenient functions added to the Platform API\nGenerics context.platform\u0026lt;MockPlatform\u0026gt;().run { hasProvider\u0026lt;T\u0026gt;() // equivalent to Platform::hasProvider(Type::class.java) provider\u0026lt;T\u0026gt;() // equivalent to Platform::provider(Type::class.java) createFrom\u0026lt;IO\u0026gt;(IOConfig\u0026lt;*\u0026gt;) // equivalent to Platform::create(IOConfig\u0026lt;*\u0026gt; ,IO::class.java) createFrom\u0026lt;IO\u0026gt;(String) // equivalent to Platform::create(String ,IO::class.java) } "},{"uri":"https://pi4j.com/kotlin/kotlin-dsl/coroutines/","title":"Coroutines Support","tags":[],"description":"Coroutines for Pi4J -Kotlin","content":"pi4jAsync Same with the pi4j DSL, you can create a pi4j block to execute within a CoroutineScope using the pi4jAsync DSL.\npi4jAsync { delay(100) // suspended call describe() } Inside pi4jAsync you have access to a newly created auto context and you can run your code in the provided CoroutineScope.\nCustom CoroutineScope You can also use a custom CoroutineScope instance.\npi4jAsync(CoroutineScope(Dispatchers.Default)) { delay(100) // suspended call describe() } Minimal Example with Coroutines This is a the same as the minimal example, but leveraging Kotlin\u0026rsquo;s Coroutines\nprivate const val PIN_BUTTON = 24 // PIN 18 = BCM 24 private const val PIN_LED = 22 // PIN 15 = BCM 22 private var pressCount = 0 pi4jAsync { console { digitalInput(PIN_BUTTON) { id(\u0026#34;button\u0026#34;) name(\u0026#34;Press button\u0026#34;) pull(PullResistance.PULL_DOWN) debounce(3000L) piGpioProvider() }.onLow { pressCount++ +\u0026#34;Button was pressed for the ${pressCount}th time\u0026#34; } digitalOutput(PIN_LED) { id(\u0026#34;led\u0026#34;) name(\u0026#34;LED Flasher\u0026#34;) shutdown(DigitalState.LOW) initial(DigitalState.LOW) piGpioProvider() }.run { while (pressCount \u0026lt; 5) { +\u0026#34;LED ${state()}\u0026#34; toggle() delay(500L / (pressCount + 1)) } } } } "},{"uri":"https://pi4j.com/kotlin/kotlin-dsl/i2c/","title":"I²C Kotlin DSL","tags":[],"description":"I²C DSL Pi4J-Kotlin","content":" Feel free to checkout the Pi4J docs on I²C\nInstallation Add LinuxFs dependency\ndependencies { implementation(\u0026#34;com.pi4j:pi4j-plugin-linuxfs:2.3.0\u0026#34;) } I²C DSL i2c(1, 0x3f) { id(\u0026#34;TCA9534\u0026#34;) linuxFsI2CProvider() }.use { tca9534Dev -\u0026gt; // use here. Will auto close } Writing i2c(1, 0x3f) { id(\u0026#34;TCA9534\u0026#34;) linuxFsI2CProvider() }.use { tca9534Dev -\u0026gt; val newState = tca9534Dev.setPin(currentState, pin = 8, TCA9534_REG_ADDR_OUT_PORT) } Minimal I²C Example This is the Kotlin DSL version of the same I²C example here, but leveraging the Kotlin DSL\nprivate const val TCA9534_REG_ADDR_OUT_PORT: Int = 0x01 private const val TCA9534_REG_ADDR_CFG: Int = 0x03 fun main() { pi4j { i2c(1, 0x3f) { id(\u0026#34;TCA9534\u0026#34;) linuxFsI2CProvider() }.use { tca9534Dev -\u0026gt; val config = tca9534Dev.readRegister(TCA9534_REG_ADDR_CFG) check(config \u0026gt;= 0) { \u0026#34;Failed to read configuration from address 0x${\u0026#34;%02x\u0026#34;.format(TCA9534_REG_ADDR_CFG)}\u0026#34; } var currentState = tca9534Dev.readRegister(TCA9534_REG_ADDR_OUT_PORT) if (config != 0x00) { println( \u0026#34;TCA9534 is not configured as OUTPUT, setting register 0x${\u0026#34;%02x\u0026#34;.format(TCA9534_REG_ADDR_CFG)} to 0x00\u0026#34; ) currentState = 0x00 tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, currentState) tca9534Dev.writeRegister(TCA9534_REG_ADDR_CFG, 0x00) } tca9534Dev.run { // bit 8, is pin 1 on the board itself, so set pins in reverse: console { currentState = setPin(currentState, 8, TCA9534_REG_ADDR_OUT_PORT) +\u0026#34;Setting TCA9534 to new state ${currentState.binStr()}\u0026#34; sleep(500L) currentState = setPin(currentState, 8, TCA9534_REG_ADDR_OUT_PORT, false) +\u0026#34;Setting TCA9534 to new state ${currentState.binStr()}\u0026#34; sleep(500L) currentState = setPin(currentState, 7, TCA9534_REG_ADDR_OUT_PORT) +\u0026#34;Setting TCA9534 to new state ${currentState.binStr()}\u0026#34; sleep(500L) currentState = setPin(currentState, 7, TCA9534_REG_ADDR_OUT_PORT, false) +\u0026#34;Setting TCA9534 to new state ${currentState.binStr()}\u0026#34; sleep(500L) } } } } } "},{"uri":"https://pi4j.com/architecture/about-the-code/code-styling/","title":"Code styling","tags":[],"description":"","content":"To prevent unnecessary code (tabs versus spaces, number of characters per line\u0026hellip;) we have defined an editorconfig for IntelliJ IDEA. You can find more info here about its use.\nSome tips to keep the code clean and readable:\nShort methods with a clear name Use SonarLint to get improvement tips while code Use shortcuts CTRL+ALT+L: Reformat code CTRL+ALT+O: Optimize imports "},{"uri":"https://pi4j.com/examples/components/","title":"Component Examples","tags":["ADS1115","Button","LED","Buzzer","Camera","Joystick","LCD Display","LED Matrix","LED Strip","Potentiometer","Servo Motor"],"description":"","content":"The FHNW University contributed a full project with example implementations of the following devices.\nCurrent available components Device(s) Developed by Link Simple Button Reto Stutz, Mike Schoder Example Devices Simple LED Reto Stutz, Mike Schoder Example Devices AD Converter ADS1115 Reto Stutz, Mike Schoder Example Devices Buzzer Reto Stutz, Mike Schoder Example Devices Camera Reto Stutz, Mike Schoder Example Devices Joystick Reto Stutz, Mike Schoder Example Devices Joystick Analog Reto Stutz, Mike Schoder Example Devices LCD Display Reto Stutz, Mike Schoder Example Devices LED Button Reto Stutz, Mike Schoder Example Devices LED Matrix Reto Stutz, Mike Schoder Example Devices LED Strip Reto Stutz, Mike Schoder Example Devices Potentiometer Reto Stutz, Mike Schoder Example Devices Servo Motor Reto Stutz, Mike Schoder Example Devices Simple Implementation For a Simple Implementation, the recommendation is to use the Launcher Class. With this, a simple application can be started.\nElectrical Engineering General inputs and help on electrical engineering can be looked up on Getting started with PI4J / Electrical Engineering page.\n"},{"uri":"https://pi4j.com/featured-projects/","title":"Featured Projects","tags":[],"description":"","content":" Did you use Pi4J in one of your projects? We would love to hear from you! Please let us know by sending an e-mail to frank at pi4j.com with a brief description, URL, links and pictures of the product or project you are working on.\nSpring Boot Alarm System SmartCoop Binary Clock Soft real time PLC PiJukeBox CocktailPi Didier the street artist robot JMonkeyEngine with Joystick Sensor drivers "},{"uri":"https://pi4j.com/architecture/about-the-code/hardware-testing/","title":"Hardware testing","tags":[],"description":"","content":" This is an experimental project which will need a lot of love\u0026hellip; The new Raspberry Pi Pico with a lot of GPIOs for a very low price, seems even to be a better fit for this project compared to the Arduino Due\u0026hellip; To be further investigated!\nTo minimize the required time and efforts to test a new release, V2+ aims to include an automated test which performs I/O testing on each I/O interface on each model of RPi. Ideally this would happen as part of the unit testing sequence for each code commit or at least as part of the release cycle.\nTo achieve this, an Arduino Due board with lots of on board I/O capability is being used. The firmware that gets loaded onto the Arduino board listens on the serial port for instructions on which pins to use and what type of test to perform. The \u0026ldquo;Test Harness\u0026rdquo; project also includes a Java library that is used to communicate with the Arduino and instrument tests.\nNext, a given I/O provider plugin includes test classes that instrument the test harness and perform live I/O testing between the SBC (or other hardware) and the Arduino Test Harness.\nTo be able to fully test all board types, a custom PCB needs to be created to perform all the interconnects between the Raspberry Pi 26-pin/40-pin headers, and the Arduino board. This way enough test harnesses could be build for each Raspberry Pi model and have a permanent setup for on-demand testing. This of course is a huge effort just by itself, and perhaps too ambitious \u0026ndash; but seeking a means to reach automated testing is really needed for the long term.\n"},{"uri":"https://pi4j.com/documentation/java-for-arm/","title":"Java for ARMv6/7/8","tags":[],"description":"","content":"You can choose from a long list of Java versions and distributions if you use the 64-bit version of the Raspberry Pi Operating System. But this 64-bit OS is only available for Raspberry Pi board versions with an ARMv7 or ARMv8 processor.\nBoard versions With ARMv6 processor Raspberry Pi 1 A and A+ Raspberry Pi 1 B and B+ Zero 1.2, 1.3 and W Compute Module 1 With ARMv7 or ARMv8 processor Model A+, version 3 Model B, version 2, 3, 4 and 5 Zero 2 and 2W Compute Module, version 3, 4, and 5 How to Check and Install Java Check the Current Version You can check the installed Java version in the terminal. On a board with ARMv7 or ARMv8, with a correctly installed JDK, you will get this result:\n$ java -version openjdk version \u0026#34;11.0.3\u0026#34; 2019-04-16 OpenJDK Runtime Environment (build 11.0.3+7-post-Raspbian-5) OpenJDK Server VM (build 11.0.3+7-post-Raspbian-5, mixed mode) On an ARMv6 version, you will get an error:\n$ java -version Error occurred during initialization of VM Server VM is only supported on ARMv7+ VFP Check your board version If you are not sure which type of board you have, you can check this in the terminal with cat /proc/cpuinfo, for instance for a Raspberry Pi B+ 1.2:\n$ cat /proc/cpuinfo processor\t: 0 model name\t: ARMv6-compatible processor rev 7 (v6l) BogoMIPS\t: 697.95 Features\t: half thumb fastmult vfp edsp java tls CPU implementer\t: 0x41 CPU architecture: 7 CPU variant\t: 0x0 CPU part\t: 0xb76 CPU revision\t: 7 Hardware\t: BCM2835 Revision\t: 0010 Serial\t: 000000005f9ba615 Model\t: Raspberry Pi Model B Plus Rev 1.2 Running Java 21+ on Raspberry Pi Zero 2 Because of changes in OpenJDK 21 (and newer), Java applications have problems on the Raspberry Pi Zero 2, 64-bit OS. These are a few example error messages, but depending on your code, the message could be different:\n$ java HelloWorld.java An exception has occurred in the compiler ((version info not available)). Please file a bug against the Java compiler via the Java bug reporting page (https://bugreport.java.com) after checking the Bug Database (https://bugs.java.com) for duplicates. Include your program, the following diagnostic, and the parameters passed to the Java compiler in your report. Thank you. java.lang.NoClassDefFoundError: com/sun/tools/javac/processing/JavacProcessingEnvironment$DiscoveredProcessors at jdk.compiler/com.sun.tools.javac.processing.JavacProcessingEnvironment.initProcessorIterator(JavacProcessingEnvironment.java:331) ... $ javac HelloWorld.java Exception in thread \u0026#34;main\u0026#34; java.lang.InternalError: Cannot find requested resource bundle for locale en_US at jdk.compiler/com.sun.tools.javac.util.JavacMessages.getBundles(JavacMessages.java:145) ... Until the root problem is fixed in OpenJDK, you can fix this problem by adding a few command-line options to disable the intrinsic that speeds up hash calculation. It contains a bug which only affects the ARM Cortex-A53 only. The code interpreter and JIT compiler are unaffected.\njava -XX:+UnlockDiagnosticVMOptions -XX:-UseVectorizedHashCodeIntrinsic HelloWorld.java Hello World This will be fixed in the release of July 2025, based on the info in this bug report: [AArch64] Incorrect result of VectorizedHashCode intrinsic on Cortex-A53\nTo read more about this problem, check the blog post Java 21+ Not Working on Zero 2.\nInstall Java 11 on ARMv6 The sources for Java are available as open-source on OpenJDK, which means, if you can\u0026rsquo;t find the correct version for a specific board, it is possible to compile it yourself. Luckily there are different suppliers providing ready-made packages of the JDK for multiple platforms. But only Azul seems to have one which is a perfect fit for Raspberry Pi\u0026rsquo;s with an ARMv6: the Zulu community edition of JDK 11.\nTo get started with Zulu JDK, download and uncompress it to your board:\n$ cd /usr/lib/jvm $ sudo wget https://cdn.azul.com/zulu-embedded/bin/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ sudo tar -xzvf zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ sudo rm zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ ls -l total 12 lrwxrwxrwx 1 root root 21 Jul 23 15:58 java-1.11.0-openjdk-armhf -\u0026gt; java-11-openjdk-armhf drwxr-xr-x 9 root root 4096 Aug 20 11:41 java-11-openjdk-armhf drwxr-xr-x 2 root root 4096 Aug 20 11:41 openjdk-11 drwxrwxr-x 10 111 122 4096 Jul 10 16:50 zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf Now we have the JDK11 ready to be used, but it still needs to be configured, so the OS is aware of it.\n$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java 1 $ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac 1 At this moment we can select the new JDK to link it to the “java” and “javac” command.\n$ sudo update-alternatives --config java There are 2 choices for the alternative java (providing /usr/bin/java). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/java-11-openjdk-armhf/bin/java 1111 auto mode 1 /usr/lib/jvm/java-11-openjdk-armhf/bin/java 1111 manual mode 2 /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java 1 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 2 update-alternatives: using /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java to provide /usr/bin/java (java) in manual mode $ sudo update-alternatives --config javac There are 2 choices for the alternative javac (providing /usr/bin/javac). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/java-11-openjdk-armhf/bin/javac 1111 auto mode 1 /usr/lib/jvm/java-11-openjdk-armhf/bin/javac 1111 manual mode 2 /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac 1 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 2 update-alternatives: using /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac to provide /usr/bin/javac (javac) in manual mode Now let\u0026rsquo;s check the Java version:\n$ java -version openjdk version \u0026#34;11.0.8\u0026#34; 2020-07-14 LTS OpenJDK Runtime Environment Zulu11.41+75-CA (build 11.0.8+10-LTS) OpenJDK Client VM Zulu11.41+75-CA (build 11.0.8+10-LTS, mixed mode) OK, ready to run Java 11 applications on the Raspberry Pi with ARMv6!\nMore info If you want more info, or use JavaFX, check these blog posts:\nInstalling Java and JavaFX on the Raspberry Pi (for ARMv7+) How to install and use Java 11 and JavaFX 11 on Raspberry Pi boards with ARMv6 processor "},{"uri":"https://pi4j.com/about/license/","title":"License (Open Source)","tags":[],"description":"","content":"The Pi4J Version 2.0 project is distributed and licensed under the Apache License, Version 2.0 license (A business-friendly OSS license).\napache.org/licenses/LICENSE-2.0 github.com/Pi4J/pi4j/blob/master/LICENSE.txt Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\nDefinitions.\n\u0026ldquo;License\u0026rdquo; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n\u0026ldquo;Licensor\u0026rdquo; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n\u0026ldquo;Legal Entity\u0026rdquo; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026ldquo;control\u0026rdquo; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\u0026ldquo;You\u0026rdquo; (or \u0026ldquo;Your\u0026rdquo;) shall mean an individual or Legal Entity exercising permissions granted by this License.\n\u0026ldquo;Source\u0026rdquo; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.\n\u0026ldquo;Object\u0026rdquo; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.\n\u0026ldquo;Work\u0026rdquo; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).\n\u0026ldquo;Derivative Works\u0026rdquo; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.\n\u0026ldquo;Contribution\u0026rdquo; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026ldquo;submitted\u0026rdquo; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026ldquo;Not a Contribution.\u0026rdquo;\n\u0026ldquo;Contributor\u0026rdquo; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.\nGrant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.\nGrant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.\nRedistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and\n(b) You must cause any modified files to carry prominent notices stating that You changed the files; and\n(c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and\n(d) If the Work includes a \u0026ldquo;NOTICE\u0026rdquo; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\nYou may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\nSubmission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.\nTrademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.\nDisclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.\nLimitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.\nAccepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.\nEND OF TERMS AND CONDITIONS\nAPPENDIX: How to apply the Apache License to your work.\nTo apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026quot;[]\u0026quot; replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026quot;printed page\u0026quot; as the copyright notice for easier identification within third-party archives. Copyright (C) 2012 - 2019 Pi4J\nLicensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); you may not use this file except in compliance with the License. You may obtain a copy of the License at\nhttp://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n"},{"uri":"https://pi4j.com/getting-started/minimal-example-application/","title":"Minimal example application","tags":["Digital Input","Digital Output","Maven","Gradle"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\nIn the \u0026ldquo;pi4j-example-minimal\u0026rdquo; GitHub project you can find a project which contains the minimal code to control a digital input and output with Pi4J. The project is further described on this page. The application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.\nWiring This minimal example application uses this wiring:\nBuilding the Application The main build tool used by the Pi4J project is Maven, but for this example we provided both the Maven and Gradle approach, so you can select the tool you prefer.\nMaven This project can be built with Apache Maven 3.6 (or later) and Java 17 OpenJDK (or later). These prerequisites must be installed prior to building this project as described on the previous pages. The following command can be used to download all project dependencies and compile the Java module. You can build this project directly on a Raspberry Pi with Java 17+.\nOn Linux:\n./mvnw clean package On Windows:\nmvnw.bat clean package Gradle You can also use the Gradle Build Tool from these same sources. Use version 6.6 (or later) and Java 17 OpenJDK (or later). The Gradle wrapper is used as described on docs.gradle.org. The Gradle configuration file build.gradle-file is included in the sources.\nOn Linux:\n./gradlew build On Windows:\ngradlew.bat build Dependency in pom.xml For the Maven approach, a pom.xml file defines all the dependencies, and the build process.\nIn this project we will be using slf4 for logging, pi4j-core and the pi4j-plugins for the Raspberry Pi and PiGPIO. To make the versions easy to update, we add those numbers as properties.\n\u0026lt;properties\u0026gt; \u0026lt;!-- DEPENDENCIES VERSIONS --\u0026gt; \u0026lt;slf4j.version\u0026gt;2.0.16\u0026lt;/slf4j.version\u0026gt; \u0026lt;pi4j.version\u0026gt;2.7.0\u0026lt;/pi4j.version\u0026gt; \u0026lt;/properties\u0026gt; These are the dependencies we need:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- include Pi4J Core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- include Pi4J Plugins (Platforms and I/O Providers) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-gpiod\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Pi4J Code Blocks Initialization Before you can use Pi4J you must initialize a new runtime context.\nThe Pi4J static class includes a few helper context creators for the most common use cases. The newAutoContext() method will automatically load all available Pi4J extensions found in the application\u0026rsquo;s classpath which may include Platforms and I/O Providers.\nvar pi4j = Pi4J.newAutoContext(); Output Pi4J Context Information The library contains helper functions to output info about the available and used platforms and providers. To keep the example code clean, these are part of the PrintInfo.java class. For example to print the loaded platforms:\nPlatforms platforms = pi4j.platforms(); console.box(\u0026#34;Pi4J PLATFORMS\u0026#34;); console.println(); platforms.describe().print(System.out); console.println(); Blink a LED To initialize a LED, we use the minimal required code, only defining the pin number. The created led-object can be used to toggle its state.\nprivate static final int PIN_LED = 22; // PIN 15 = BCM 22 var led = pi4j.digitalOutput().create(PIN_LED); while (pressCount \u0026lt; 5) { if (led.state() == DigitalState.HIGH) { led.low(); } else { led.high(); } Thread.sleep(500 / (pressCount + 1)); } Handle the Button Presses To handle digital input events, some more configuration is needed, and we use a config builder. With that configuration, Pi4J can create the object for us and the state changes can be handled.\nAdditional info on the newConfigBuilder can be found on \u0026ldquo;Building an I/O Instance\u0026rdquo;.\nprivate static int pressCount = 0; private static final int PIN_BUTTON = 24; // PIN 18 = BCM 24 var buttonConfig = DigitalInput.newConfigBuilder(pi4j) .id(\u0026#34;button\u0026#34;) .name(\u0026#34;Press button\u0026#34;) .address(PIN_BUTTON) .pull(PullResistance.PULL_DOWN) .debounce(3000L); var button = pi4j.create(buttonConfig); button.addListener(e -\u0026gt; { if (e.state() == DigitalState.LOW) { pressCount++; console.println(\u0026#34;Button was pressed for the \u0026#34; + pressCount + \u0026#34;th time\u0026#34;); } }); Closing the Application Before the application quits, we need to call the shutdown() function on the Pi4J static helper class. This will ensure that all I/O instances are properly shutdown, released by the system and shutdown in the appropriate manner. Termination will also ensure that any background threads/processes are cleanly shutdown and any used memory is returned to the system.\npi4j.shutdown(); Steps to Run on Your Raspberry Pi Attach a LED and button as shown in the image above Use a recent Raspbian OS image which has Java 17 or newer. To check if you have the correct Java version in the terminal: $ java -version openjdk version \u0026#34;17.0.7\u0026#34; 2023-04-18 OpenJDK Runtime Environment (build 17.0.7+7-Debian-1deb11u1) OpenJDK 64-Bit Server VM (build 17.0.7+7-Debian-1deb11u1, mixed mode, sharing) Download the project from GitHub and build it: $ git clone https://github.com/Pi4J/pi4j-example-minimal.git $ cd pi4j-example-minimal/ $ ./mvnw clean package Change to the distribution directory where you can find the generated package and required Java-modules. $ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 344544 Oct 21 08:07 pi4j-core-2.7.0.jar -rw-r--r-- 1 pi pi 7134 Oct 21 08:08 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 158997 Oct 21 08:07 pi4j-library-gpiod-2.7.0.jar -rw-r--r-- 1 pi pi 22633 Oct 21 08:07 pi4j-plugin-gpiod-2.7.0.jar -rw-r--r-- 1 pi pi 28051 Oct 21 08:07 pi4j-plugin-raspberrypi-2.7.0.jar -rwxr-xr-x 1 pi pi 101 Oct 21 08:08 run.sh -rw-r--r-- 1 pi pi 69435 Oct 21 08:07 slf4j-api-2.0.16.jar -rw-r--r-- 1 pi pi 15704 Oct 21 08:07 slf4j-simple-2.0.16.jar Start the application with the provided run.sh script: $ ./run.sh The output will first show you some info about the platforms and providers. Then the LED starts blinking and shows how many times you pushed the button: LED high LED low LED high Button was pressed for the 1th time LED low LED high Button was pressed for the 2th time LED low LED high LED low LED high Button was pressed for the 3th time LED low LED high LED low LED high Button was pressed for the 4th time LED low LED high LED low LED high Button was pressed for the 5th time "},{"uri":"https://pi4j.com/getting-started/minimal-example-application-fatjar/","title":"Minimal example as FAT JAR","tags":["Digital Input","Digital Output","FatJAR"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fatjar\nThe \u0026ldquo;Minimal example application\u0026rdquo; uses one LED and button to demonstrate the basic use of Pi4J. When building that project with Maven, all the required Java modules are copied to the target/distribution directory. But a lot of developers like to produce a single, executable JAR that contains all dependencies, also known as a \u0026ldquo;FAT JAR\u0026rdquo;.\nThe repository \u0026ldquo;pi4j-example-fatjar\u0026rdquo; GitHub project contains a Maven project with identical wiring, dependencies and build command to the \u0026ldquo;Minimal example application\u0026rdquo;, but results in such a FAT JAR instead of separate Java modules.\nMaven Plugins By using three build plugins the FAT JAR is created:\nmaven-compiler-plugin maven-jar-plugin maven-shade-plugin For the full description, take a look at the README.md in the sources and the page \u0026ldquo;Build as a FAT JAR with Maven\u0026rdquo;.\nBuilding and Running Build with:\nmvn clean package Once the build is complete and was successful, you can find the compiled FAT JAR pi4j-example-fatjar.jar in the target directory. You can build directly on your Raspberry Pi or if you are developing on a different computer, copy the file to your Raspberry Pi with (in this example the Pi has IP 192.168.0.252):\nscp target/pi4j-example-fatjar.jar pi@192.168.0.252://home/pi On the Raspberry Pi open a terminal, or via SSH from your PC, execute this command:\n$ java -jar pi4j-example-fatjar.jar [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - \u0026lt;-- The Pi4J Project --\u0026gt; [main] INFO com.pi4j.util.Console - Minimal Example project [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.runtime.impl.DefaultRuntime - Initializing Pi4J context/runtime... [main] WARN com.pi4j.runtime.impl.DefaultRuntime - Replacing provider DIGITAL_OUTPUT RaspberryPi Digital Output (GPIO) Provider with priority 0 with provider GpioD Digital Output (GPIO) Provider with higher priority 150 [main] WARN com.pi4j.runtime.impl.DefaultRuntime - Replacing provider DIGITAL_INPUT RaspberryPi Digital Input (GPIO) Provider with priority 0 with provider GpioD Digital Input (GPIO) Provider with higher priority 150 [main] INFO com.pi4j.library.gpiod.internal.GpioDContext - Using chip gpiochip0 pinctrl-bcm2711 [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.runtime.impl.DefaultRuntime - Pi4J context/runtime successfully initialized. [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PLATFORMS | [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - PLATFORMS: [1] \u0026#34;Pi4J Runtime Platforms\u0026#34; \u0026lt;com.pi4j.platform.impl.DefaultPlatforms\u0026gt; PLATFORM: \u0026#34;RaspberryPi Platform\u0026#34; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - | Pi4J DEFAULT PLATFORM | [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - PLATFORM: \u0026#34;RaspberryPi Platform\u0026#34; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PROVIDERS | [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - PROVIDERS: [6] \u0026#34;I/O Providers\u0026#34; \u0026lt;com.pi4j.provider.impl.DefaultProviders\u0026gt; DIGITAL_INPUT: [1] \u0026lt;com.pi4j.io.gpio.digital.DigitalInputProvider\u0026gt; PROVIDER: \u0026#34;GpioD Digital Input (GPIO) Provider\u0026#34; {gpiod-digital-input} \u0026lt;com.pi4j.plugin.gpiod.provider.gpio.digital.GpioDDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.gpiod.provider.gpio.digital.GpioDDigitalInputProviderImpl} SERIAL: [1] \u0026lt;com.pi4j.io.serial.SerialProvider\u0026gt; PROVIDER: \u0026#34;RaspberryPi Serial Provider\u0026#34; {raspberrypi-serial} \u0026lt;com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl} I2C: [1] \u0026lt;com.pi4j.io.i2c.I2CProvider\u0026gt; PROVIDER: \u0026#34;RaspberryPi I2C Provider\u0026#34; {raspberrypi-i2c} \u0026lt;com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl} DIGITAL_OUTPUT: [1] \u0026lt;com.pi4j.io.gpio.digital.DigitalOutputProvider\u0026gt; PROVIDER: \u0026#34;GpioD Digital Output (GPIO) Provider\u0026#34; {gpiod-digital-output} \u0026lt;com.pi4j.plugin.gpiod.provider.gpio.digital.GpioDDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.gpiod.provider.gpio.digital.GpioDDigitalOutputProviderImpl} SPI: [1] \u0026lt;com.pi4j.io.spi.SpiProvider\u0026gt; PROVIDER: \u0026#34;RaspberryPi SPI Provider\u0026#34; {raspberrypi-spi} \u0026lt;com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl} ANALOG_OUTPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogOutputProvider\u0026gt; ANALOG_INPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogInputProvider\u0026gt; PWM: [1] \u0026lt;com.pi4j.io.pwm.PwmProvider\u0026gt; PROVIDER: \u0026#34;RaspberryPi PWM Provider\u0026#34; {raspberrypi-pwm} \u0026lt;com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ------------------- [main] INFO com.pi4j.util.Console - | Pi4J REGISTRY | [main] INFO com.pi4j.util.Console - ------------------- [main] INFO com.pi4j.util.Console - REGISTRY: [2] \u0026#34;I/O Registered Instances\u0026#34; \u0026lt;com.pi4j.registry.impl.DefaultRegistry\u0026gt; IO: \u0026#34;Press button\u0026#34; {button} \u0026lt;com.pi4j.plugin.gpiod.provider.gpio.digital.GpioDDigitalInput\u0026gt; {DIN-24} IO: \u0026#34;DOUT-22\u0026#34; {DOUT-22} \u0026lt;com.pi4j.plugin.gpiod.provider.gpio.digital.GpioDDigitalOutput\u0026gt; {DOUT-22} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [Pi4J.RUNTIME-1] INFO com.pi4j.util.Console - Button was pressed for the 1th time [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [Pi4J.RUNTIME-1] INFO com.pi4j.util.Console - Button was pressed for the 2th time [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [Pi4J.RUNTIME-1] INFO com.pi4j.util.Console - Button was pressed for the 3th time [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [Pi4J.RUNTIME-1] INFO com.pi4j.util.Console - Button was pressed for the 4th time [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [Pi4J.RUNTIME-1] INFO com.pi4j.util.Console - Button was pressed for the 5th time [main] INFO com.pi4j.runtime.impl.DefaultRuntime - Shutting down Pi4J context/runtime... [main] INFO com.pi4j.plugin.gpiod.provider.gpio.digital.GpioDDigitalInput - Shutdown input listener for button [main] INFO com.pi4j.util.ExecutorPool - Shutting down executor pool Pi4J.RUNTIME [main] INFO com.pi4j.runtime.impl.DefaultRuntime - Pi4J context/runtime successfully shutdown. Dispatching shutdown event. "},{"uri":"https://pi4j.com/kotlin/kotlin-dsl/serial/","title":"Serial Kotlin DSL","tags":[],"description":"SERIAL (UART/RS232) DSL Pi4J-Kotlin","content":" Feel free to checkout the Pi4J docs on Serial\nInstallation Add PiGPIO dependency\ndependencies { implementation(\u0026#34;com.pi4j:pi4j-plugin-pigpio:2.3.0\u0026#34;) } Serial DSL serial(\u0026#34;/dev/ttyS0\u0026#34;) { use_9600_N81() dataBits_8() parity(Parity.NONE) stopBits(StopBits._1) flowControl(FlowControl.NONE) piGpioSerialProvider() }.open { // use here. } Minimal Serial Example This is the Kotlin DSL version of the same Serial example here, but leveraging the Kotlin DSL\nserial(\u0026#34;/dev/ttyS0\u0026#34;) { // .. }.open { console { +\u0026#34;Waiting till serial port is open\u0026#34; while (!isOpen) { print(\u0026#34;.\u0026#34;) sleep(250) } println() +\u0026#34;Serial port is open\u0026#34; startDaemon { inputStream.bufferedReader().use { while (true) { if (available() != 0) sleep(10) else buildString { (0 until available()).forEach { _ -\u0026gt; readByte().let { b -\u0026gt; // All non-string bytes are handled as line breaks if (b \u0026lt; 32) return@forEach else append(b.toInt().toChar()) } } }.also { +\u0026#34;Data: \u0026#39;$it\u0026#39;\u0026#34; } } } } while (isOpen) sleep(500) } } And startDaemon is defined as:\nfun startDaemon(runnable: Runnable) = Thread(runnable).apply { isDaemon = true start() } "},{"uri":"https://pi4j.com/featured-projects/spring-boot-alarm/","title":"Spring Boot Alarm System","tags":["Spring","Spring Boot","Gradle","Digital Input","Digital Output","PIR","LED","Buzzer"],"description":"","content":" GITHUB PROJECT: github.com/bmike2047/springboot-rpi-alarm-system\nThis project by Mihai Buleandra, uses Spring Boot to create a simple wired alarm system. Most examples on this website use Maven, but this project is a nice example of how to configure a Gradle project to use Pi4J. Mihai also uses Thymeleaf and Bootstrap for the web user interface, that has live updates showing the state of the alarm system.\nThe alarm system makes use of Java\u0026rsquo;s multithreading capabilities, as it\u0026rsquo;s based on a non-blocking Finite State Machine. This means each state runs in its own thread allowing the web interface to not block while waiting for different operations. Multi-threaded reusable Java drivers for the Raspberry Pi are implemented using the Pi4J library for the keypad, Passive Infrared sensor (PIR), LED and Buzzer. Keypad driver includes debounce implementation also.\nThe code and more info is available in the GitHub project.\n"},{"uri":"https://pi4j.com/featured-projects/smartcoop/","title":"SmartCoop","tags":["I2C","SPI","Serial"],"description":"","content":" PROJECT WEBSITE: smartcoop.tech\nDave Duncanson, an ex Royal Australian Airforce (RAAF) electronics technician and embedded software developer, created the SmartCoop. It\u0026rsquo;s a fully automated Chicken Coop Controller solution which uses a Raspberry Pi and a ESP32-S3 Processor located on a custom designed Surface Mount Designed (SMD) PCB. The goal of this project was to significantly reduce the amount of regular and routine tasks required to keep a small flock (~30) of chickens on a hobby farm located in NSW just outside of Canberra Australia.\nThe 4th generation of this solution is based on over ten years in development with a lot of trail and error along the way. Just one example was the need to run all of the wiring harness within Conduit otherwise the local cockatoos will eat the wiring. There are no plans to commercialize this project, and all sources and hardware designs are available on BitBucket.\nDave admits that this solution is most likely over-engineered and therefore not cost-effective for the typical small suburban chicken coop or flock. But it\u0026rsquo;s the perfect solution for him to fully automate the chicken coop, including multiple doors, water management, feed monitoring, system logging (MQTT). He can control everything with an advanced web based user interface. And it protects his chickens from foxes!\nHe wants to extend the project further with UHF RFID Chicken Tag Readers. This way it will become possible to automatically close the main door when all the chickens have entered the Coop, and even record which chickens are laying the eggs in each laying box.\nThanks to the different providers (GPIO and I2C) in V2 of the Pi4J library, the development of the software became a lot easier as Dave could switch between providers when he was debugging some of the I2C implementations. Because he uses a Raspberry Pi (instead of embedded-only with, for instance, Arduino), he was able to do the majority of the development in Java running on the Pi. This made the implementation of advanced features like the H2 database, MQTT, and GPSD a lot simpler.\nKey Features The 4th Generation of the SmartCoop provides the following key features:\nFully Automated Main Door, utilising a light sensor to trigger the open and close with dawn and dusk setting for each day at your location via a GPS. Fully automated Yard Door, that utilises a weather forecast from the Australia BOM to decide if the yard door should be opened each day Comprehensive Web interface that provides a range of manual controls, configuration settings and charting of sensor data Manual push buttons on the PCB to open or close either of the doors, fill the water tank or power up the Raspberry Pi Monitors and automated fill of a water tank Preset configurable power down and on again function for the Raspberry Pi to reduce overnight battery power consumption Nightly check is send via email to ensure that everything is closed for the overnight power down Open Source Relational Database to store configuration and long term monitoring of all sensor information GPS interface that provides an accurate Time Source for updating the RTC and when our Internet is down, plus LAT \u0026amp; LONG coordinates used for Dusk \u0026amp; Dawn settings Realtime monitoring of remaining chicken food across two separate feeders Fetches the weather forecast for the location from the Australian BOM site to determine if yard door is to be opened for the day Realtime monitoring of the chicken coop system via a MQTT broker Sofware The application uses the following key software components and libraries:\nThe Java Runtime Environment (JRE 17x) The Pi4J Project - Java I/O Library for the Raspberry Pi (v2.7) Hibernate ORM Library (v6.x) H2 Database Engine Hardware The hardware design is composed of the following key components:\nRaspberry Pi Zero 2W A supporting PCB Any 12VDC Solar Regulator (5amp) Any 12Vdc Solar Panel (~100W) Deep cycle 12VDC Battery 1 x 12VDC Water Solenoid 2 x 12VDC electric motors (geared ~23rpm) 5 x Inductive Proximity Sensor Switch PNP DC6V-36V (LJ12A3-4-Z/BY) 1 x Single Float Value Switch (12VDC) 20kg Load Cell A suitable water proof enclosure (IP66) with clear Front Door to house the PCB and solar regulator "},{"uri":"https://pi4j.com/featured-projects/binary-clock/","title":"Binary Clock","tags":["LED","PCF8575","MCP23008","MCP23017"],"description":"","content":" GITHUB PROJECT: github.com/taartspi/pi4j-binary-clock\nThis project by Tom Aarts (published on May 15, 2024), is a binary clock created with LEDs on a breadboard. In the video below you see it incrementing to the next minute and hour. What you see is the Hour Minute and Second displayed in BCD (Binary Coded Decimal):\nDesign document describing the LED PCF8575 connections, and the Java implementation that drives the clock LEDs. Note: there are two PCF8575 IC used in this design. This IC is used as it can provide the current flow to directly control the LED. Alternative IC like the MCP23017 with less current capability would require a NPN transistor in the circuit.\nWiring The following documents the connections for a single LED\nLEDs This project uses 20 LEDs in three colors.\nSingle LED wiring\nLED Anode and Cathode\nLED colors\nHigher level example of the twenty LED connections. This shows half of the LEDs. the same connection pattern repeats.\nLED connections\nLED connections across entire BreadBoard\nAITIAO PCF8575 16 IO Expander Since there are 20 LEDs, two ICs are required. In my case these parts I purchased do not match their documentation. My chip has solder bridges for all three address bits, A0 A1 A2. Also, their description of a solder bridge across VCC-VDD appears to be backwards. I think as cautionary tale, I soldered the ICs down and lost access to their VCC-VDD bridge and couldn’t experiment.\nThis companies chip functions correctly with the Chip VCC and LED anode voltage equal.\nPrototype board Half Size BreadBoard. You can see in the chart ‘Overall LED Connections’ I cut paths on the planar so the LEDs could be placed close to each other. You can buy larger BreadBoards from ElectroCookie, called snappable. On these boards each row, ie: A B C \u0026hellip; has three solder lands and each letters trace are not connected to the next letter, so no trace cutting and there is more area for components and soldering.\nAlternate BreadBoard\nPCF8575 pin assignment\nRaspberry Pi Connections PCF8575 ICs and the Diode anodes connect to the Pi 3.3v PCF8575 ICs connect to the Pi Ground. PCF8575 ICs connect to the Pi SDA and SCL (I2C). Java Implementation The Java project uses Pi4J V2.6.0 and you can find the sources in this GitHub repository\nCompleted project PCF8575 BreadBoard\nLED BreadBoard\nPCF 8575 wired\nInterconnect\nOperational\nAlternate IC You could use a MCP23008 or MCP23017 as the IC. There are a few more steps to configure the IC, and its limited current capability requires a NPN transistor to switch the LED current.\nNPN Transistor for MCP230XX\n"},{"uri":"https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/","title":"Soft real time PLC","tags":[],"description":"","content":"Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available.\nConveyors for containers filled by a dispensing robot\neSyBox using pi4j to communicate with the Raspberry Pi\u0026#39;s I2C bus\neSyBox slot detection in action\nThese are projects by the company atexxi.ch.\nA soft real time PLC written in Java running on Strolch This PLC project by Robert von Burg combines Pi4j, Strolch and the Raspberry Pi.\nIt is being used in a material flow controller which coordinates FromStock orders with a medical dispensing robot and dispenses the packets into containers. These containers are then moved by a Strolch based PLC. The containers travel on a 12m long conveyor with multiple segments and entry/exits to position the container at the dispensing robot\u0026rsquo;s exit.\nMedical cabinet with pick-by-light The most recent project are medical cabinets which use I2C to communicate with custom electronics to control the locks, perform a pick-by-light from slots and uses infrared to detect access to a slot with products in it.\n"},{"uri":"https://pi4j.com/architecture/advanced/","title":"Advanced","tags":[],"description":"","content":"Pi4J V2+ tries to focus on its core functionality (the GPIO I/O) but at the same time wants to provide the possibility to extend and adapt to other hardware, underlying framework etc.\nYou can find more info on these pages about some of the current functionalities to achieve this:\nAnnotated provisioning Dependency injection Native Library Path Plug-ins Remote support "},{"uri":"https://pi4j.com/examples/crowpi/","title":"Electronics with CrowPi","tags":["CrowPi"],"description":"","content":"The CrowPi is an electronics starter kit in a laptop-housing. Of course, you can get any electronics starter kit for this purpose or buy separate components. That\u0026rsquo;s the fun of electronics: components are inexpensive and easy to find on ebay or one of the many web shops.\nCrowPi 1\nCrowPi 2\nExample electronics starter kit\nAs the CrowPi contains a lot of components, its use is described on the following subpages:\nDevelop with Intellij IDEA CrowPi examples The CrowPi sources and documentation are provided by the Swiss FHNW University based on a project in 2021 by Pascal Mathis and Tobias Siegrist under supervision of Barbara Scheuner and Dieter Holz. The original documentation (in German) is available on \u0026ldquo;CrowPi goes Java\u0026rdquo; (with sources on GitHub).\n"},{"uri":"https://pi4j.com/documentation/logging/","title":"Logging with SLF4J","tags":[],"description":"","content":"Pi4J uses SLF4J for logging. To include it in your project, add this Maven dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0-alpha0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; There are different ways to configure the logging output, as described on the SLF4J website, but the shortest is probably with this property in your main-method:\npublic static void main(String[] args) throws Exception { // Configure default logging level, accept a log level as the first program argument System.setProperty(\u0026#34;org.slf4j.simpleLogger.defaultLogLevel\u0026#34;, \u0026#34;INFO\u0026#34;); // Your code comes here } "},{"uri":"https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/","title":"PiJukeBox","tags":[],"description":"","content":"\nDaniel Mårtensson used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators.\nFeatures: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi\u0026rsquo;s, terminal based.\nWith a Raspberry Pi B+, OpenJDK 8 and Pi4J inside this radio, it became a juke box. The sources are available on github.com/DanielMartensson/PiJukeBox\n"},{"uri":"https://pi4j.com/about/team/","title":"The Team","tags":[],"description":"","content":" Robert Savage, Project Founder, Architect, Lead Developer.\nPrincipal Software Architect/Engineer. Consultant, technology enthusiast, entrepreneur, open source contributor, technology blogger. Founder at shadeBlue, LLC and SavageSoftware, LLC. Robert has a more than 20 year career working in the professional audio visual and home/commercial automation industry and an extensive background in developing technology solutions with a special focus on home automation and hardware/firmware/software integration. In 2012, Robert created the Pi4J project which provides Java developers an easy to use Java library enabling access to low-level I/O functionality (GPIO, I2C, SPI, Serial, etc.) of embedded systems like the Raspberry Pi. I created Pi4J to empower Java programmers to get involved with embedded platforms such as the Raspberry Pi and provide an easy to use and accessible Java-centric object-oriented library enabling control of real world (physical) \u0026ldquo;things\u0026rdquo;. Pi4J V2 brings an entirely new and modern approach to Java I/O programming for embedded systems. I\u0026rsquo;m excited to get V2 released and see what additional creative projects emerge. Read more about Robert Savage in this interview on Foojay.io. Frank Delporte, Project organization, Documenter, Developer.\nJava and Raspberry Pi-enthousiast, blogger on webtechie.be and author of the book \u0026ldquo;Getting Started with Java on Raspberry Pi\u0026rdquo;. Technical writer at Azul. Lead coach CoderDojo in Ieper, Belgium. Software developer with more than 25 years of experience in video, multimedia, technical project management, digital signage and (web) programming. I\u0026rsquo;m a strong believer in the power and fun of Java on the Raspberry Pi. My goal is to make it as easy as possible to get started for new and experienced Java developers who want to start there first hardware experiment. That was the reason I wrote a book about this subject and share my experiments on my blog and GitHub. Pi4J V2 brings a lot of improvements to an already great project, and - just one example - the use of the BCM pin numbers will make it even a lot easier to use the GPIO\u0026rsquo;s. That\u0026rsquo;s why I join this great team to assist in delivering this V2 and extend it further so we can bring even more Java to the Raspberry Pi. Read more about Frank Delporte in this interview on Foojay.io. Robert von Burg aka \u0026ldquo;Eitch\u0026rdquo;, Developer, Releaser.\nAs lead developer for strolch.li we use Raspberry Pi as our platform to connect with products, and to implement a PLC in Java. The Pi4J project allows us to encapsulate the low level aspects of communicating with the hardware, and stay in our preferred choice. The strolch.li/plc.html project allows us to also stay in the same DSL for writing server applications, as well as communicating with low level devices. Since I love open source projects, it felt natural to me to start investing time in the Pi4J projects to assist in the further development. Dr. Dieter Holz, Lecturer, Software Developer. Dr. Dieter Holz is lecturer and a software developer with more than 40 years of experience. He co-founded Canoo, a Software-Boutique based in Basel, Switzerland (now known as Karakun) and worked in several large scale Java projects. For over 10 years, he teaches at FHNW Java / JavaFX in the context of real-world business applications, and Kotlin and Jetpack Compose for native Android-Apps and desktop applications.\nTogether with his students, Dieter created the CrowPi example implementations, the Pi4J Operating System, and other examples and documentation here on the Pi4J website.\nRead more about Dieter Holz in this interview on Foojay.io. Thomas Aarts (aka Tom), Developer, Creating IC examples.\nMy previous work entailed a decade in Alaska involving HF through Microwave communication and airport Instrument Landing Systems (ILS) DME NDB VASI. The next decade was centered around telephony. Working for ‘ROLM’ I was a software engineer working on the CBX series of switches. Most years in assembler using the DG instruction set. Later years on the larger CBX that used a company designed compiler much like ‘C’ on a much different instruction set. The last two decades I worked within an IBM lab. At the start I worked the AS400, a mid to large size server. Initially development of software at the user interface, above the MI. After a few years I moved in the firmware stack at the time all the servers, mid-mainframe, changed to using the IBM RISC processor. After some years in the firmware stack I moved to a newly formed simulation team. This entailed developing a simulation of the entire central processor complex (CPC) or Central Electronic Complex (CEC) to enable the firmware stack to boot and the partitions to boot on top and run. So after a long time working just above the hardware or simulating the hardware I found the Pi4j project of interest. After its’ use for some sensors and displays I am spending more time learning its capability and if possible offer something to the project. After that by decade history rundown I should add I retired. Read more about Tom Aarts in this interview. Muhammad Hashim aka \u0026ldquo;mhashim6\u0026rdquo;, Developer, Focus on Kotlin.\nI\u0026rsquo;m a Software Engineer at Instabug, Writer \u0026amp; Blogger at The Upside-Down Trees \u0026amp; The Unhappy Folk. I go by \u0026ldquo;Timeless, Placeless\u0026rdquo; As it better reflects the crafts I do; my art and interests; and my life. I\u0026rsquo;ve joined the team to bring Kotlin to Pi4J; The project that brought the JVM to the Raspberry Pi. Alexander Liggesmeyer, Student Worker at Max Planck Institute for Informatics, personal website.\nAlexander created the GpioD Provider for release 2.5.0 to make Pi4J compatible with the Raspberry Pi 5. He also loves drinking cocktails with the CocktailPi as a result. Read more about Alexander Liggesmeyer in this interview on Pi4J.com. "},{"uri":"https://pi4j.com/featured-projects/cocktail-maker-by-alex9849/","title":"CocktailPi","tags":[],"description":"","content":"The CocktailPi is a cocktail mixing machine by Alexander Liggesmeyer. It can control as many pumps as the RaspberryPi provides GPIO pins. For every pump that gets added to the system, the user has to provide the amount of time that that pump needs to pump one centiliter in milliseconds. The machine uses peristaltic pumps. So that number is perfectly accurate. The flow rate won\u0026rsquo;t vary over time. It uses a relay board for closing the electronic circuit for all pumps. This allows to power the pumps with more than 5V. The relay board is connected to the Pi which controls the board with Pi4J V1. The backend-application is written in Java (Spring boot). The frontend is written with VueJS.\nLinks Project website Sources Pictures Video A video is available on Reddit\nApplication features Pumping ingredients in sequential order. Pumping ingredients concurrently and mixing them by spreading the active pump timings within the productionstep. Ingredients that cannot be added automatically (maybe because they didn\u0026rsquo;t get assigned to one pump or are simply not liquid) can be handled. If a recipe with a non-pumpable ingredient got ordered the application will prompt the user to add that ingredient at the corresponding point. Recipes can be resized for every order. The user decides the size of the cocktail he wants to order. All ingredients amount will get recalculated automatically. A drag \u0026amp; drop recipe editor. Recipes can be categorized. Collections: Users can create collections and add recipes to them. Bar: Users can add owned ingredients to their bar. The application can search for recipes that he can order with the owned recipes. If the user tries to order a recipe where he doesn\u0026rsquo;t own all ingredients he will get a warning. The cocktail maker can search for recipes that can be produced fully automatic. (Won\u0026rsquo;t require the user to add ingredients manually) Recipes can be searched by ingredients. Multiple users \u0026amp; permission system: The admin can create new users and assign them to predefined groups, that have different permissions. Track the remaining amount of liquid of the connected bottles and prevent an order if the remaining liquid doesn\u0026rsquo;t reach. It is also able to switch between pumps on the fly. If one order empties one bottle, but another bottle with the same ingredient is connected, the application will empty the first container and will switch to the second one mid-production. Docker deployment The whole application can be deployed as a docker container that has to be started in privileged mode. This allows even beginners that don\u0026rsquo;t have much experience to build their own machine.\n"},{"uri":"https://pi4j.com/documentation/create-context/","title":"Creating a Pi4J Context","tags":[],"description":"","content":"The context is an immutable runtime object that holds the configured state and manages the lifecycle of a Pi4J instance. It includes all loaded plugins, providers, platforms, I/O instance registry, environmental configuration and runtime objects including executor thread pools, I/O event listeners, etc.\nTerminating/destroying the context stops and releases all resources, threads, listeners, and provisioned I/O instances held by the context.\nVersion 1 was implemented using a static singleton, while version 2 uses a \u0026ldquo;Context\u0026rdquo; to avoid static singletons.\nCreating a Context A Pi4J Context can be created automatically (accepting all default context configurations) or manually (builder) allowing users to customize the context configuration.\nAutomatic An auto context includes AUTO-DETECT BINDINGS enabled which will load all detected Pi4J extension libraries (Platforms and Providers) in the class path. Note: Starting with 2.5.0-SNAPSHOT the Mock providers are not loaded. If the Mock providers are required see Alternate Context Creation With Mock Providers.\nvar pi4j = Pi4J.newAutoContext(); Builder If you need more flexibility are specific use-cases, the builder can be used to define all the parameters of the context, for example when you want to use your own providers, use mocked instances for testing\u0026hellip;:\nContext pi4j = Pi4J.newContextBuilder() .add(new MockPlatform()) .add(MockAnalogInputProvider.newInstance(), MockAnalogOutputProvider.newInstance(), MockSpiProvider.newInstance(), MockPwmProvider.newInstance(), MockSerialProvider.newInstance(), MockI2CProvider.newInstance(), MockDigitalInputProvider.newInstance(), MockDigitalOutputProvider.newInstance()) .add(new MyCustomADCProvider(/* implements AnalogInputProvider, id=\u0026#34;my-adc-prov\u0026#34; */)) .add(new MyCustomSPIProvider(/* implements SpiProvider, id=\u0026#34;my-spi-prov\u0026#34; */)) .build(); Alternate Context Creation With Mock Providers The following code example will create a Context containing all the Mock Providers and Platform.\nContext pi4j = Pi4J.newContextBuilder().autoDetectMockPlugins().autoDetectPlatforms().build(); More information Use a single Context instance A single Context instance must be created in your application and shared between the classes. A Context object contains all the runtime and management state of the I/O. If you would use multiple Context objects and attempt to reuse certain I/O hardware or I/O providers it\u0026rsquo;s possible that they could conflict or get out of sync.\nGet GPIO handlers from the Context The Context maintains a reference to each I/O instance created, until pi4j.shutdown() is called.\nSomewhere you will need to create() your I/O instance giving it a unique ID (String). If you try to call create() a second time with the same ID, you will get an IOAlreadyExistsException.\npi4j.digitalOutput().create(1, \u0026#34;my-gpio\u0026#34;); Elsewhere in your application, you can get access to existing I/O instances using the Context\u0026rsquo;s io() or getIO() methods.\nif (pi4j.hasIO(\u0026#34;my-gpio\u0026#34;)) { DigitalOutput myOutput = pi4j.io(\u0026#34;my-gpio\u0026#34;); } Additional methods to access the registered I/O instances can be obtained through the Registry class.\npi4j.registry().* "},{"uri":"https://pi4j.com/featured-projects/street-artist-robot/","title":"Didier the street artist robot","tags":[],"description":"","content":"Meet \u0026ldquo;Didier\u0026rdquo; the street artist robot, a project by Duvam. The sources are shared on github.com/duvamduvam/didier-java.\n"},{"uri":"https://pi4j.com/getting-started/user-interface-with-javafx/","title":"User interface with JavaFX","tags":["Digital Input","Digital Output","JavaFX","Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-javafx\nJavaFX is a framework to create user interfaces for desktop (Windows, Mac, Linux) and mobile phones. JavaFX is an opensource project which is documented on openjfx.io and the sources are available in this GitHub project.\nThe main goal of Java has always been to be able to create applications which are \u0026ldquo;write once, run everywhere\u0026rdquo;. JavaFX promises the same for Graphical User Interface applications.\nGluon is the main maintainer of the OpenJFX project and offers commercial support to companies who want to use JavaFX in critical applications. They also provide tools to build and compile Java code to native applications for all platforms.\nDeveloping a JavaFX Application The best part of Java is the \u0026ldquo;Write Once, Run Everywhere\u0026rdquo;. This means you can develop your application on any PC (Windows, Mac, Linux) and run it on any other one of these (yes even on mobile) with the exact same look-and-feel and behavior. The only limitation is the part you develop specifically for the Raspberry Pi: controlling the GPIOs with Pi4J.\nThe most used IDE for Java development is IntelliJ IDEA, which is not available for Raspberry Pi. If you are using it on your PC and want to learn more about the best approach to get started with JavaFX, read this great tutorial \u0026ldquo;Beginning JavaFX Applications with IntelliJ IDEA\u0026rdquo; by Carl Dea.\nJavaFX on Raspberry Pi JavaFX is also an ideal framework to build Java applications with a user interface for the Raspberry Pi!\nYou can find a runtime version dedicated to the Raspberry Pi on the Gluon download page. Let\u0026rsquo;s install it on our board, so we can start Java+JavaFX applications which make best use of the capabilities of the Raspberry Pi.\nInstallation To get the latest version on your Raspberry Pi, first check the Gluon download page for the download link.\nCopy the link and use it with wget to download the file:\nDownload the file $ wget -O openjfx.zip https://gluonhq.com/download/javafx-17-ea-sdk-linux-arm32/ Unzip the file $ unzip openjfx.zip Move the unzipped directory to the opt-directory (optionally, but it\u0026rsquo;s a logical place) $ sudo mv javafx-sdk-17/ /opt/javafx-sdk-17/ Start an Application Now the OpenJFX-runtime is available on our Raspberry Pi, we can start each Java application which was compiled to a JAR with some additional parameters to run it with the best rendering support.\nThe additional arguments are needed to link to the downloaded JavaFX library and select the correct Monocle platform.\njava \\ -Dglass.platform=gtk \\ -Djava.library.path=/opt/javafx-sdk-17/lib \\ -Dmonocle.platform.traceConfig=false \\ -Dprism.verbose=false \\ -Djavafx.verbose=false \\ --module-path .:/opt/javafx-sdk-17/lib \\ --add-modules javafx.controls \\ --module {YOUR_MAIN_CLASS} $@ Minimal Example Application Sources In this repository https://github.com/Pi4J/pi4j-example-javafx, a minimal example project is provided which combines Java, JavaFX, Pi4J and a few buttons. The wiring for this example is identical to the Minimal example application with a single LED and button.\nJavaFX UI after start-up\nJavaFX UI after click on physical button\nLED turned on by clicking on the JavaFX button\nSteps to Test the Application Download the sources to your Raspberry Pi $ git clone https://github.com/pi4j/pi4j-example-javafx Move to the downloaded directory $ cd pi4j-example-javafx Build the project $ mvn package Move to the target \u0026gt; distribution directory $ cd target/distribution Run the application with the provided run-script $ sudo ./run.sh "},{"uri":"https://pi4j.com/featured-projects/joystick-game/","title":"JMonkeyEngine with Joystick","tags":[],"description":"","content":"Pavl G. created a Java Gradle library to control a car in a JMonkeyEngine game with an arduino joystick module connected to a Raspberry Pi4 model B, using GPIO digital pins and SPI interfacing through MCP3008 ADC (Analog~Digital Converter).\nRequirements Raspberry Pi with arm processor (pi3, pi4, piZero) with a working java8 (preferred). Female-to-male jumper wires. Breadboard. Arduino Joystick module. MCP3008 IC (ADC \u0026ndash; other adcs may work too, but we are covering only MCP3008 here). Some patience and time. Difference between Analog and Digital signals? An analog signal is a continuously variable voltage between 0 and Vmax over time, examples : Temperature sensor output, Potentiometers (joysticks)\u0026hellip;. A digital signal is rather a discrete step-by-step output voltage of LOW (fall) to HIGH (rise) according to the switch position among a network of resistors. To convert from analog signals to digial signals, we need to encode the output voltage changing over time to some sequence of bits. We cannot interface analog electronics on digital devices such as (arduinos and raspberry pi w/o converting into digial signals). What\u0026rsquo;s ADC? Let\u0026rsquo;s have an example of a 3-bit Analogue to Digital Converter :\nThis is how ADC works under the hood, steps of converting Analog to Digital Analog voltage goes through Vin, Then it\u0026rsquo;s passed to a network of voltage comparators that compares its voltage to the selected reference range (Vref, which is selected at the time of wiring). If Vin \u0026gt; Vref the comparator output would be HIGH aka (1), if Vin \u0026lt; Vref the comparator output would be LOW aka (0). The significant of having a network of comparators is to encode the value of the analog signal into a digital sequence of bits. The output of comparators Dn gets passed into a 3-bit priority encoder. The priority encoder by definition, it encodes based on the high priority input and ignores the low priority input. So, if Vin = 3.5 to 4.0 V then the Comparators output = 11111111, At last when inputting the comparator output into the priority encoder the encoder gives a value of 7 which points to D7 of comparator U7 aka the last voltage level, and that\u0026rsquo;s true because our Vin is bigger than the Vref. What\u0026rsquo;s SPI? Serial Peripheral Interface (SPI) is an interface bus commonly used to send data between microcontrollers and small peripherals such as shift registers, sensors, and SD cards. It uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Our target is to transfer the output from our priority encoder to the BCM processor of our Pi throughout the SPI protocol (Synchronously over Tx from MCP3008 to Rx of the Pi). To send and receive synchronous data we use MISO (the same as CIPO) for receving data from peripherals and MOSI (the same as COPI) to send data to the peripherals. MISO : Master-in-Slave-Out = CIPO : Controller-in-peripheral-out. MOSI : Master-out-Slave-In = COPI : Controller-out-Peripheral-in. MCP3008 is used to receive analog input, so MISO or CIPO is our common active data line. CS is the chip select, it\u0026rsquo;s used to select which peripheral device to use. SCLK is the serial clock and it\u0026rsquo;s used to synchronize data on a data line, to have a clear separate message per 8 clocks (8-bit message). This diagram describes steps of how SPI Communication works in MCP3008 :\nCS = LOW -\u0026gt; signifies the selection to peripheral IO 0. SCLK += Clock. Rising edge of clock (LOW-to-HIGH) -\u0026raquo; Reads data from A/D and latches it for the MCU (micro-controller unit) -\u0026raquo; Creates the rising edges of Din line (Cyan line) -\u0026raquo; MOSI line. Falling edge of clock (HIGH-to_LOW) -\u0026raquo; Writes data from the MCU to the A/D -\u0026raquo; Creates the falling edges of Dout line bits (magneta line) -\u0026raquo; MISO line. Each input (D0, D1, D2, Dn) is an analog input that\u0026rsquo;s encoded into a 10-bit digital output (B0-B9) and then clocked out for the MCU on the falling edge of the SCLK as shown by the last data line (Dout). B-null (red circle) is the leading bit, it marks the last bit clocked out. MCP3008 ADC MCP3008 A/D Converter is a 10-bit analog to digital converter. 10-bit means : it has a maximum resolution of 10-bits in binary (1111111111) = in dec (1023) = in hex (3FF) and that\u0026rsquo;s determined by the Vref vs Dn voltage as discussed before using the voltage comparator. MCP3008 has 8 analog input channels that can be used in parallel (updated via SCLK using the SPI), the last number 8 stands for the number of analog inputs. MCP3008 controls its logic using SPI. MCP3008 can accept between 2v7 and 5v5 after which the IC may burn out. MCP3008 comes in various packages for various usages (PDIP, SOIC,\u0026hellip;.), in our case we would use the PDIP. Other adcs like MCP3002 and MCP3004 works by the same analogy, except that they can accept a max of 2 analog inputs and a max of 8 analog inputs respectively, if your project would use a max of 2 analog inputs, then you could buy MCP3002 and still can follow this tutorial. Cracking the MCP3008 Datasheet Alright, here is how to tackle down the MCP3008/MCP3004 datasheet :\nKnow your package type whether PDIP (Plastic Dual in-Line), SOIC (Small Outline IC), TSSOP (Thin Shrink Small Outline Plastic) :\nKnow your pin configuration and orientation :\nIn our case, we do a tutorial, so we will use PDIP (Plastic-Dual-In-Line) package : So, our pins outline are as follows : Know the meaning of pins on your package :\nThis is the hardest part of understanding how an IC work, but quick looking on an internal diagram may be insightful :\nAs you can see the MCP has a different way of comparing VREF and Din and encoding the results, it uses a modern way called 10-bit SAR - Successive Approximation Register and a DAC which we will not cover in this tutorial but the net result is the same as a using a network of resistors with comparators.\nKnow the max ratings of various IC properties before wiring up :\nVDD-Max-Rating = 5v5. VREF-Max-Raing = 5v5, min-working-voltage = 2v7. Analog-Channel-Max-Rating = VREF = 5v5 \u0026ndash; after that the channel may burn or the IC may not work. Max-Clock-Rating = f-CLK = 3.6 MHZ on 5v5, 1.35 MHZ on 2v7. Error = +/- 1.0 LSB (least significant bit). Resolution = max analog value = 10-bits = 0b1111111111 = 1023. Other data like CLK rising, falling and setup time are neglectable. You may pay attention to temperature data if your project works in a special temperature case like a hot place or freezer or etc. Have some fun with the IC.\nWiring Up Vcc : is used for powering up the IC and not to compare with VREF. Vref : is used for controlling the maximum resolution of the input voltage (analog signal), if VREF = 5v5 (maximum voltage received by MCP3008), then the resolution of Vin is a 100%. Testing the wiring Before going deeper and testing with jme vehicle, please test this code and do your conclusions :\n// Define MCP3008 provider on CS0 -- Peripheral device 0 final MCP3008GpioProvider mcp3008GpioProvider = new MCP3008GpioProvider(SpiChannel.CS0); // define analog input pins on the adc final GpioPinAnalogInput[] gpioPinAnalogInput= new GpioPinAnalogInput[2]; gpioPinAnalogInput[0] = MCP3008Pin.CH0; gpioPinAnalogInput[1] = MCP3008Pin.CH1; // define the threshold analog (the minimum voltage at which the Pi can listen to). mcp3008GpioProvider.setEventThreshold(thresholdAnalogValue, gpioPinAnalogInput); // enable monitoring of analog values with an interval of 250 ms mcp3008GpioProvider.setMonitorEnabled(true); mcp3008GpioProvider.setMonitorInterval(250); // start collecting data from the SPi connected to MCP3008 output. final GpioController gpioController = GpioFactory.getInstance(); gpioController.addListener((GpioPinListenerAnalog) event -\u0026gt; { System.out.println(\u0026#34;Value at CH0 : \u0026#34; + mcp3008GpioProvider.getValue(gpioPinAnalogInput[0])); System.out.println(\u0026#34;Value at CH1 : \u0026#34; + mcp3008GpioProvider.getValue(gpioPinAnalogInput[1])); }, gpioPinAnalogInput); Testing with a jmonkeyengine vehicle It\u0026rsquo;s very hard to give you a full overview of how to create a jmonkeyengine vehicle in this tutorial, so you could fairly refer to jme docs and examples for more :\nUse the physics in your game and control your game via keyboard : https://wiki.jmonkeyengine.org/docs/3.4/tutorials/beginner/hello_physics.html A Keyboard controlled car demo : https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestPhysicsCar.java The idea is simple, any game can be controlled using a keyboard interface (bound to jme update), so you can simply replace that with a custom InputHandler using a custom hardware. The trick is to bind your joystick pi4j interface to jme thread (OpenGL\u0026rsquo;s thread). Video of operation More at sources ADC overview : https://www.electronics-tutorials.ws/combination/analogue-to-digital-converter.html MCP3008 ADC : https://www.microchip.com/en-us/product/MCP3008 SPI overview : https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all Gradle lib : https://github.com/Scrappers-glitch/JoyStickModule Testcase : https://github.com/Scrappers-glitch/JmeCarPhysicsTestRPI "},{"uri":"https://pi4j.com/documentation/platforms/","title":"Choosing a Platform","tags":[],"description":"","content":"Platforms are extensible service modules responsible for defining a set of default I/O providers and specific hardware capabilities for an embedded hardware system where Pi4J is deployed/running.\nTechnically speaking \u0026hellip; multiple platforms could be loaded into the runtime context, but only one will be considered the default platform for most I/O provisioning and operations. An example of this could be both a RaspberryPi Platform and Mock Platform are detected as plugins and loaded into the context, but only one will be determined at runtime to be the default platform used by the context.\nSome priority scheme will need to be implemented and invoked at runtime to resolve which is the best \u0026ldquo;platform\u0026rdquo; to accept as the default platform at runtime (on start up).\nThe idea here is that a user could have multiple platform plugins in their directory but only one, theoretically the best suited, will be determined and used at runtime based on the runtime environment which makes it possible to develop, run and test on e.g. Windows with the MockPlatform and when finished run on the Raspberry Pi with the same generated jar\u0026rsquo;s which use the RaspberryPiPlatform.\nCurrent supported platforms:\nRaspberry Pi "},{"uri":"https://pi4j.com/getting-started/fxgl/","title":"Game development with FXGL","tags":["JavaFX"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl\nAs described on the previous page you can use JavaFX to build user interfaces which behave exactly the same on your PC and Raspberry Pi. Let\u0026rsquo;s go a step further and make a game with an \u0026ldquo;Arcade\u0026rdquo; controller.\nFor this project, we will be using FXGL, an opensource library on top of JavaFX to build games.\nThe image of the crowpi project has every prerequisite installed to work with javaFX/FXGL\nThe controller This project uses an Arcade kit in combination with a Picade X HAT USB-C to easily connect the wires of the buttons and joystick.\nConnect the USB power to the hat instead of your Raspberry Pi, and use the power button on the hat to start your Raspberry Pi.\nArcade kit components\nPicade Hat\nAssembled Picade Hat and Arcade kit\nConnected wires on Picade Hat\nPicade Hat pin numbers\nPimoroni provides a GitHub project with software to use this hat with RetroPie, but this project aims to take full control of the hardware with Java.\nThe GPIO numbers are defined by the hat and can be found on pinout.xyz\nSteps to run snake on your Raspberry Pi Download the project from GitHub and build it: $ git clone https://github.com/Pi4J/pi4j-example-fxgl.git $ cd pi4j-example-fxgl/ $ mvn clean package Change to the distribution directory where you can find the generated package and required Java-modules. Start it with the provided run.sh script: $ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 364456 Jun 19 10:04 pi4j-core-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 7243 Jun 19 10:04 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 142461 Jun 19 10:04 pi4j-library-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 37302 Jun 19 10:04 pi4j-plugin-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 26917 Jun 19 10:04 pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run.sh -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run-kiosk.sh -rw-r--r-- 1 pi pi 52173 Jun 19 10:04 slf4j-api-2.0.0-alpha0.jar -rw-r--r-- 1 pi pi 15372 Jun 19 10:04 slf4j-simple-2.0.0-alpha0.jar $ sudo ./run.sh There are two run scripts: run.sh: runs the application in standard windowed mode run-kiosk.sh: runs the application in DRM mode, see kiosk mode\nPicade To control our game we use the hardware mentioned above. Tho following mapper uses a similar binding method as in the minimal example\nPimapper To make use of the picade controls for existing FXGL project we provide an interface to simply extend your application.\nIntegrate piMapping The code for the piMapper is found in the example snake game.\nUpdate Game Change your Game from “extend GameApplication” to “extend PicadeGameApplication” PicadeGameApplication overrides the GameApplication class of FXGL and provides additional functions to map the picade controllers\npublic class FxglExample extends PicadeGameApplication Update Key Inputs Now we can use the new piMapper to address keys as well as picade controls. To do this, we need to tell the onKeyDown function, what control we want. Inputs are defined as in previous tutorials in the picadeControl enum\nonKeyDown(PicadeControl.PIN_BUTTON_1, KeyCode.F, () -\u0026gt; player.getComponent(SnakeHeadComponent.class).grow()); onKeyDown(KeyCode.G, () -\u0026gt; player.getComponent(SnakeHeadComponent.class).log()); GPIO The Enum PicadeControl handles the the gpio numbers for the connected controls. pinout.xyz PIN_JOYSTICK_UP(12), PIN_JOYSTICK_DOWN(6), PIN_JOYSTICK_LEFT(20), PIN_JOYSTICK_RIGHT(16), PIN_BUTTON_1(5); Run Scripts run.sh Runs the application in windowed mode\n#!/usr/bin/env bash java \\ -Dglass.platform=gtk \\ -Djava.library.path=/opt/javafx-sdk-17/lib \\ -Dmonocle.platform.traceConfig=false \\ -Dprism.verbose=false \\ -Djavafx.verbose=false \\ --module-path .:/opt/javafx-sdk-17/lib \\ --add-modules javafx.controls \\ --module com.pi4j.example/com.pi4j.example.FxglExample $@ run-kiosk.sh Runs the application with monocle in DRM (Direct rendering mode). More to kiosk mode here\n"},{"uri":"https://pi4j.com/featured-projects/sensor-drivers/","title":"Sensor drivers","tags":["ADS1115","BME280","BMP180","HTU21D","PCF8591","BH1750"],"description":"","content":"In case you want to read the data from various I2C sensors connected to Raspberry Pi the difficult part is usually writing a piece of code which talks to the I2C sensor.\nrpi-drivers is a Java library by Juraj Veverka implementing simple APIs and communication code for some widely used I2C sensors. You can easily measure temperature, pressure and humidity, get ambient light intensity or measure voltage in your java Raspberry Pi projects.\nSupported sensors are:\nADS1115 BME280 BMP180 HTU21D PCF8591 BH1750 Simply include rpi-drivers dependency into your Java Gradle or Maven project, and you are good to go!\n"},{"uri":"https://pi4j.com/getting-started/fxgl/fxgl-to-picade/","title":"FXGl to Picade","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl\nIn this section we demonstrate how to convert existing FXGL projects to work on a RaspberryPi\nIf you don\u0026rsquo;t have an existing FXGL project, go grab one from FXGLGames\nSteps to get your app running on a RaspberryPi Add Maven support to your project In our project we use Maven to manage dependencies and build the application, other build tools such as gradle are also viable but not covered in this tutorial. In the Project tool window, right-click your project and select Add Framework Support In the dialog that opens, select Maven from the options on the left and click OK Add run scripts Create a folder called assets in the root directory of your project. Copy the run scripts into the folder\nChange the module names according to your projects module\nEdit pom.xml Extend the properties tag with dynamic maven compiler version based of the projects java version\n\u0026lt;!-- JAVA COMPILER VERSIONS --\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;${java.version}\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;${java.version}\u0026lt;/maven.compiler.target\u0026gt; Also in the properties tag, additionally to the base dependencies from Minimal example application add the dependency version for FXGL and the build plugins.\n\u0026lt;!-- DEPENDENCIES VERSIONS --\u0026gt; \u0026lt;slf4j.version\u0026gt;2.0.0-alpha0\u0026lt;/slf4j.version\u0026gt; \u0026lt;pi4j.version\u0026gt;2.0-SNAPSHOT\u0026lt;/pi4j.version\u0026gt; \u0026lt;fxgl.version\u0026gt;11.16\u0026lt;/fxgl.version\u0026gt; \u0026lt;!-- BUILD PLUGIN VERSIONS --\u0026gt; \u0026lt;exec-maven-plugin.version\u0026gt;1.6.0\u0026lt;/exec-maven-plugin.version\u0026gt; \u0026lt;maven-compiler-plugin.version\u0026gt;3.8.1\u0026lt;/maven-compiler-plugin.version\u0026gt; In the FXGL version 11.16 sepcial javaFX libraries are included to run on raspberryPi\nAdd following dependency for FXGL:\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- FXGL library which includes JavaFX --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.almasb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fxgl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${fxgl.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; The following code is used to build the application in order to run it on the raspberryPi. Insert the module path and the path to the main class at the with [INSERT MODULE PATH] marked location. For example: com.pi4j.example/com.pi4j.example.FxglExample\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- JAVA COMPILER --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-compiler-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;release\u0026gt;${java.version}\u0026lt;/release\u0026gt; \u0026lt;showDeprecation\u0026gt;true\u0026lt;/showDeprecation\u0026gt; \u0026lt;showWarnings\u0026gt;true\u0026lt;/showWarnings\u0026gt; \u0026lt;verbose\u0026gt;false\u0026lt;/verbose\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- DEFAULT JAR EXECUTABLE CLASS --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;exec-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${exec-maven-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;java\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;executable\u0026gt;java\u0026lt;/executable\u0026gt; \u0026lt;arguments\u0026gt; \u0026lt;argument\u0026gt;--module-path\u0026lt;/argument\u0026gt; \u0026lt;argument\u0026gt;${project.build.directory}/distribution\u0026lt;/argument\u0026gt; \u0026lt;argument\u0026gt;--module\u0026lt;/argument\u0026gt; \u0026lt;argument\u0026gt;[INSERT MODULE PATH]\u0026lt;/argument\u0026gt; \u0026lt;/arguments\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- BUILD THE FINAL JAR FILE IN THE /target/distribution PATH --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/distribution\u0026lt;/outputDirectory\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- COPY ANY RUNTIME SCRIPTS TO THE /target/distribution PATH --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-antrun-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;target\u0026gt; \u0026lt;copy todir=\u0026#34;${project.build.directory}/distribution\u0026#34; overwrite=\u0026#34;true\u0026#34; flatten=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;fileset dir=\u0026#34;assets\u0026#34; includes=\u0026#34;*.sh\u0026#34;\u0026gt;\u0026lt;/fileset\u0026gt; \u0026lt;/copy\u0026gt; \u0026lt;chmod dir=\u0026#34;${project.build.directory}/distribution\u0026#34; perm=\u0026#34;ugo+rx\u0026#34; includes=\u0026#34;**/*.sh\u0026#34;/\u0026gt; \u0026lt;/target\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;run\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- DOWNLOAD RUNTIME DEPENDENCIES --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;process-sources\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-dependencies\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/distribution\u0026lt;/outputDirectory\u0026gt; \u0026lt;includeScope\u0026gt;runtime\u0026lt;/includeScope\u0026gt; \u0026lt;excludeTransitive\u0026gt;false\u0026lt;/excludeTransitive\u0026gt; \u0026lt;overWriteReleases\u0026gt;false\u0026lt;/overWriteReleases\u0026gt; \u0026lt;overWriteSnapshots\u0026gt;true\u0026lt;/overWriteSnapshots\u0026gt; \u0026lt;overWriteIfNewer\u0026gt;true\u0026lt;/overWriteIfNewer\u0026gt; \u0026lt;!-- On the Raspberry Pi we use specific JavaFX dependencies, so we exclude them here and they are added in the run-script. --\u0026gt; \u0026lt;excludeGroupIds\u0026gt;org.openjfx\u0026lt;/excludeGroupIds\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; Add module-info In our build we run modules. This module has to be defined in module-info.java.\nAdd all required dependencies for your project here.\nMore info for modular FXGL here\nopen module com.pi4j.example { // Pi4J MODULES requires com.pi4j; requires com.pi4j.plugin.pigpio; // SLF4J MODULES requires org.slf4j; requires org.slf4j.simple; requires com.almasb.fxgl.all; uses com.pi4j.extension.Extension; uses com.pi4j.provider.Provider; // allow access to classes in the following namespaces for Pi4J annotation processing exports com.pi4j.example to com.almasb.fxgl.core; } "},{"uri":"https://pi4j.com/getting-started/fxgl/kiosk-mode/","title":"JavaFX kiosk mode","tags":[],"description":"","content":" Visit webtechie.be for the full blogpost\nKiosk Mode With Gluon\u0026rsquo;s JavaFX 17-ea, we are able to run applications in different modes: Desktop and Kiosk mode. In this post we focus on the Kiosk mode only.\nWith this approach, the application is the only thing you see on the screen. This prevents the user to open any other applications, or mess up your system. In this case, there is no need for a window manager, and the application directly uses the underlying (hardware) framebuffer. To achieve this, we use Monocle with EGL and DRM, as that is the Linux approach to directly address the hardware acceleration, without a window manager. The JavaFX application is using Direct Rendering Mode (DRM) to be visualized. An extra benefit is the performance boost, as your program is the only thing that needs to be handled towards the screen.\nBy using /sbin/init 3 before the application starts, the desktop mode is stopped. As DRM in JavaFX 17-ea is part of the commercial license of Gluon, we need to set the environment value ENABLE_GLUON_COMMERCIAL_EXTENSIONS, for more info see Gluon docs: “JavaFX on Embedded” \u0026gt; “Legal notice”. The display id needs to be defined, if card0 is not working and you get the error [GluonDRM] Device /dev/dri/card0 could be opened, but has no drm capabilities., try card1. More info is provided on Gluon docs: “JavaFX on Embedded” \u0026gt; “Testing JavaFX”. After the application is stopped, we call /sbin/init 5 to restart the regular desktop environment. #!/usr/bin/env bash /sbin/init 3 export ENABLE_GLUON_COMMERCIAL_EXTENSIONS=true java \\ -Degl.displayid=/dev/dri/card0 \\ -Dmonocle.egl.lib=/opt/javafx-sdk-17/lib/libgluon_drm-1.1.3.so \\ -Djava.library.path=/opt/javafx-sdk-17/lib \\ -Dmonocle.platform.traceConfig=false \\ -Dprism.verbose=false \\ -Djavafx.verbose=false \\ -Dmonocle.platform=EGL \\ --module-path .:/opt/javafx-sdk-17/lib \\ --add-modules javafx.controls \\ --module com.pi4j.example/com.pi4j.example.FxglExample $@ /sbin/init 5 To run the application in kiosk mode it is recommended to have an open ssh session on the side to follow the process or in case of errors, being able to restart the desktop with:\n/sbin/init 5 Performance By disabling the window manager, more ressources are available for the application, therefore running more performant. To test the performance of the windowed mode and kiosk mode, several tests have been executed.\nRaspberryPi model: RaspberryPi 4 8G Model B\nThe tests were run with 50, 100 and 500 balls. The results of the study show that even thought many more resources are available, the game does not run the expected amount smoother. A slight increase of RAM and CPU is noticeable, but the average frames per second do not improve that much. Non the less, the FPS was more stable while running in kiosk mode and might be an advantage when running games.\nOverall the kiosk mode has advantages over the windowed mode but using the kiosk mode exclusively to boost the performance is not recommended.\nExtra tips Gluon documentation Gluon keeps the documentation for Raspberry Pi constantly updated, keep an eye on gluonhq to stay up-to-date.\n64-bit OS and JavaFX If you want to go 64-bit, you can use the same approach. There is no official 64-bit Raspberry Pi OS yet, but you can find more information on “Faster \u0026amp; More Reliable 64-bit OS on Raspberry Pi 4 with USB Boot”.\nUnclutter Another great addition for a kiosk approach is Unclutter, a small tool which hides your mouse cursor when you do not need it. You only have to move the mouse for the cursor to reappear.\nsudo apt install unclutter To run the application in kiosk mode it is recommended to have an open ssh session on the side to follow the process or in case of errors, being able to restart the desktop with:\n/sbin/init 5 "},{"uri":"https://pi4j.com/documentation/providers/","title":"Choosing an I/O Provider","tags":["GpioD","LinuxFS","PiGpio"],"description":"","content":"Providers are extensible service modules responsible for the concrete implementation of a specific I/O type. The providers also allow to separate the internal logic of the Pi4J core from the concrete implementation of the board on which they are used.\nPi4J 2.0 - 2.4: Multiple providers for the same I/O type can be loaded into a Pi4J context concurrently. For example a \u0026ldquo;RaspberryPi-DigitalInputProvider\u0026rdquo; and \u0026ldquo;GertBoard-DigitalInputProvider\u0026rdquo; could both be loaded and both providing digital inputs at the same time.\nAs of Pi4J 2.5 multiple providers for the same I/O type is no longer supported. During the Context initialization it will ensure only a single provider for an I/O type is loaded. In addition the Mock Providers are not loaded unless expressly requested when creating the Context. See Create Context\nCurrent supported providers:\nGpioD Was introduced in Pi4J 2.5.0 Pro Works on Raspberry Pi 5 Doesn\u0026rsquo;t need sudo Supports DigitalInput and DigitalOutput LinuxFS Pro Works on Raspberry Pi 5 Generic for any SoC supporting LinuxFS Supports I2C, SPI, and PWM Hardware Doesn\u0026rsquo;t need sudo Contra Doesn\u0026rsquo;t provide serial and SPI DigitalInput and DigitalOutput under construction Latency (? - still to be tested) PiGpio Pro Provides all types of communication: DigitalInput, DigitalOutput, PWM, I2C, SPI, Serial Can be used remotely Contra Needs to run as sudo 03/22/2024 Does not support Raspberry Pi 5 Possible future providers:\nPi5 SPI, under construction. Pi5 Serial. At present the intent is no Pi4j Serial provider on Pi5. As an alternative see jSerialComm. RemoteProvider to control the I/O from a remote device e.g. through websockets Pi4J 2.5 Provider not found\nPi4J 2.5 ensuring a single provider for an I/O type is loaded may result in the provider your code references not being found because it was replaced by a higher priority provider. If you encounter this case, you can remove the unwanted provider plugin from your pom.xml file dependencies. Then after a clean and rebuild of your program the unwanted provider will no longer be loaded.\nPrettyPrint loaded providers. After creating the Context the following code will print the currently loaded provider for each I/O type.\nSystem.out.println(\u0026#34;-------------------------------------------------\u0026#34;); System.out.println(\u0026#34;PI4J PROVIDERS\u0026#34;); System.out.println(\u0026#34;-------------------------------------------------\u0026#34;); pi4j.providers().describe().print(System.out); System.out.println(\u0026#34;-------------------------------------------------\u0026#34;); "},{"uri":"https://pi4j.com/getting-started/javafx-mvc-template/","title":"JavaFX GUI and MVC template","tags":["Digital Input","Digital Output","JavaFX","Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-template-javafx\nThe FHNW University created a template project which is now part of the Pi4J example repositories.\nThe goal of this project is to:\nProvide a clear step-by-step how to prepare your Raspberry Pi Provide multiple test and start applications Explain the use of a MVC-model (Model-View-Controller) to clearly split data, actions and user interface Explain the use of JUnit test Sources and Info Please check the README of the sources of the project for a full description of the setup process of the Raspberry Pi and to fully understand the example applications and the MVC-model. This page is only intended to give you a quick overview.\nExample Applications HelloFX A simple application to test if the JavaFX libraries are installed correctly. Should not be used as a template for one\u0026rsquo;s own JavaFX applications.\nWiring The two other example applications use an LED and a button. These must be wired as is shown in the following diagram:\nMinimalPi4J The MinimalPi4j application is a Pi4j only application without a GUI. This application is also only used to test the setup and can be deleted after testing.\nPressing the button should generate a message in the console.\nOnce the Pi4J setup has been tested, MinimalPi4J can be deleted.\nTemplateApp This application shows the interaction between a JavaFX based Graphical User Interface (GUI) and the Raspberry Pi connected sensors and actuators, the Physical User Interface (PUI).\nThis application is to be used as a template for one\u0026rsquo;s own applications. This includes the existing test cases.\nYou should first get to know and understand the example. For your own applications you should then copy the the TemplateApp and modify it for your project, however without violating the rules of the MVC concept.\nTemplatePUIApp The MVC concept should also be used for applications without a GUI.\nWhen developing PUI only applications, or when adding the GUI later, then one should use the TemplatePUIApp as template.\nThe MVC concept The classic Model-View-Controller concept contains in addition to the starter class at least 3 more classes. The interaction is clearly defined:\nThis way the GUI and PUI are completely separated from each other, i.e a GUI button to turn an LED on has no direct access to the LED component of the PUI. Instead the GUI button triggers a corresponding action in the controller which then sets the on state property in the model. The PUI listening on this state then turns the actual LED on or off.\nGUI and PUI work with the same identical controller and thus also the same identical model.\nIn the MVC concept, every user interaction traverses the exact same cycle:\nConclusion You can use the same architecture (MVC) to implement a JavaFX-based GUI, a PUI attached to a Raspberry Pi, and integrate both in a clean, modular way.\n"},{"uri":"https://pi4j.com/documentation/providers/gpiod/","title":"GpioD Provider","tags":["GpioD","Digital Input","Digital Output"],"description":"","content":"The GpioD plugin provider was added in Pi4J 2.5.0 to be able to support the Raspberry Pi 5 with the new GPIO chip RP1.\nProviders in the GpioD plugin:\ngpiod-digital-input gpiod-digital-output Supported Operating System Versions The GpioD provider requires minimum kernel Bullseye 6.1.21 and Bookworm 6.6.22 !\nIf you get an error at startup with the following content, your OS is outdated for the GpioD implementation used in Pi4J:\nUNDERLYING EXCEPTION: [java.lang.UnsatisfiedLinkError]=/tmp/libgpiod368899536808039438.so: /lib/aarch64-linux-gnu/libc.so.6: version `GLIBC_2.33\u0026#39; not found (required by /tmp/libgpiod368899536808039438.so) Dependencies To use the GpioD provider include the following dependencies:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-gpiod\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Specifying the GPIO Chip On devices like industrial Raspberry Pis and the Raspberry Pi 5 that are equipped with multiple GPIO chips, it is necessary to explicitly specify the target GPIO chip when using Pi4J to control GPIO. This prevents unintended access to other GPIO chips and enables accurate control.\nChecking GPIO Chips You can check the list of GPIO chips installed on the system using the gpiodetect command.\n$ sudo gpiodetect gpiochip0 [pinctrl-bcm2711] (58 lines) gpiochip1 [raspberrypi-exp-gpio] (8 lines) gpiochip2 [1-0027] (16 lines) gpiochip3 [10-0020] (16 lines) In the example above, four GPIO chips (gpiochip0, gpiochip1, gpiochip2, gpiochip3) are detected.\nSpecifying GPIO Chips in Pi4J To control a specific GPIO chip with Pi4J, specify the GPIO chip name with the .setGpioChipName() method when creating a context using Pi4J.newContextBuilder(). This new method has been added in V3.0.0 of Pi4J.\nContext pi4j = Pi4J.newContextBuilder() .add(GpioDDigitalInputProvider.newInstance()) .setGpioChipName(\u0026#34;gpiochip2\u0026#34;) .build(); By default, gpiochip0 is used. You only need to specify the chip if you want to use another one.\n"},{"uri":"https://pi4j.com/documentation/providers/linuxfs/","title":"LinuxFS Provider","tags":["LinuxFS","PWM","I2C"],"description":"","content":"The current implementation of the LinuxFS plugin implements a file based I2C, SPI, and PWM provider. The file based I2C provider opens /dev/i2c-1 using a RandomAccessFile to perform I2C reads and writes. The file based PWM provider opens /sys/class/pwm/pwmchip? using a RandomAccessFile to perform PWM operations.\nThe Linuxfs provider linuxfs-pwm requires minimum kernel Bullseye 6.1.21 and Bookworm 6.6.22 !\nProviders in the LinuxFS plugin:\nlinuxfs-i2c linuxfx-spi linuxfs-pwm \u0026ndash;\u0026gt; check below for important info about the channel configuration! Under construction linuxfs-digital-input linuxfs-digital-output To use the LinuxFS provider include the following dependencies:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-linuxfs\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; I2C Example on how to use I2C with LinuxFS:\nContext pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j).id(\u0026#34;TCA9534\u0026#34;).bus(1).device(0x3f).build(); try (I2C tca9534Dev = i2CProvider.create(i2cConfig)) { int config = tca9534Dev.readRegister(TCA9534_REG_ADDR_CFG); tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, currentState); tca9534Dev.writeRegister(TCA9534_REG_ADDR_CFG, (byte) 0x00); tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, newState); } pi4j.shutdown(); SPI The buffer size for this SPI implementation is 4096 bytes. This can be configured in config.txt:\nDebian Bullseye OS: /boot/config.txt Raspberry Pi OS, based on Debian Bookworm: /boot/firmware/config.txt var spiConfig = Spi.newConfigBuilder(pi4j) .id(SPI_PROVIDER_ID) .name(SPI_PROVIDER_NAME) .bus(spiBus) .chipSelect(chipSelect) .baud(Spi.DEFAULT_BAUD) .mode(SpiMode.MODE_0) .provider(\u0026#34;linuxfs-spi\u0026#34;) .build(); var spi = pi4j.create(spiConfig); PWM To use PWM with the LinuxFS provider, it\u0026rsquo;s important to understand the config builder needs the channel number, not the BCM number! This channel number, is different depending on the type of board you are using.\nFor instance, on a Raspberry Pi 5 with the dtoverlay=pwm-2chan setting in config.txt, a PWM connection on BCM 19 must be configured as channel=3.\nSee the Pulse Width Modulation (PWM) page on how to configure hardware PWM and which channels are available per board.\nExample on how to use PWM with LinuxFS:\n/** * Builds a new PWM configuration for the buzzer * * @param pi4j Pi4J context * @param channel Channel number of the PWM * @return PWM configuration */ protected static PwmConfig buildPwmConfig(Context pi4j, int channel) { return Pwm.newConfigBuilder(pi4j) .id(\u0026#34;PWMChannel\u0026#34; + channel) .name(\u0026#34;Buzzer\u0026#34;) .address(channel) .pwmType(PwmType.HARDWARE) .provider(\u0026#34;linuxfs-pwm\u0026#34;) .initial(0) .shutdown(0) .build(); } "},{"uri":"https://pi4j.com/documentation/providers/pigpio/","title":"PiGpio Provider","tags":["PiGpio","PWM","I2C","SPI","Serial","Digital Input","Digital Output"],"description":"","content":"The current implementation of the PiGpio exposes the GPIO functions available on the Raspberry Pi (see Note Pi5 below). This implementation is developed/supported by a team separate of Pi4j. Pi4j is a consumer of that PiGpio work.\nPi5 At the present time the PiGpio implementation does not support the new Pi5 board. - This new Pi5 RP1 chip will require a large development effort. There is no known plan for this develoment. Providers in the PiGpio plugin:\npigpio-digital-input pigpio-digital-output pigpio-pwm pigpio-i2c pigpio-spi pigpio-serial Applications which use the PiGpio Provider, need to be started with sudo to be able to interface with the GPIOs.\nWhen you don\u0026rsquo;t use sudo, you\u0026rsquo;ll see an error like this:\nWARN com.pi4j.library.pigpio.impl.PiGpioNativeImpl - PIGPIO ERROR: PI_INIT_FAILED; pigpio initialisation failed To use the PiGpio provider include the following dependencies:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-pigpio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "},{"uri":"https://pi4j.com/documentation/board-info/","title":"Using Board Info","tags":[],"description":"","content":" GITHUB Sources of BoardInfoHelper.java and the data model: pi4j/pi4j-core/src/main/java/com/pi4j/boardinfo/util/BoardInfoHelper.java\nSince V2.6.0, the new class BoardInfoHelper provides the following info:\nType of Raspberry Pi board as a BoardInfo object. If the system uses a RP1 chip with usesRP1() (Raspberry Pi 5 only at this moment). If the system is 32-bit or 64-bit with is32bit() and is64bit(). The amount of memory available and used by the JVM as a JvmMemory object. Info about volt, temperature, etc. as a BoardReading object. The board info is used in some of the plugins to set the correct priority, based on the use of a Raspberry Pi 5 (with RP1) versus earlier board (without RP1).\nHow the Board Model is Detected Previous Method (\u0026lt; 2.7.1 version) In earlier versions, the board model was determined by reading the board version number from the /proc/cpuinfo file using shell commands:\n$ cat /proc/cpuinfo | grep \u0026#39;Revision\u0026#39; | awk \u0026#39;{print $3}\u0026#39; Updated Method (\u0026gt;= 2.7.1 version) Starting with version 2.7.1, the board version number is determined programmatically in Java using the CpuInfoReader class. This method reads and processes the /proc/cpuinfo file to extract the CPU revision.\nFor instance, for a Raspberry Pi Compute 4, multiple version numbers are possible:\nCOMPUTE_4(\u0026#34;Compute Module 4\u0026#34;, STACK_ON_COMPUTER, Arrays.asList(\u0026#34;a03140\u0026#34;, \u0026#34;b03140\u0026#34;, \u0026#34;c03140\u0026#34;, \u0026#34;d03140\u0026#34;, \u0026#34;a03141\u0026#34;, \u0026#34;b03141\u0026#34;, \u0026#34;c03141\u0026#34;, \u0026#34;d03141\u0026#34;), ...) Demo Use on api.pi4j.com The new BoardInfoHelper class and the related enums and methods are used as the basis for the website api.pi4j.com that visualizes all the info defined inside the library, like board info, header pins, type of pins, etc. This website runs on a Raspberry Pi board, so the System Information screen show the info about that board using this new class.\nList of boards defined in the library\nSystem Information of the Raspberry Pi running the website\nExamples Example Code var console = new Console(); var pi4j = Pi4J.newAutoContext(); // ------------------------------------------------------------ // Output Pi4J Board information // ------------------------------------------------------------ // When the Pi4J Context is initialized, a board detection is // performed. You can use this info in case you need board-specific // functionality. // OPTIONAL // Display board information console.println(\u0026#34;Board model: \u0026#34; + pi4j.boardInfo().getBoardModel().getLabel()); console.println(\u0026#34;Operating system: \u0026#34; + pi4j.boardInfo().getOperatingSystem()); console.println(\u0026#34;Java versions: \u0026#34; + pi4j.boardInfo().getJavaInfo()); // Access additional info via BoardInfoHelper console.println(\u0026#34;Board model: \u0026#34; + BoardInfoHelper.current().getBoardModel().getLabel()); console.println(\u0026#34;Raspberry Pi model with RP1 chip (Raspberry Pi 5): \u0026#34; + BoardInfoHelper.usesRP1()); console.println(\u0026#34;OS is 64-bit: \u0026#34; + BoardInfoHelper.is64bit()); console.println(\u0026#34;JVM memory used (MB): \u0026#34; + BoardInfoHelper.getJvmMemory().getUsedInMb()); console.println(\u0026#34;Board temperature (°C): \u0026#34; + BoardInfoHelper.getBoardReading().getTemperatureInCelsius()); // Access throttled states var throttledStates = BoardInfoHelper.getBoardReading().getThrottledStates(); console.println(\u0026#34;Throttled states: \u0026#34;); throttledStates.forEach(state -\u0026gt; console.println(\u0026#34; - \u0026#34; + state.name())); console.println(\u0026#34;Throttled states description: \u0026#34; + BoardInfoHelper.getBoardReading().getThrottledStatesDescription()); Example Output [main] INFO com.pi4j.util.Console - Board model: Raspberry Pi 4 Model B [main] INFO com.pi4j.util.Console - Operating system: Name: Linux, version: 6.1.21-v8+, architecture: aarch64 [main] INFO com.pi4j.util.Console - Java versions: Version: 22, runtime: 22+36, vendor: Azul Systems, Inc., vendor version: Zulu22.28+91-CA [main] INFO com.pi4j.util.Console - Board model: Raspberry Pi 4 Model B [main] INFO com.pi4j.util.Console - Raspberry Pi model with RP1 chip (Raspberry Pi 5): false [main] INFO com.pi4j.util.Console - OS is 64-bit: true [main] INFO com.pi4j.util.Console - JVM memory used (MB): 10.910163879394531 [main] INFO com.pi4j.util.Console - Board temperature (°C): 61.3 [main] INFO com.pi4j.util.Console - Throttled states: [main] INFO com.pi4j.util.Console - - UNDERVOLTAGE_DETECTED [main] INFO com.pi4j.util.Console - - SOFT_TEMPERATURE_LIMIT_ACTIVE [main] INFO com.pi4j.util.Console - Throttled states description: Under-voltage detected, Soft temperature limit active Overriding the Detected Board In some cases, you may want to overrule the detected board:\nTesting on another platform. Correct Raspberry Pi is not detected, for instance, a new type of board has not been added to BoardModel yet. You want to use Pi4J on another type of board, for instance, Orange Pi. Since V3.0.2, you can overrule the detected board in the BoardInfoHelper singleton. Make sure to do this before the Pi4J context is initialized, so the correct plugins are loaded.\n// With default GpioD chip BoardInfoHelper.current().setBoardModel(BoardModel.GENERIC); var pi4j = Pi4J.newAutoContext(); // Or if you want to use a specific chip name BoardInfoHelper.current().setBoardModel(BoardModel.GENERIC); var pi4j = Pi4J.newContextBuilder() .add(GpioDDigitalInputProvider.newInstance()) .setGpioChipName(\u0026#34;gpiochip2\u0026#34;) .build(); Two generic boards where created for this use-case, but of course, you can also use one of the other BoardModel enum values.\n// Generic model, this can be used to force the library // to load Raspberry Pi plugins on other board types GENERIC(\u0026#34;Generic board compatible with Raspberry Pi 4\u0026#34;, SINGLE_BOARD_COMPUTER, new ArrayList\u0026lt;\u0026gt;(), PiModel.MODEL_B, HeaderVersion.TYPE_3, LocalDate.now(), Soc.UNKNOWN, Cpu.UNKNOWN, 4, new ArrayList\u0026lt;\u0026gt;(), new ArrayList\u0026lt;\u0026gt;()), GENERIC_RP1(\u0026#34;Generic board compatible with Raspberry Pi 5\u0026#34;, SINGLE_BOARD_COMPUTER, new ArrayList\u0026lt;\u0026gt;(), PiModel.MODEL_B, HeaderVersion.TYPE_3, LocalDate.now(), Soc.UNKNOWN, Cpu.UNKNOWN, 4, new ArrayList\u0026lt;\u0026gt;(), new ArrayList\u0026lt;\u0026gt;(), new ArrayList\u0026lt;\u0026gt;(), true), "},{"uri":"https://pi4j.com/documentation/build-io/","title":"Building an I/O Instance","tags":[],"description":"","content":"A GPIO can be configured with Pi4J in different ways, either short for default behavior, a bit longer with additional settings, or with a full custom configuration using a building pattern.\nI/O Initialization Examples Before we can initialize an I/0, the Pi4J context must be initialized. The Pi4J static class includes a few helper context creators for the most common use cases. The newAutoContext() method will automatically load all available Pi4J extensions found in the application\u0026rsquo;s classpath which may include Platforms and I/O Providers.\nvar pi4j = Pi4J.newAutoContext(); DigitalInput Here are a few examples of the different possibilities to initialize a digital input object:\n// Shortest way var button = pi4j.din().create(INTEGER_PIN_ADDRESS); // Is equal to var button = pi4j.digitalInput().create(INTEGER_PIN_ADDRESS); // The create method can be called with more parameters var button = pi4j.din().create(INTEGER_PIN_ADDRESS, STRING_ID); var button = pi4j.din().create(INTEGER_PIN_ADDRESS, STRING_ID, STRING_NAME); var button = pi4j.din().create(INTEGER_PIN_ADDRESS, STRING_ID, STRING_NAME, STRING_DESCRIPTION); // Or you can use a configuration builder var buttonConfig = DigitalInput.newConfigBuilder(pi4j) .id(\u0026#34;button\u0026#34;) .name(\u0026#34;Press button\u0026#34;) .address(PIN_BUTTON) .pull(PullResistance.PULL_DOWN) .debounce(3000L); var button = pi4j.create(buttonConfig); DigitalOutput The examples above are also applicable for an output:\n// Shortest way var led = pi4j.dout().create(INTEGER_PIN_ADDRESS); // Is equal to var led = pi4j.digitalOutput().create(INTEGER_PIN_ADDRESS); // The create method can be called with more parameters, see above // Or you can use a configuration builder var ledConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;my-dout\u0026#34;) .name(\u0026#34;My LED\u0026#34;) .address(PIN_LED) .shutdown(DigitalState.LOW) .initial(DigitalState.HIGH); var led = pi4j.create(ledConfig); PWM, SPI, I2C, Serial The same methodology is available for other types of I/O\u0026rsquo;s:\n// Shortest way var pwm = pi4j.pwm().create(INTEGER_PIN_ADDRESS); var spi = pi4.spi().create(STRING_ID); var i2c = pi4j.i2c().create(INTEGER_BUS, INTEGER_DEVICE); var serial = pi4j.serial().create(STRING_ID); // Or using the config builder, for example, I2C: var i2cConfig = I2C.newConfigBuilder(pi4j) .id(\u0026#34;my-i2c\u0026#34;) .bus(I2C_BUS) .device(I2C_ADDRESS) .build(); var i2c = pi4j.i2c().create(i2cConfig); newConfigBuilder parameters id The id field is used internally inside the Pi4J context/runtime to keep track of the instances. If you don\u0026rsquo;t assign an id, Pi4J will create a unique ID string for the instance \u0026ndash; so its optional and only needed if you want to specify your own unique ID string.\nAdditionally, you can retrieve the I/O instance from the Pi4J context anywhere else in your program if needed by the id. This can help in some cases where you only need to pass around the single Pi4J context, and you can still gain access to the I/O instances without having to track and pass around your own variable references. So even if your variable reference to an I/O instance goes out of scope, Pi4J will maintain a reference to the I/O instance internally until it is shutdown().\n// Three ways to get existing LED output instance DigitalOutput led = pi4j.io(\u0026#34;my-led\u0026#34;); var led = (DigitalOutput) pi4j.io(\u0026#34;my-led\u0026#34;); var led = pi4j.io(\u0026#34;my-led\u0026#34;, DigitalOutput.class); Internally the I/O instances are maintained by the Registry. You can gain access to the Registry via the context. There are additional methods in registry to interrogate/discover/enumerate the created I/O instances at runtime.\n// Get the Pi4J I/O registry Registry registry = pi4j.registry(); // Check to see if the LED output already exists (by id) boolean myLedAlreadyExists = registry.exists(\u0026#34;my-led\u0026#34;); // Get all digital output instances from the Pi4J I/O registry var outputs = registry.allByIoType(IOType.DIGITAL_OUTPUT); name and description Fields like name and description are entirely optional and not used by Pi4J internally except to print if performing a describe() or toString() operation on Pi4J objects.\n// Create digital output I/O configuration var config = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;my-dout\u0026#34;) .name(\u0026#34;My Digital Output\u0026#34;) .address(GPIO_PIN) .shutdown(DigitalState.LOW) .initial(DigitalState.HIGH) .provider(\u0026#34;linuxfs-digital-output\u0026#34;); // Create digital output I/O instance using configuration var output = pi4j.create(config); // Print digital output object to system out output.describe().print(System.out); ---- // ... CONSOLE OUTPUT // \u0026gt; IO: \u0026#34;My Digital Output\u0026#34; {my-dout} \u0026lt;com.pi4j.plugin.linuxfs.provider.gpio.digital.LinuxFsDigitalOutput\u0026gt; {DOUT-26} Reuse the config The config object can be reused to create multiple GPIOs by overriding the address (and id if used) for each I/O instance:\nvar config = DigitalOutput.newConfigBuilder(pi4j) .provider(\u0026#34;linuxfs-digital-output\u0026#34;) .shutdown(DigitalState.LOW) .initial(DigitalState.LOW); var pin0 = pi4j.create(config.address(0).id(\u0026#34;my-led\u0026#34;)); var pin1 = pi4j.create(config.address(1).id(\u0026#34;my-relay\u0026#34;)); var pin2 = pi4j.create(config.address(2).id(\u0026#34;my-lock\u0026#34;)); var pin3 = pi4j.create(config.address(3).id(\u0026#34;my-pump\u0026#34;)); "},{"uri":"https://pi4j.com/examples/communityimplementation/","title":"Community Implementations","tags":["1602A","ADS1256","BMP280","DAC8552","DHT22","IS31FL3731","MCP23008","MCP23017","MCP3008","MCP4725","SN74HC595","TCA9548","VL53L0X"],"description":"","content":"On this page we want to keep a list of projects which contain implementation code for specific devices using the Pi4J V2+ core library. Please let us know via Pi4J Discussions if you want to have your project added to this list.\nCurrent available device support projects Device(s) Developed by Link 1602A LCD HD44780U Thomas Aarts github.com/Pi4J/pi4j-example-devices 1602A_LCD_PCF8574A I2C Controller Thomas Aarts github.com/Pi4J/pi4j-example-devices 1602A LCD MCP23017 I2C Controller Thomas Aarts github.com/Pi4J/pi4j-example-devices ADS1256 24bit A-to-D Thomas Aarts github.com/Pi4J/pi4j-example-devices AT24c512 SEEPROM Thomas Aarts github.com/Pi4J/pi4j-example-devices BME280 Sensor Temperature and Pressure Thomas Aarts github.com/Pi4J/pi4j-example-devices BMP280 Temperature and Pressure Sensor Thomas Aarts github.com/Pi4J/pi4j-example-devices DAC8552 16bit DAC SPI connected Thomas Aarts github.com/Pi4J/pi4j-example-devices DHT22 Temp/Humidity sensor Thomas Aarts github.com/Pi4J/pi4j-example-devices IS31FL3731 matrix controller Thomas Aarts github.com/Pi4J/pi4j-example-devices MCP23008 drive and read chip GPIOs Thomas Aarts github.com/Pi4J/pi4j-example-devices MCP23008 and MCP23017 Pin monitoring Thomas Aarts github.com/Pi4J/pi4j-example-devices MCP23017 drive and read chip GPIOs Thomas Aarts github.com/Pi4J/pi4j-example-devices MCP3008 A/D 10bit converter Thomas Aarts github.com/Pi4J/pi4j-example-devices MCP4725 12 bit DAC Thomas Aarts github.com/Pi4J/pi4j-example-devices MPL3115A2 Altitude Thomas Aarts github.com/Pi4J/pi4j-example-devices NeoPixel LED strip Thomas Aarts github.com/Pi4J/pi4j-example-devices RotaryEncoder5880 Thomas Aarts github.com/Pi4J/pi4j-example-devices SN74HC595 8 Bit shift register Thomas Aarts github.com/Pi4J/pi4j-example-devices SSD1306 OLED Display Thomas Aarts github.com/Pi4J/pi4j-example-devices TCA9548 (1x8 I2C switch) Thomas Aarts github.com/Pi4J/pi4j-example-devices VL53L0X TimeOfFlight device Thomas Aarts github.com/Pi4J/pi4j-example-devices "},{"uri":"https://pi4j.com/getting-started/learn-more/","title":"Learn more...","tags":[],"description":"","content":"Pi4J is used in a lot of projects, and you can find a lot of examples online. On this page we want to keep an up-to-date list. Do you want to add something? Please hit \u0026ldquo;Edit this page\u0026rdquo; on the top and create a pull request!\nTwitter Please share your personal or professional projects where you combine Java and the Raspberry Pi on Twitter with the hashtag #JavaOnRaspberryPi.\nOnline Articles Foojay.io is a place for friends of OpenJDK, providing articles, updated analyses, selected highlights, and categorized lists on all things Java. There is also a category of posts dedicated to Java on the Raspberry Pi.. Books Getting Started with Java on the Raspberry Pi This book by Frank Delporte includes a lot of info and history about Java itself and how to install it on the Raspberry Pi. Also, a lot of tips and tricks to become or be a better developer. And above all many simple examples on these and even more other topics:\nThe magic of Bits and Bytes and solving the confusion of Java signed values with the help of a led number display. Beautiful user interfaces made with JavaFX so you can interact with the hardware. Pi4J applications to be able to control different types of hardware like LEDs, buttons, displays, led strips, relay boards, and many more. Spring applications to interact with your Pi via web interfaces. How to set up a queue to send and receive messages to and from Arduino boards or other Pi’s. Interviews with Karen Mouws (STEM and diversity), Trisha Gee (IntelliJ IDEA), Xiaokai He (Visual Studio Code), Alexander Belokrylov (BellSoft Liberica JDK), Jakob Jenkov (Java and tutorials.jenkov.com), Johan Vos (OpenJFX, JavaFX and GluonHQ), Gerrit Grunwald (Java, JavaFX, TilesFX), Mark Heckler (Spring), Vlad Mihalcea (JPA, Hibernate) The ebook is available on Leanpub and the paper book on Elektor.\n"},{"uri":"https://pi4j.com/examples/communityimplementation/prototype-board/","title":"Prototype Board","tags":["Prototype"],"description":"","content":"A Versatile Prototype Board Experimenting with various ICs \u0026lsquo;chips\u0026rsquo; may require different methods to connect the chip to the Pi. As shown in the BMP280 usage a chip maybe available mounted on a small circuit board where connection to the Pi requires only jumpers. But even this simple means has limits as connecting several chips when using a Pi case and maybe a cooling fan creates problems. In addition some chips are only available as a socket device where a 4-28 pin socket is required. This next section demonstrates \u0026lsquo;a\u0026rsquo; way these limits can be overcome.\nConnecting to the Pi The use of breadboards adds flexibility in the ways to install and jumper to various chips. After soldering the pins to the chip breadboards you can use female-female jumpers to connect directly to the Pi Gpio pins from more than one chip breadboard.\nAlso, the jumper connections to the Pi are simplified by extending the Pi gpios to an external Gpio breadboard.\nPower off the Pi with sudo shutdown prior to making connections.\nComponent and wiring Ribbon Cable Connecting directly to the Pi 40 pin connector becomes difficult as the number of terminations increase and the use of a case and fan require minor disassembly. The 40 pin connector can be extended to a Gpio breadboard. This extension is possible with a ribbon cable.\nRibbon cable and breadboards\nOnce the ribbon cable is attached to the Pi 40 pin connector the Pi case can be secured.\nPrototyope power\nRibbon cable termination Using a 40 pin connector labeled for a Pi facilitates installing jumpers. The Gpio breadboard terminates the ribbon cable. The Gpio breadboard is wired to supply 3.3v 5v and ground through multiple pins to facilitate use of multiple chip breadboards.\nPrototype pi_40_pin_extension\nThe use of a 28 pin socket will accommodate many different chips.\nPrototype pi_28_pin_socket\nSoldering the 28 pin socket and pins associated with each of the 28 pins provides jumper connections to all pins of the inserted chip.\nThe chip breadboard also provides sets of pins for 3.3v 5v and ground. Single jumpers from the Gpio breadboard to this chip breadboard provides these multiple pins.\nPrototype board\nComplete At this point a chip can be plugged into the 28 pin connector. If you insert the chip with its pin 1 at the pin 1 of the chip breadboard it simplifies pin identification between the chips datasheet and its breadboard connection. Using the chips Datasheet jumpers connect between pins of the chip to the Pi GPIOs on Gpio breadboard connector or 5v/3.3v and ground on the chip breadboard.\nPrototype complete\n"},{"uri":"https://pi4j.com/examples/communityimplementation/bmp280/","title":"BMP280 Sensor","tags":["BMP280"],"description":"","content":"Description The BMP280 is a Pressure and temperature sensor accessed via I2C or SPI. The BMP280 is a simple device that requires the connection of few wires to operate. Because of this simplicity the device can serve as a very easy project for initial Pi and Pi4j usage. This document will explain the more simple means to connect the sensor and access the device with existing software requiring no coding. The document will also explain minimal coding required to allow greater flexibility.\nA later section explains creating a more robust proto-type environment to better support using various integrated circuits, see Prototype board.\nConnecting Adafruit BMP280 After soldering the pins to the PCB you can use female-female jumpers to connect directly to the Pi GPIO pins.\nPower off the Pi with sudo shutdown prior to making connections. Or if you complete these connections with power applied, connect CS to 3.3v before connecting Vin. This is required to ensure the I2C interface is enabled, else the chip enables SPI communication protocol.\nComponent and wiring BMP280 module The following shot is the Adafruit BMP280 module. The BMP280 chip is mounted on a small circuit board with pins to solder in for connections.\nBMP280 module\n40 pin identification This shot is the Pi with an easy to read card that identifies the 40 pin connector.\nBMP280 pi_canca_card\n40 pin connection This is the BMP280 module connected to the Pi 40 pin connector.\nBMP280 wire_cmpl\nHeader Pin/Colors – Pi 40 pin connector Pin Color Description Vin Red to Pi 3.3 pin 1 3v N/C Gnd Brown to Pi pin 6 SCK Green to Pi pin 5 SDO N/C SDI Blue to Pi pin 3 CS Orange to Pi pin 17 Validate Connections Power on the Pi. Log in as usual. Run the command i2cdetect -y 1. This command will display all I2C devices connected to I2C bus 1. In this case only the BMP280 is connected so the table should include a device 77, 0x77 being the device address of the BMP280.\nBMP280 i2cdetect\nBuild via Maven The Pi4j project uses git via github for the source code repository. The main Pi4J documentation provides details of the repository and maven build process.\nThe project Example Devices uses the prescribed Maven build process. It is easiest to git clone the Example Devices directory and use these steps to build. Note: each device within this directory contains a README.md that explains the expected Hardware connections, build process, and how to use the device via these modules.\n$ mvn clean package $ cd target/distribution $ sudo ./runBMP280.sh Program output [main] INFO com.pi4j.util.Console - I2C detail : com.pi4j.plugin.linuxfs.provider.i2c.LinuxFsI2C@45018215 bus : 1 address : 119 [main] INFO com.pi4j.util.Console - Temperatue C = 32.37366343149915 [main] INFO com.pi4j.util.Console - Temperatue F = 90.27259417669848 [main] INFO com.pi4j.util.Console - Pressure Pa = 97930.29684231618 [main] INFO com.pi4j.util.Console - Pressure InHg = 28.91894505802476 [main] INFO com.pi4j.util.Console - Pressure mb = 979.2223518169782 Supporting BMP280 Source Code BMP280 source files\nThis is part of a larger project Example Devices\nCode A simple example on how to use the BMP280 sensor. This requires Example Devices was built.\npackage com.pi4j.test.devices.bmp280; import com.pi4j.Pi4J; import com.pi4j.devices.bmp280.BMP280Device; import com.pi4j.plugin.linuxfs.provider.i2c.LinuxFsI2CProvider; import com.pi4j.util.Console; public class BMP280 { public static void main(String[] args) throws Exception { // ------------------------------------------------------------ // Initialize the Pi4J Runtime Context // ------------------------------------------------------------ // Before you can use Pi4J you must initialize a new runtime // context. // // The \u0026#39;Pi4J\u0026#39; static class includes a few helper context // creators for the most common use cases. The \u0026#39;newAutoContext()\u0026#39; // method will automatically load all available Pi4J // extensions found in the application\u0026#39;s classpath which // may include \u0026#39;Platforms\u0026#39; and \u0026#39;I/O Providers\u0026#39; var pi4j = Pi4J.newContextBuilder().add( LinuxFsI2CProvider.newInstance()).build(); // print installed providers System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); System.out.println(\u0026#34;PI4J PROVIDERS\u0026#34;); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); pi4j.providers().describe().print(System.out); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); final Console console = new Console(); console.print(\u0026#34;==============================================================\u0026#34;); console.print(\u0026#34;startup BMP280 \u0026#34;); console.print(\u0026#34;==============================================================\u0026#34;); var bmpDev = new BMP280Device(pi4j, console, 1, 0x77, \u0026#34;info\u0026#34;); bmpDev.initSensor(); console.println(\u0026#34; Dev I2C detail \u0026#34; + bmpDev.i2cDetail()); console.println(\u0026#34; Setup ----------------------------------------------------------\u0026#34;); console.println(\u0026#34; I2C detail : \u0026#34; + bmpDev.i2cDetail()); double reading1 = bmpDev.temperatureC(); console.println(\u0026#34; Temperatue C = \u0026#34; + reading1); double reading2 = bmpDev.temperatureF(); console.println(\u0026#34; Temperatue F = \u0026#34; + reading2); double press1 = bmpDev.pressurePa(); console.println(\u0026#34; Pressure Pa = \u0026#34; + press1); double press2 = bmpDev.pressureIn(); console.println(\u0026#34; Pressure InHg = \u0026#34; + press2); double press3 = bmpDev.pressureMb(); console.println(\u0026#34; Pressure mb = \u0026#34; + press3); // Shutdown Pi4J pi4j.shutdown(); } } "},{"uri":"https://pi4j.com/documentation/io-examples/","title":"I/O Examples","tags":[],"description":"","content":"Here you can find detailed examples for the different functionalities of Pi4J per I/O type.\nDigital Output (GPIO) Digital Input (GPIO) Pulse Width Modulation (PWM) Inter-Integrated Circuit (I²C) Serial Peripheral Interface (SPI) Serial (UART/RS232) 1-Wire The supported low-level I/O interface types are defined in the core library as an enumerated list.\nANALOG_INPUT(AnalogInputProvider.class, AnalogInput.class, AnalogInputConfig.class, AnalogInputConfigBuilder.class), ANALOG_OUTPUT(AnalogOutputProvider.class, AnalogOutput.class, AnalogOutputConfig.class, AnalogOutputConfigBuilder.class), DIGITAL_INPUT(DigitalInputProvider.class, DigitalInput.class, DigitalInputConfig.class, DigitalInputConfigBuilder.class), DIGITAL_OUTPUT(DigitalOutputProvider.class, DigitalOutput.class, DigitalOutputConfig.class, DigitalOutputConfigBuilder.class), PWM(PwmProvider.class, Pwm.class, PwmConfig.class, PwmConfigBuilder.class), I2C(I2CProvider.class, com.pi4j.io.i2c.I2C.class, I2CConfig.class, I2CConfigBuilder.class), SPI(SpiProvider.class, Spi.class, I2CConfig.class, I2CConfigBuilder.class), SERIAL(SerialProvider.class, Serial.class, SerialConfig.class, SerialConfigBuilder.class); "},{"uri":"https://pi4j.com/documentation/registry/","title":"I/O Registry","tags":[],"description":"","content":"An additional V2+ feature is an I/O registry where all I/O instances that have been created can be maintained, managed, re-accessed, etc. As the library keeps track of all the created I/O instances, they become publicly accessible through a registry where users can interrogate, iterate, identify and access all created I/O instances that Pi4J is managing.\nThis is very useful for add-ons/plugins that want to provide runtime information about the state of all I/O, for example a web app illustrating the current state of I/O.\nThe registry is responsible for managing I/O instance lifecycles and provides a means for your program to easily access any I/O instance using its unique identifier.\n"},{"uri":"https://pi4j.com/documentation/shutdown/","title":"Shutdown (cleanup)","tags":[],"description":"","content":"Pi4J has a shutdown method that can be used for two different purposes.\nEnd Of Application At the end of our application, the context needs to be shutdown to release the I/O and clean up the used resources.\n# Start of program var pi4j = Pi4J.newAutoContext(); # YOUR CODE GOES HERE # End of program pi4j.shutdown(); Reuse of a GPIO When you want to reuse a GPIO, it must be shutdown to clean it up. This can be done by shutting down the GPIO itself and providing the ID to the shutdown method. As an example, check this unit test:\n@Test public void testShutdownAndRecreate() throws Pi4JException { var inputConfig = DigitalInput.newConfigBuilder(pi4j) .id(\u0026#34;DIN-3\u0026#34;) .name(\u0026#34;DIN-3\u0026#34;) .address(3); // create a new input, then shutdown var input = pi4j.create(inputConfig); pi4j.shutdown(input.id()); // shouldn\u0026#39;t fail when recreating input = pi4j.create(inputConfig); // or shutting down pi4j.shutdown(input.id()); } "},{"uri":"https://pi4j.com/examples/jbang/jbang_minimal_example/","title":"Minimal Example","tags":["JBang","Digital Input","Digital Output","LED","Button"],"description":"","content":"Minimal Pi4J with JBang example GITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; Pi4JMinimalExample.java\nIntro Before proceeding with this example, make sure that you have a Raspberry Pi prepared to execute Java code with JBang as explained here.\nThe following example is based on the \u0026ldquo;Minimal example application\u0026rdquo;, and uses the same wiring with a button and LED. By using JBang we can run this project with a single file without the need of a full Maven or Gradle project, or compiling the Java code.\nApplication Create a new file Pi4JMinimalExample.java with the following content:\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? //DEPS org.slf4j:slf4j-api:1.7.35 //DEPS org.slf4j:slf4j-simple:1.7.35 //DEPS com.pi4j:pi4j-core:2.3.0 //DEPS com.pi4j:pi4j-plugin-raspberrypi:2.3.0 //DEPS com.pi4j:pi4j-plugin-pigpio:2.3.0 import com.pi4j.Pi4J; import com.pi4j.io.gpio.digital.DigitalInput; import com.pi4j.io.gpio.digital.DigitalOutput; import com.pi4j.io.gpio.digital.DigitalState; import com.pi4j.io.gpio.digital.PullResistance; import com.pi4j.util.Console; public class Pi4JMinimalExample { // Connect a button to PIN 18 = BCM 24 private static final int PIN_BUTTON = 24; // Connect a LED to PIN 15 = BCM 22 private static final int PIN_LED = 22; private static int pressCount = 0; public static void main(String[] args) throws Exception { final var console = new Console(); var pi4j = Pi4J.newAutoContext(); var ledConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;led\u0026#34;) .name(\u0026#34;LED Flasher\u0026#34;) .address(PIN_LED) .shutdown(DigitalState.LOW) .initial(DigitalState.LOW) .provider(\u0026#34;pigpio-digital-output\u0026#34;); var led = pi4j.create(ledConfig); var buttonConfig = DigitalInput.newConfigBuilder(pi4j) .id(\u0026#34;button\u0026#34;) .name(\u0026#34;Press button\u0026#34;) .address(PIN_BUTTON) .pull(PullResistance.PULL_DOWN) .debounce(3000L) .provider(\u0026#34;pigpio-digital-input\u0026#34;); var button = pi4j.create(buttonConfig); button.addListener(e -\u0026gt; { if (e.state() == DigitalState.LOW) { pressCount++; console.println(\u0026#34;Button was pressed for the \u0026#34; + pressCount + \u0026#34;th time\u0026#34;); } }); while (pressCount \u0026lt; 5) { if (led.equals(DigitalState.HIGH)) { console.println(\u0026#34;LED low\u0026#34;); led.low(); } else { console.println(\u0026#34;LED high\u0026#34;); led.high(); } Thread.sleep(500 / (pressCount + 1)); } pi4j.shutdown(); } } Running the Application Because this example uses the PiGpio plugin, we need to execute it with sudo:\nWithout the need of any further configuration, installation, dependency download, or compiling, we should now be able to run this code with:\n$ sudo `which jbang` Pi4JMinimalExample.java Downloading JDK 11. Be patient, this can take several minutes... [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED low [Thread-0] INFO com.pi4j.util.Console - Button was pressed for the 1th time [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [Thread-2] INFO com.pi4j.util.Console - Button was pressed for the 2th time [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high ... [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [Thread-8] INFO com.pi4j.util.Console - Button was pressed for the 5th time Conclusion With JBang we can have a single-source Java file that can be executed without the need for a full Maven or Gradle project. And we don\u0026rsquo;t even need to compile anything!\nJBang is a great way to simply run Java-files, helps you to quickly get started with Pi4J on the Raspberry Pi, and can be the ideal getting-started method to experiment with electronics and Java.\n"},{"uri":"https://pi4j.com/examples/jbang/jbang_pi4j_spi_led_matrix/","title":"8x8 LED Matrix","tags":["JBang","SPI","LED","LED Matrix","MAX7219"],"description":"","content":"Controlling a 8x8 LED Matrix with MAX7219 via SPI GITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; Pi4JLedMatrixSpi.java\nThis example is explained in the following video:\nIntro Before proceeding with this example, make sure that you have a Raspberry Pi prepared to execute Java code with JBang as explained here.\nWiring SPI requires four connections, but as we don\u0026rsquo;t read data back, we only connect three of them plus power and ground.\nBCM 10 (MOSI) to DIN BCM 11 (SCLK) to CLK BCM 8 (CE0) to CS 5V to VCC Ground to ground Wiring between Raspberry Pi and matrix\nWiring details\nApplication Please check the full code which is available in the GitHub repository. This is just the main method, which initializes Pi4J and the SPI-object, which is then used to configure the device and send several demo content. We invite you to take a look at the various methods to understand how content is sent to the display. This is a nice use-case to understand how bits and bytes are used to generate images and characters.\nCharacters defined by bits\nExample output\npublic static void main(String[] args) throws Exception { var pi4j = Pi4J.newAutoContext(); // Initialize SPI console.println(\u0026#34;Initializing the matrix via SPI\u0026#34;); var spiConfig = Spi.newConfigBuilder(pi4j) .id(\u0026#34;Matrix SPI Provider\u0026#34;) .name(\u0026#34;matrix-spi\u0026#34;) .bus(SpiBus.BUS_0) .chipSelect(SpiChipSelect.CS_0) .baud(Spi.DEFAULT_BAUD) .mode(SpiMode.MODE_0) .provider(\u0026#34;pigpio-spi\u0026#34;) .build(); spi = pi4j.create(spiConfig); spi.write(SpiCommand.TEST.getValue(), (byte) 0x01); System.out.println(\u0026#34;Test mode all on\u0026#34;); Thread.sleep(1000); spi.write(SpiCommand.TEST.getValue(), (byte) 0x00); System.out.println(\u0026#34;Test mode all off\u0026#34;); Thread.sleep(1000); spi.write(SpiCommand.DECODE_MODE.getValue(), (byte) 0x00); System.out.println(\u0026#34;Use all bits\u0026#34;); spi.write(SpiCommand.BRIGHTNESS.getValue(), (byte) 0x08); System.out.println(\u0026#34;Changed brightness to medium level\u0026#34; + \u0026#34; (0x00 lowest, 0x0F highest)\u0026#34;); spi.write(SpiCommand.SCAN_LIMIT.getValue(), (byte) 0x0f); System.out.println(\u0026#34;Configured to scan all digits\u0026#34;); spi.write(SpiCommand.SHUTDOWN_MODE.getValue(), (byte) 0x01); System.out.println(\u0026#34;Woke up the MAX7219, is off on startup\u0026#34;); allOff(); showOneByOne(100); showRows( 250); showCols( 250); showRandomOutput( 5, 500); showAllImages( 2000); showAllAsciiCharacters( 750); scrollAllAsciiCharacters( 50); allOff(); pi4j.shutdown(); console.println(\u0026#34;Finished\u0026#34;); } Running the Application Because this example uses the PiGpio plugin, we need to execute it with sudo. Without the need of any further configuration, installation, dependency download, or compiling, we can now run this code with:\n$ sudo `which jbang` Pi4JLedMatrixSpi.java [jbang] Resolving dependencies... [jbang] org.slf4j:slf4j-api:1.7.35 [jbang] org.slf4j:slf4j-simple:1.7.35 [jbang] com.pi4j:pi4j-core:2.3.0 [jbang] com.pi4j:pi4j-plugin-raspberrypi:2.3.0 [jbang] com.pi4j:pi4j-plugin-linuxfs:2.3.0 [jbang] com.pi4j:pi4j-plugin-pigpio:2.3.0 [jbang] Dependencies resolved [jbang] Building jar for Pi4JLedMatrixSpi.java... [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - Initializing the matrix via SPI Test mode all on Test mode all off Use all bits Changed brightness to medium level (0x00 lowest, 0x0F highest) Configured to scan all digits Woke up the MAX7219, is off on startup One by one on row 1 One by one on row 2 One by one on row 3 One by one on row 4 One by one on row 5 One by one on row 6 One by one on row 7 One by one on row 8 Row 1 is on Row 2 is on Row 3 is on Row 4 is on Row 5 is on Row 6 is on Row 7 is on Row 8 is on Col 0 is on Col 1 is on Col 2 is on Col 3 is on Col 4 is on Col 5 is on Col 6 is on Col 7 is on Random effect 1 Random effect 2 Random effect 3 Random effect 4 Random effect 5 Showing image HEART Showing image PI_LOGO Showing image SMILEY Showing image ARROW_LEFT Showing image CROSS Written to SPI : SPACE Written to SPI : A Written to SPI : B Written to SPI : E Written to SPI : I Written to SPI : S Written to SPI : T Scrolled : SPACE Scrolled : A Scrolled : B Scrolled : E Scrolled : I Scrolled : S Scrolled : T [main] INFO com.pi4j.util.Console - Finished Conclusion The given example code is pretty long as it contains many helper methods and some enums. Normally in a \u0026ldquo;full Java application\u0026rdquo;, you would create separate files for these enums to keep the code easier to organize.\nBut for an example as this one, it\u0026rsquo;s nice that we can combine everything in one file and execute it with JBang.\n"},{"uri":"https://pi4j.com/examples/jbang/bme280_temperature_humidity_pressure/","title":"BME280 Sensor","tags":["JBang","BME280","BMP280"],"description":"","content":"BME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang GITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; Pi4JTempHumPressI2C.java and github.com/Pi4J/pi4j-jbang \u0026gt; Pi4JTempHumPressSpi.java\nIntro This is an example project to demonstrate how to read the temperature, humidity and pressure from a BME280 sensor, installed on an Adafruit board that can be controlled via I2C and SPI. Such a sensor itself is a very tiny component that can be integrated in phones and many other types of devices.\nTypically, when you want to integrate such a device in a project, you\u0026rsquo;ll need to dive into the Data Sheet to find out how it needs to be controlled. If you want to better understand the code from this example, you can check the Data Sheet as the register read-outs and calculations are based on the example code you can find in that document.\nBME280 on an Adafruit board\nBME280 on an Adafruit board\nBME280 is very small\nVideo This tutorial is also explained in this video:\nEnable I2C and SPI We will be using both I2C and SPI for this experiment, so we need to make sure they are enabled:\nOpen a terminal Execute sudo raspi-config Go to \u0026ldquo;Interface Options\u0026rdquo; Go to \u0026ldquo;I2C\u0026rdquo; and select \u0026ldquo;Yes\u0026rdquo; Go to \u0026ldquo;SPI\u0026rdquo; and select \u0026ldquo;Yes\u0026rdquo; Wiring Wiring for I2C As this board can be controlled with both I2C and SPI, there are more available connections than we need for I2C. Make the following connections between the BME280 and a Raspberry Pi:\nVin to 3.3V GND to GND SCK to I2C clock SCL (pin 5) SDI to I2C data SDA (pin 3) CS to 3.3V The connection order is documented in the datasheet, and mentions that a connection between the CS pin and 3.3V is required to enable the I2C interface, before the VCC pin is connected to 3.3V. Failure to do this could lead to frustrating debugging\u0026hellip;\nIn the wiring diagram, another brand of board (Sparkfun) is used, which has the I2C and SPI connections on different sides, but to align it with the pictures, the same connections are used as are available on the Adafruit board.\nBME280 I2C wiring\nBME280 I2C wiring\nBME280 I2C wiring\nCheck the I2C Wiring After the wiring has been completed, you can check if the device is connected correctly by checking if the I2C device is detected. Make sure I2C is enabled on the Raspberry Pi, as mentioned before. When everything went OK, you should now see that a device is detected on I2C address 0x77:\n$ i2cdetect -y 1 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- 77 On modern Raspberry Pi OS releases, you can run this command without sudo. The -y disables interactive mode, so it just goes ahead and scans. The 1 specifies the I2C bus.\nWiring for SPI Make the following connections between the BME280 and a Raspberry Pi:\nVin to 3.3V GND to GND SDI to MOSI (BCM10, pin 19) SDO to MISO (BCM9, pin 21) SCK to SCLK (BCM11, pin 23) CS to BCM21 (pin 40) In the wiring diagram, another brand of board (Sparkfun) is used, which has the I2C and SPI connections on different sides, but to align it with the pictures, the same connections are used as are available on the Adafruit board.\nBME280 SPI wiring\nBME280 SPI wiring\nBME280 SPI wiring\nBME280 SPI wiring\nApplication Before proceeding with this example, make sure that you have a Raspberry Pi prepared to execute Java code with JBang as explained here.\nBecause I2C and SPI require different dependencies, imports and settings, two separate example files are provided:\nPi4JTempHumPressI2C.java Pi4JTempHumPressSpi.java Each of these two files contain all settings and code to be compiled and executed with JBang.\nDependencies and Imports First we need to start with an extra line to instruct JBang to handle it as a Java application, and download the dependencies.\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? Then we can define the dependencies and imports.\nDependencies and Imports for I2C //DEPS org.slf4j:slf4j-api:1.7.35 //DEPS org.slf4j:slf4j-simple:1.7.35 //DEPS com.pi4j:pi4j-core:2.3.0 //DEPS com.pi4j:pi4j-plugin-raspberrypi:2.3.0 //DEPS com.pi4j:pi4j-plugin-linuxfs:2.3.0 Then we can define the imports as we would do in any Java file:\nimport com.pi4j.Pi4J; import com.pi4j.util.Console; import com.pi4j.io.i2c.I2C; import com.pi4j.io.i2c.I2CConfig; import com.pi4j.io.i2c.I2CProvider; import java.text.DecimalFormat; Dependencies and Imports for SPI ///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? //DEPS org.slf4j:slf4j-api:1.7.35 //DEPS org.slf4j:slf4j-simple:1.7.35 //DEPS com.pi4j:pi4j-core:2.3.0 //DEPS com.pi4j:pi4j-plugin-raspberrypi:2.3.0 //DEPS com.pi4j:pi4j-plugin-linuxfs:2.3.0 //DEPS com.pi4j:pi4j-plugin-pigpio:2.3.0 Then we can define the imports as we would do in any Java file:\nimport com.pi4j.Pi4J; import com.pi4j.io.gpio.digital.DigitalOutput; import com.pi4j.io.gpio.digital.DigitalState; import com.pi4j.io.spi.*; import com.pi4j.util.Console; import java.text.DecimalFormat; Main Method The main method initializes the sensor, and loops 10 times to the process of resetting the sensor, reading the values, and pauzing.\nMain Method for I2C private static final Console console = new Console(); // Pi4J Logger helper private static final int I2C_BUS = 0x01; private static final int I2C_ADDRESS = 0x77; // When connecting SDO to GND = 0x76 public static void main(String[] args) throws Exception { var pi4j = Pi4J.newAutoContext(); // Initialize I2C console.println(\u0026#34;Initializing the sensor via I2C\u0026#34;); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j) .id(\u0026#34;BME280\u0026#34;) .bus(I2C_BUS) .device(I2C_ADDRESS) .build(); // Read values 10 times try (I2C bme280 = i2CProvider.create(i2cConfig)) { for (int counter = 0; counter \u0026lt; 10; counter++) { console.println(\u0026#34;**************************************\u0026#34;); console.println(\u0026#34;Reading values, loop \u0026#34; + (counter + 1)); resetSensor(bme280); // The sensor needs some time to make the measurement Thread.sleep(300); getMeasurements(bme280); Thread.sleep(5000); } } pi4j.shutdown(); console.println(\u0026#34;**************************************\u0026#34;); console.println(\u0026#34;Finished\u0026#34;); } Main Method for SPI private static final Console console = new Console(); // Pi4J Logger helper private static final String SPI_PROVIDER_NAME = \u0026#34;BME280 SPI Provider\u0026#34;; private static final String SPI_PROVIDER_ID = \u0026#34;BME280-spi\u0026#34;; private static final SpiChipSelect chipSelect = SpiChipSelect.CS_0; private static final SpiBus spiBus = SpiBus.BUS_0; private static final int csPin = 21; // BCM 21 = physical pin 40 private static DigitalOutput csGpio; private static Spi spi; public static void main(String[] args) throws Exception { var pi4j = Pi4J.newAutoContext(); // Initialize SPI console.println(\u0026#34;Initializing the sensor via SPI\u0026#34;); var csGpioConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;CS_pin\u0026#34;) .name(\u0026#34;CS\u0026#34;) .address(csPin) .shutdown(DigitalState.HIGH) .initial(DigitalState.HIGH) .provider(\u0026#34;pigpio-digital-output\u0026#34;); csGpio = pi4j.create(csGpioConfig); var spiConfig = Spi.newConfigBuilder(pi4j) .id(SPI_PROVIDER_ID) .name(SPI_PROVIDER_NAME) .bus(spiBus) .chipSelect(chipSelect) .baud(Spi.DEFAULT_BAUD) .mode(SpiMode.MODE_0) .provider(\u0026#34;pigpio-spi\u0026#34;) .build(); spi = pi4j.create(spiConfig); // Read values 10 times for (int counter = 0; counter \u0026lt; 10; counter++) { console.println(\u0026#34;**************************************\u0026#34;); console.println(\u0026#34;Reading values, loop \u0026#34; + (counter + 1)); resetSensor(); // The sensor needs some time to make the measurement Thread.sleep(300); getMeasurements(); Thread.sleep(5000); } pi4j.shutdown(); console.println(\u0026#34;**************************************\u0026#34;); console.println(\u0026#34;Finished\u0026#34;); } Reset and Readout of the Values The reset and value readout is inspired by the Adafruit CircuitPython library and is fully available in the sources on GitHub. It\u0026rsquo;s a combination of setting and reading registers, with different calculations. For example, for the temperature:\nbyte[] buff = new byte[6]; device.readRegister(BMP280Declares.press_msb, buff); long adc_T = (long) ((buff[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 12) | (long) ((buff[4] \u0026amp; 0xFF) \u0026lt;\u0026lt; 4) | (long) ((buff[5] \u0026amp; 0x0F) \u0026gt;\u0026gt; 4); ... DecimalFormat df = new DecimalFormat(\u0026#34;0.###\u0026#34;); // Temperature device.readRegister(readReg, compVal); long dig_t1 = castOffSignInt(compVal); device.readRegister(BMP280Declares.reg_dig_t2, compVal); int dig_t2 = signedInt(compVal); device.readRegister(BMP280Declares.reg_dig_t3, compVal); int dig_t3 = signedInt(compVal); double var1 = (((double) adc_T) / 16384.0 - ((double) dig_t1) / 1024.0) * ((double) dig_t2); double var2 = ((((double) adc_T) / 131072.0 - ((double) dig_t1) / 8192.0) * (((double) adc_T) / 131072.0 - ((double) dig_t1) / 8192.0)) * ((double) dig_t3); double t_fine = (int) (var1 + var2); double temperature = (var1 + var2) / 5120.0; console.println(\u0026#34;Temperature: \u0026#34; + df.format(temperature) + \u0026#34; °C\u0026#34;); console.println(\u0026#34;Temperature: \u0026#34; + df.format(temperature* 1.8 + 32) + \u0026#34; °F \u0026#34;); Running the Application Because JBang can download the dependencies and compile the code, we just need the Java-file to execute it.\nA side note regarding the humidity value: it turned out its value was lower compared to another device, while the temperature and pressure seemed to be close to expected. This appears to be a known issue. The manufacturer was involved in some hits and admits the chip can fall out of calibration depending storage and soldering conditions. They have a documented multistep process where you store the chip at different temperatures to potentially get it back to the correct humidity readout.\nRunning the I2C Application The I2C example uses the LinuxFS plugin of Pi4J. This means it can be executed without the need to use sudo:\n$ jbang Pi4JTempHumPressI2C.java [jbang] Resolving dependencies... [jbang] org.slf4j:slf4j-api:1.7.35 [jbang] org.slf4j:slf4j-simple:1.7.35 [jbang] com.pi4j:pi4j-core:2.3.0 [jbang] com.pi4j:pi4j-plugin-raspberrypi:2.3.0 [jbang] com.pi4j:pi4j-plugin-pigpio:2.3.0 [jbang] com.pi4j:pi4j-plugin-linuxfs:2.3.0 [jbang] Dependencies resolved [jbang] Building jar... [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - Initializing the sensor via I2C [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Temperature: 21.287 °C [main] INFO com.pi4j.util.Console - Temperature: 70.316 °F [main] INFO com.pi4j.util.Console - Pressure: 100412.769 Pa [main] INFO com.pi4j.util.Console - Pressure: 1.004 bar [main] INFO com.pi4j.util.Console - Pressure: 0.991 atm [main] INFO com.pi4j.util.Console - Humidity: 52.7 % [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Reading values, loop 2 ... [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Finished Running the SPI Application As the PiGpio plugin is used, this example application must be executed with sudo:\n$ sudo `which jbang` Pi4JTempHumPressSpi.java [jbang] Resolving dependencies... [jbang] org.slf4j:slf4j-api:1.7.35 [jbang] org.slf4j:slf4j-simple:1.7.35 [jbang] com.pi4j:pi4j-core:2.3.0 [jbang] com.pi4j:pi4j-plugin-raspberrypi:2.3.0 [jbang] com.pi4j:pi4j-plugin-pigpio:2.3.0 [jbang] com.pi4j:pi4j-plugin-linuxfs:2.3.0 [jbang] com.pi4j:pi4j-plugin-pigpio:2.3.0 [jbang] Dependencies resolved [jbang] Building jar... [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - Initializing the sensor via SPI [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Reading values, loop 1 [main] INFO com.pi4j.util.Console - Temperature: 21.865 °C [main] INFO com.pi4j.util.Console - Temperature: 71.356 °F [main] INFO com.pi4j.util.Console - Pressure: 100419.804 Pa [main] INFO com.pi4j.util.Console - Pressure: 1.004 bar [main] INFO com.pi4j.util.Console - Pressure: 0.991 atm [main] INFO com.pi4j.util.Console - Humidity: 49.74 % [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Reading values, loop 2 ... [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Finished Conclusion Once again, JBang proves to be the perfect companion to experiment with Pi4J and an electronics component!\nRead More The following sources have been used for this example:\nPi4J_V2-TemperatureSensor example code by Tom Aarts Bosch BMP280 Data Sheet Bosch BME280 Data Sheet Bosch example code on GitHub Product page: \u0026ldquo;Adafruit BME280 I2C or SPI Temperature Humidity Pressure Sensor - STEMMA QT\u0026rdquo; Tutorial with Arduino code: \u0026ldquo;Adafruit BME280 Humidity + Barometric Pressure + Temperature Sensor Breakout\u0026rdquo; Adafruit_CircuitPython_BME280 library source code "},{"uri":"https://pi4j.com/documentation/building/","title":"Building and running","tags":[],"description":"","content":"When you create your application with and IDE on the Raspberry Pi itself (e.g. with Visual Studio Code), you can simply run the application. But of course, you want to build and package your project to easily deploy it on one or more Raspberry Pi\u0026rsquo;s.\nThere are different possibilities:\nBuilding with javac Build as a FAT JAR with Maven Build Java modules with Maven Build Java modules with Gradle Running Pi4J with JBang "},{"uri":"https://pi4j.com/documentation/building/javac/","title":"Building with javac","tags":["Javac"],"description":"","content":"You can build a Pi4J project using only java and javac.\nWiring No wiring is needed for this minimal example as it only demonstrates how to create a minimal application which initializes Pi4J.\nJava release Any Java release over 21 is enough, check it with this command:\n$ java -version openjdk version \u0026#34;21.0.1\u0026#34; 2023-10-17 LTS OpenJDK Runtime Environment Zulu21.30+15-CA (build 21.0.1+12-LTS) OpenJDK 64-Bit Server VM Zulu21.30+15-CA (build 21.0.1+12-LTS, mixed mode, sharing) PI4J jar files You will need to download the Pi4J distribution from the Maven repository:\npi4j-distribution-2.1.1.zip\nExpand the file:\nunzip pi4j-distribution-2.1.1.zip\nAdd the lib directory to CLASSPATH by added this line to your .bashrc file:\nexport CLASSPATH=$CLASSPATH:~/pi4j-2.1.1/lib/*\nMinimal Java example file Use your preferred editor to create this GettingStartedExample.java file:\nimport com.pi4j.Pi4J; import com.pi4j.io.gpio.digital.DigitalOutput; import com.pi4j.platform.Platform; import com.pi4j.platform.Platforms; import com.pi4j.provider.Providers; import com.pi4j.registry.Registry; import com.pi4j.util.Console; public class GettingStartedExample { public static void main(String[] args) throws Exception { final var console = new Console(); console.title(\u0026#34;\u0026lt;-- The Pi4J Project --\u0026gt;\u0026#34;, \u0026#34;Getting Started Example\u0026#34;); var pi4j = Pi4J.newAutoContext(); Platforms platforms = pi4j.platforms(); console.box(\u0026#34;Pi4J PLATFORMS\u0026#34;); platforms.describe().print(System.out); console.println(); Platform platform = pi4j.platform(); console.box(\u0026#34;Pi4J DEFAULT PLATFORM\u0026#34;); platform.describe().print(System.out); console.println(); Providers providers = pi4j.providers(); console.box(\u0026#34;Pi4J PROVIDERS\u0026#34;); providers.describe().print(System.out); console.println(); Registry registry = pi4j.registry(); DigitalOutput output = pi4j.dout().create(1, \u0026#34;my-digital-output-1\u0026#34;); console.box(\u0026#34;Pi4J REGISTRY\u0026#34;); registry.describe().print(System.out); console.println(); pi4j.shutdown(); } } Compile the example javac GettingStartedExample.java\nExecute the example java GettingStartedExample\nIf everything is OK the output must be something similar to this, depending on your configuration:\n[main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - \u0026lt;-- The Pi4J Project --\u0026gt; [main] INFO com.pi4j.util.Console - Getting Started Example [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PLATFORMS | [main] INFO com.pi4j.util.Console - -------------------- PLATFORMS: [1] \u0026#34;Pi4J Runtime Platforms\u0026#34; \u0026lt;com.pi4j.platform.impl.DefaultPlatforms\u0026gt; ??PLATFORM: \u0026#34;RaspberryPi Platform\u0026#34; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - | Pi4J DEFAULT PLATFORM | [main] INFO com.pi4j.util.Console - --------------------------- PLATFORM: \u0026#34;RaspberryPi Platform\u0026#34; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PROVIDERS | [main] INFO com.pi4j.util.Console - -------------------- PROVIDERS: [12] \u0026#34;I/O Providers\u0026#34; \u0026lt;com.pi4j.provider.impl.DefaultProviders\u0026gt; ??DIGITAL_INPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalInputProvider\u0026gt; ? ??PROVIDER: \u0026#34;RaspberryPi Digital Input (GPIO) Provider\u0026#34; {raspberrypi-digital-input} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl} ? ??PROVIDER: \u0026#34;PiGpio Digital Input (GPIO) Provider\u0026#34; {pigpio-digital-input} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl} ??SERIAL: [2] \u0026lt;com.pi4j.io.serial.SerialProvider\u0026gt; ? ??PROVIDER: \u0026#34;RaspberryPi Serial Provider\u0026#34; {raspberrypi-serial} \u0026lt;com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl} ? ??PROVIDER: \u0026#34;PiGpio Serial Provider\u0026#34; {pigpio-serial} \u0026lt;com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl} ??PWM: [2] \u0026lt;com.pi4j.io.pwm.PwmProvider\u0026gt; ? ??PROVIDER: \u0026#34;PiGpio PWM Provider\u0026#34; {pigpio-pwm} \u0026lt;com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl} ? ??PROVIDER: \u0026#34;RaspberryPi PWM Provider\u0026#34; {raspberrypi-pwm} \u0026lt;com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl} ??I2C: [2] \u0026lt;com.pi4j.io.i2c.I2CProvider\u0026gt; ? ??PROVIDER: \u0026#34;PiGpio I2C Provider\u0026#34; {pigpio-i2c} \u0026lt;com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl} ? ??PROVIDER: \u0026#34;RaspberryPi I2C Provider\u0026#34; {raspberrypi-i2c} \u0026lt;com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl} ??ANALOG_OUTPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogOutputProvider\u0026gt; ??SPI: [2] \u0026lt;com.pi4j.io.spi.SpiProvider\u0026gt; ? ??PROVIDER: \u0026#34;PiGpio SPI Provider\u0026#34; {pigpio-spi} \u0026lt;com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl} ? ??PROVIDER: \u0026#34;RaspberryPi SPI Provider\u0026#34; {raspberrypi-spi} \u0026lt;com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl} ??DIGITAL_OUTPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalOutputProvider\u0026gt; ? ??PROVIDER: \u0026#34;RaspberryPi Digital Output (GPIO) Provider\u0026#34; {raspberrypi-digital-output} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl} ? ??PROVIDER: \u0026#34;PiGpio Digital Output (GPIO) Provider\u0026#34; {pigpio-digital-output} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl} ??ANALOG_INPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogInputProvider\u0026gt; [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ------------------- [main] INFO com.pi4j.util.Console - | Pi4J REGISTRY | [main] INFO com.pi4j.util.Console - ------------------- REGISTRY: [1] \u0026#34;I/O Registered Instances\u0026#34; \u0026lt;com.pi4j.registry.impl.DefaultRegistry\u0026gt; ??IO: \u0026#34;DOUT-1\u0026#34; {my-digital-output-1} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutput\u0026gt; {DOUT-1} [main] INFO com.pi4j.util.Console - Thanks to Manuel de Vega Barreiro for this contribution.\n"},{"uri":"https://pi4j.com/documentation/building/fat-jar/","title":"Build as a FAT JAR with Maven","tags":["FatJAR"],"description":"","content":" EXAMPLE PROJECT: https://github.com/Pi4J/pi4j-example-fatjar\nAbout FAT JARs With Pi4J V1 you can create a so-called FAT JAR, which packages all the dependencies into one jar-file. That way it is very easy to build your project on one computer and distribute your application as a single file to one or more clients.\nBecause of the modular approach and how Pi4J V2+ loads it dependencies at runtime, this approach can be achieved by using the maven-shade-plugin.\nExample FAT JAR project Check the example project (link on top of this page) for the full README, pom.xml and sources.\nMaven plugins Three plugins are used in pom.xml to create the FAT JAR:\n\u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;pi4j-example-fatjar\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- https://maven.apache.org/plugins/maven-compiler-plugin/ The Compiler Plugin is used to compile the sources of your project. --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-compiler-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;release\u0026gt;${java.version}\u0026lt;/release\u0026gt; \u0026lt;showDeprecation\u0026gt;true\u0026lt;/showDeprecation\u0026gt; \u0026lt;showWarnings\u0026gt;true\u0026lt;/showWarnings\u0026gt; \u0026lt;verbose\u0026gt;false\u0026lt;/verbose\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- https://maven.apache.org/plugins/maven-jar-plugin/ This plugin provides the capability to build (executable) jars and is used here to set the mainClass which will start the application. --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-jar-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;${main.class}\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- https://maven.apache.org/plugins/maven-shade-plugin/ This plugin provides the capability to package the artifact in an uber-jar, including its dependencies and to shade - i.e. rename - the packages of some of the dependencies. The transformer will combine the files in the META-INF.services directories of multiple Pi4J plugins with the same package name into one file. --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-shade-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;transformers\u0026gt; \u0026lt;transformer implementation=\u0026#34;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\u0026#34;/\u0026gt; \u0026lt;/transformers\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;shade\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; By using maven-shade-plugin the correct META-INF.services files are generated.\nAs a jar-file is actually a zip-file, we can easily check the contents of the FAT JAR after it has been created with mvn package:\ndirectories com lib META-INF org files LICENSE.txt NOTICE.txt README.md Loading of the Pi4J modules Pi4J V2+ uses ServiceLoader to detect which modules are available to communicate with the GPIOs. This allows to very dynamically extend the possibilities of the framework.\nCode extract from pi4j-core/src/\u0026hellip;/runtime/impl/DefaultRuntime.java:\n// detect available Pi4J Plugins by scanning the classpath looking for plugin instances var plugins = ServiceLoader.load(Plugin.class); Thanks to the maven-shade-plugin, each Pi4J plugin that is part of the project, is included in META-INF/services/com.pi4j.extension.Plugin:\ncom.pi4j.plugin.raspberrypi.RaspberryPiPlugin com.pi4j.plugin.pigpio.PiGpioPlugin When running this application we can indeed see the loaded platform and provider plugins in the logs:\n[main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - | Pi4J DEFAULT PLATFORM | [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - PLATFORM: \u0026#34;RaspberryPi Platform\u0026#34; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PROVIDERS | [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - PROVIDERS: [12] \u0026#34;I/O Providers\u0026#34; \u0026lt;com.pi4j.provider.impl.DefaultProviders\u0026gt; ├─SPI: [2] \u0026lt;com.pi4j.io.spi.SpiProvider\u0026gt; │ ├─PROVIDER: \u0026#34;PiGpio SPI Provider\u0026#34; {pigpio-spi} \u0026lt;com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl} │ └─PROVIDER: \u0026#34;RaspberryPi SPI Provider\u0026#34; {raspberrypi-spi} \u0026lt;com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl} ├─ANALOG_INPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogInputProvider\u0026gt; ├─SERIAL: [2] \u0026lt;com.pi4j.io.serial.SerialProvider\u0026gt; │ ├─PROVIDER: \u0026#34;PiGpio Serial Provider\u0026#34; {pigpio-serial} \u0026lt;com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl} │ └─PROVIDER: \u0026#34;RaspberryPi Serial Provider\u0026#34; {raspberrypi-serial} \u0026lt;com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl} ├─DIGITAL_INPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalInputProvider\u0026gt; │ ├─PROVIDER: \u0026#34;RaspberryPi Digital Input (GPIO) Provider\u0026#34; {raspberrypi-digital-input} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl} │ └─PROVIDER: \u0026#34;PiGpio Digital Input (GPIO) Provider\u0026#34; {pigpio-digital-input} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl} ├─I2C: [2] \u0026lt;com.pi4j.io.i2c.I2CProvider\u0026gt; │ ├─PROVIDER: \u0026#34;RaspberryPi I2C Provider\u0026#34; {raspberrypi-i2c} \u0026lt;com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl} │ └─PROVIDER: \u0026#34;PiGpio I2C Provider\u0026#34; {pigpio-i2c} \u0026lt;com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl} ├─ANALOG_OUTPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogOutputProvider\u0026gt; ├─DIGITAL_OUTPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalOutputProvider\u0026gt; │ ├─PROVIDER: \u0026#34;RaspberryPi Digital Output (GPIO) Provider\u0026#34; {raspberrypi-digital-output} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl} │ └─PROVIDER: \u0026#34;PiGpio Digital Output (GPIO) Provider\u0026#34; {pigpio-digital-output} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl} └─PWM: [2] \u0026lt;com.pi4j.io.pwm.PwmProvider\u0026gt; ├─PROVIDER: \u0026#34;RaspberryPi PWM Provider\u0026#34; {raspberrypi-pwm} \u0026lt;com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl} └─PROVIDER: \u0026#34;PiGpio PWM Provider\u0026#34; {pigpio-pwm} \u0026lt;com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl} [main] INFO com.pi4j.util.Console - "},{"uri":"https://pi4j.com/documentation/building/modules-maven/","title":"Build Java modules with Maven","tags":["Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\nBecause the Pi4J V2+ project follows the modular approach of Java, the functionality of the framework has been split into different modules, each with their own responsibility.\nThe easiest way to start a new project, is to copy one of the example projects which include a full Maven pom.xml-file with all the required steps and configurations to build the project with all its modules into the target/distribution directory.\nTake for instance a look at the \u0026ldquo;Minimal example application\u0026rdquo;.\nBuild your project with:\n$ mvn clean package When finished, you will find the generated package and required Java-modules and can start your application with the provided run.sh script:\n$ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 364456 Jun 19 10:04 pi4j-core-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 7243 Jun 19 10:04 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 142461 Jun 19 10:04 pi4j-library-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 37302 Jun 19 10:04 pi4j-plugin-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 26917 Jun 19 10:04 pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run.sh -rw-r--r-- 1 pi pi 52173 Jun 19 10:04 slf4j-api-2.0.0-alpha0.jar -rw-r--r-- 1 pi pi 15372 Jun 19 10:04 slf4j-simple-2.0.0-alpha0.jar $ sudo ./run.sh "},{"uri":"https://pi4j.com/documentation/building/modules-gradle/","title":"Build Java modules with Gradle","tags":["Gradle"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\nThe Pi4J project itself uses Maven and most example projects also use this build tool. But if you prefer to use Gradle, you can start with a copy of the \u0026ldquo;Minimal example application\u0026rdquo; which includes all the required files to build with Gradle.\nUse Gradle version 6.6 (or later) and Java 21 OpenJDK (or later). The Gradle wrapper is used as described on docs.gradle.org. The Gradle configuration file build.gradle-file is included in the sources.\nBuild with Gradle On Linux:\n./gradlew build\nOn Windows:\ngradlew.bat build\nBuild result Once the build is complete and was successful, you can find the compiled build (Gradle) folder. Specifically all dependency modules (JARs) and a simple run.sh bash script will be located in the build/distribution (Gradle) folder.\nThese are all the required files needed to distribute (copy) to your Raspberry Pi to run this project. If you are using the native bindings running locally on the Raspberry Pi, then you make have to run the program using sudo to gain the necessary access permissions to the hardware I/O.\nThis is the list of files created by the build process of this example application:\npi4j-core pi4j-example-minimal pi4j-library-pigpio pi4j-plugin-pigpio pi4j-plugin-raspberrypi slf4j-api slf4j-simple run.sh \u0026ndash;\u0026gt; this is the actual start file which will run pi4j-example-minimal Run on Raspberry Pi Make the run script executable and start it like this:\n$ chmod +x run.sh $ sudo ./run.sh "},{"uri":"https://pi4j.com/documentation/building/jbang/","title":"Running Pi4J with JBang","tags":["JBang"],"description":"","content":"JBang allows you to execute Java code with dependencies as a single file without the need for a full Maven or Gradle project. You also don\u0026rsquo;t need to compile your code. So it\u0026rsquo;s a very easy way to get started with Java and Pi4J.\nMultiple examples and more information is available in the section \u0026ldquo;Example Implementations \u0026gt; JBang Examples\u0026rdquo;.\n"},{"uri":"https://pi4j.com/examples/jbang/pixelblaze_output_expander/","title":"Pixelblaze Output Expander","tags":["JBang","Pixelblaze","LED Strip"],"description":"","content":" GITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; PixelblazeOutputExpander.java\nOne of the most \u0026ldquo;fancy\u0026rdquo; electronic components is definitely a LED strip. It\u0026rsquo;s really cool to control a long strip of lights with only a few lines of code\u0026hellip; But, there is a problem. The timing of the signals is crucial to reliably control these strips. Both Python and Java on a Raspberry Pi can struggle with these timings as they are running on Linux, a non-real-time operating system. So pauses in the garbage collection of the Java virtual machine, or any glitch in the operating system can cause unexpected effects on the LED strips. That\u0026rsquo;s why in most projects, a microcontroller (Arduino, Raspberry Pi Pico, ESP32,\u0026hellip;) is used to drive the LED strip.\nFull LED strip code walkthrough, and additional info in this live session with with Robert (aka Eitch) and Frank:\nIntro This example is using such approach with the Pixelblaze Output Expander (PBOE). This product was initially intended to connect more LED strips to the Pixelblaze V3 Standard - WiFi LED Controller and Pixelblaze V3 Pico - Tiny WiFi LED Controller. But because the expander is controlled through a serial connection, we can also use it with a Raspberry Pi.\nYou can buy this component here:\nDirectly from the creator of the Pixelblaze in the US: ElectroMage. Outside of the US: UK: DialSLV Mouser but doesn\u0026rsquo;t ship to consumers in the EU/UK because it isn’t CE-certified. LED Strips LED Strips Used in the Examples The LED strips used in these examples, contain LEDs of the WS2812B type, which means they have SMD 5050-LEDs with an integrated IC-driver, so they can be addressed separately. A few examples:\nLED strip on Amazon LED matrix on Amazon Many variants on ebay How Data is Handled by LED Strips To control such a LED strip, you need to send it a byte array with RGB (red/green/blue) values. Let\u0026rsquo;s use an example for a strip with three LEDs, on which you want to show:\nFull red (RGB #FF0000) Not full white (RGB #A6A6A6) Full blue (RGB #0000FF) Although you may be used to use the color ordering RGB for e.g. CSS or in drawing applications, LED strips actually use GRB.\nThis means, we need a byte array with 9 values:\nArray index 0 1 2 3 4 5 6 7 8 LED 1 2 3 G, R, B #00 #FF #00 #A6 #A6 #A6 #00 #00 #FF The IC of the first led will take the first 3 values from the byte array and output the remaining part to the second LED:\nArray index 0 1 2 3 4 5 LED 2 3 G, R, B #A6 #A6 #A6 #00 #00 #FF Again, the second LED will take the first 3 values and output the remaining part:\nArray index 0 1 2 LED 3 G, R, B #00 #00 #FF For this system to work correctly, a strict timing of the data signal is needed. Otherwise the IC will handle parts of the data as being a new package, and you\u0026rsquo;ll get unexpected results.\nThis is a timing diagram from a datasheet of WS2812B Intelligent control LED integrated light source:\nTiming of the signals for an LED strip\nWiring To control the PBOE, we actually only need one wire to be connected to the Raspberry Pi (RPi) for the serial data to be sent from RPi to PBOE. But we must not forget one important fact: a LED strip with a lot of LEDs will require more power than the RPi can supply. So we need an external power supply that is dimensioned correctly to provide all the power needed for the strip when all LEDs are at maximum level. As a guideline, 0,1W ~ 0,3W/LED is required per LED. For a strip with 60 LEDs/meter, that means 18W/meter, or a total of 90W for a 5-meter strip. That\u0026rsquo;s almost 20A at 5V!\nUse an external power supply to power LED strips!!! The 5V of the Raspberry Pi is passed straight through from the USB and the current is therefore limited. Here is a good question with clear answers about this topic on StackExchange.\nConnections between RPi, PBOE, and power supply:\nGND PBOE to GND power supply, common with GND of RPi 5V PBOE to external power supply DAT PBOE to BCM14 on Rpi (pin 8 = UART Tx) Connections between PBOE and LED strip:\nDin to PBOE Channel 0, Data 5V to PBOE Channel 0, 5V GND to PBOE Channel 0, GND Full setup of this project\nLED strip with three connections for power, ground, and data\nPixelblaze Output Expander\nConnections on the Raspberry Pi\nConnections on the Pixelblaze Output Expander\nConnections for the LED strip\nEnabling Serial To be able to control the serial link from software, the following steps must be followed:\nIn terminal: sudo raspi-config Go to \u0026ldquo;Interface Options\u0026rdquo; Go to \u0026ldquo;Serial Port\u0026rdquo; Select \u0026ldquo;No\u0026rdquo; for \u0026ldquo;login shell\u0026rdquo; Select \u0026ldquo;Yes\u0026rdquo; for \u0026ldquo;hardware enabled\u0026rdquo; Status of the Pixelblaze Output Expander LEDs Fading / pulsing orange: Has not seen any valid looking data. Solid orange (for a short time): Received expander data. Green LED (for a short time): Received data for its channels and is drawing. Application Before proceeding with this example, make sure that you have a Raspberry Pi prepared to execute Java code with JBang as explained here.\nJeff Vyduna and Ben Hencke of ElectroMage, the creators of Pixelblaze, provided example Java code for this project. The serial data format is documented on GitHub. What the code is doing in short:\nOpen serial communication. Depending on the type of board and the connection you are using (GPIO pin, or other serial connection), this can be a different port. Most probably it will be /dev/ttyS0 (Raspberry Pi 4 or earlier), or /dev/ttyAMA0 (Raspberry Pi 5). Use BaudRate 2000000, this is a hard requirement for the PBOE. Send a byte array of RGB values for each LED. Send a drawAll command to put the values on the LEDs. Repeat as much as you want the two previous steps\u0026hellip; Before the application stops, close the serial port. helper.PixelBlazeOutputExpanderHelper This example project doesn\u0026rsquo;t use the Pi4J serial communication (because it doesn\u0026rsquo;t support this baud rate - at this moment), but instead the com.fazecast:jSerialComm:2.10.2 library. Although we are using JBang and can execute the code with a single file, a separate file is used for the logic to interact with the PBOE, so it can be used in other examples.\nInside PixelBlazeOutputExpanderHelper, an inner class is used to set up the serial communication and provide a write method. This is the actual part of the code that is interacting with the PBOE via the serial port.\nprivate class ExpanderDataWriteAdapter { private SerialPort port = null; private final String portPath; public ExpanderDataWriteAdapter (String portPath) { this.portPath = portPath; openPort(); } private void openPort() { if (port != null) { System.out.println(\u0026#34;Closing \u0026#34; + portPath); port.closePort(); } try { port = null; //set to null in case getCommPort throws, port will remain null. port = SerialPort.getCommPort(this.portPath); port.setBaudRate(2000000); port.setComPortTimeouts(SerialPort.TIMEOUT_NONBLOCKING, 0, 0); port.openPort(0, 8192, 8192); System.out.println(\u0026#34;Opening \u0026#34; + portPath); } catch (Exception e) { System.err.println(\u0026#34;Could not open serial port \u0026#34; + e.getMessage()); } } private void closePort() { if (port != null) { System.out.println(\u0026#34;Closing \u0026#34; + portPath); port.closePort(); } } public void write(byte[] data) { int lastErrorCode = port != null ? port.getLastErrorCode() : 0; boolean isOpen = port != null \u0026amp;\u0026amp; port.isOpen(); if (port == null || !isOpen || lastErrorCode != 0) { System.out.println(\u0026#34;Port was open:\u0026#34; + isOpen + \u0026#34;, last error:\u0026#34; + lastErrorCode); openPort(); } port.writeBytes(data, data.length); } } The remaining part of PixelBlazeOutputExpanderHelper exposes a few methods to write RGB values to the strip, or clear them all, but hides all the \u0026ldquo;internal logic\u0026rdquo; in private methods.\npublic class PixelBlazeOutputExpanderHelper { private static final byte CH_WS2812_DATA = 1; private static final byte CH_DRAW_ALL = 2; private final ExpanderDataWriteAdapter adapter; public PixelBlazeOutputExpanderHelper(String address) { System.out.println(\u0026#34;Initializing serial\u0026#34;); adapter = new ExpanderDataWriteAdapter(address); } public void sendAllOff(int channel, int numberOfLeds) { ... } public void sendColors(int channel, int bytesPerPixel, int rIndex, int gIndex, int bIndex, int wIndex, byte[] pixelData, boolean debug) { ... } public void closePort() { adapter.closePort(); } private void sendDrawAll() { ... } private void writeCrc(CRC32 crc) { ... } private void packInt(byte[] outgoing, int index, int val) { ... } private ByteBuffer initHeaderBuffer(int size, byte channel, byte command) { ByteBuffer buffer = ByteBuffer.allocate(size); buffer.order(ByteOrder.LITTLE_ENDIAN); buffer.put((byte) \u0026#39;U\u0026#39;); buffer.put((byte) \u0026#39;P\u0026#39;); buffer.put((byte) \u0026#39;X\u0026#39;); buffer.put((byte) \u0026#39;L\u0026#39;); buffer.put(channel); buffer.put(command); return buffer; } private class ExpanderDataWriteAdapter { ... } } PixelblazeOutputExpander Thanks to the helper-class, the code inside the actual demo is very small.\nJBang Configuration and Imports As with each JBang example, we need to define the first script line and the dependencies, one in this case, and we need to include the helper-source. Only two imports are needed for this example.\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? //DEPS com.fazecast:jSerialComm:2.10.2 //SOURCES helper/PixelBlazeOutputExpanderHelper.java import helper.PixelBlazeOutputExpanderHelper; import java.util.Random; Initialize the Helper The main method needs to initialize the helper and contains a helper method to send a specific color, one LED at a time, to a strip:\nprivate static PixelBlazeOutputExpanderHelper helper; public static void main(String[] args) throws InterruptedException { // Depending on the type of board and the connection you are using // (GPIO pin, or other serial connection), this can be a different port. // Most probably it will be `/dev/ttyS0` (Raspberry Pi 4 or earlier), // or `/dev/ttyAMA0` (Raspberry Pi 5). helper = new PixelBlazeOutputExpanderHelper(\u0026#34;/dev/ttyS0\u0026#34;); // RGB commands will be added here helper.closePort(); } private static void sendOneByOne(int channel, int numberOfLeds, byte red, byte green, byte blue) throws InterruptedException { System.out.println(\u0026#34;One by one on channel \u0026#34; + channel); for (int i = 0; i \u0026lt; numberOfLeds; i++) { byte[] oneLed = new byte[numberOfLeds * BYTES_PER_PIXEL]; oneLed[i * BYTES_PER_PIXEL] = red; oneLed[(i * BYTES_PER_PIXEL) + 1] = green; oneLed[(i * BYTES_PER_PIXEL) + 2] = blue; helper.sendColors(channel, BYTES_PER_PIXEL, 1, 0, 2, 0, oneLed, false); Thread.sleep(50); } } Controlling the LEDs With all this code in place, we can start sending color data to the LED strip. The idea is to send a byte array containing a value for each color of the LEDs.\nFor instance, to send these colors to the first four LEDs, when using RGB-leds:\n1 Red 2 Green 3 Blue 4 White\nThe byte array will look like this:\nbyte[] pixeldata = new byte[12]; // 3 colors * 4 leds // Red = 0xff0000 byte[0] = (byte) 0xff; byte[1] = (byte) 0x00; byte[2] = (byte) 0x00; // Green = 0x00ff00 byte[3] = (byte) 0x00; byte[4] = (byte) 0xff; byte[5] = (byte) 0x00; // blue = 0x0000ff byte[6] = (byte) 0x00; byte[7] = (byte) 0x00; byte[8] = (byte) 0xff; // White = 0xffffff byte[9] = (byte) 0xff; byte[10] = (byte) 0xff; byte[11] = (byte) 0xff; Number of colors per LED A LED on a strip can contain three inner LEDs for RGB, or four for RGBW. In case of RGBW, you need to adapt the script to define BYTES_PER_PIXEL = 4, and your byte array with the color values needs to include four values per LED.\n// 3 colors per LED, White = 0xffffff byte[0] = (byte) 0xff; byte[1] = (byte) 0xff; byte[2] = (byte) 0xff; // 4 colors per LED, White = 0x000000ff byte[0] = (byte) 0x00; byte[1] = (byte) 0x00; byte[2] = (byte) 0x00; byte[3] = (byte) 0xff; Order of the color values Test the red, green, and blue output to define how the RGB colors are ordered in the PBOE controller and/or LED strip. You can define the relationship between the colors in your byte array with the actual led strip in the sendColors method, with the int rIndex, int gIndex, int bIndex, int wIndex parameters. If you are using RGB-leds and 3 bytes per pixel, the wIndex parameter is ignored.\nSending color values The example code uses multiple byte arrays to send various colors and effects to a strip with 11 LEDs, connected to the channel 0 pins of the PBOE.\nprivate static final int BYTES_PER_PIXEL = 3; private static final int CHANNEL_STRIP_SHORT = 0; private static final int NUMBER_OF_LEDS_STRIP_SHORT = 11; public static void main(String[] args) throws InterruptedException{ helper=new PixelBlazeOutputExpanderHelper(\u0026#34;/dev/ttyS0\u0026#34;); // All off on, short LED strip helper.sendAllOff(CHANNEL_STRIP_SHORT,NUMBER_OF_LEDS_STRIP_SHORT); Thread.sleep(500); // One by one red, short LED strip sendOneByOne(CHANNEL_STRIP_SHORT,NUMBER_OF_LEDS_STRIP_SHORT,(byte)0xff,(byte)0x00,(byte)0x00); // All the same color red, green, blue, short LED strip for(int color=0;color\u0026lt;BYTES_PER_PIXEL; color++){ System.out.println(\u0026#34;All \u0026#34;+(color==0?\u0026#34;red\u0026#34;:(color==1?\u0026#34;green\u0026#34;:\u0026#34;blue\u0026#34;))); byte[]allSame=new byte[NUMBER_OF_LEDS_STRIP_SHORT*BYTES_PER_PIXEL]; for(int i=0;i\u0026lt;NUMBER_OF_LEDS_STRIP_SHORT; i++){ allSame[(BYTES_PER_PIXEL*i)+color]=(byte)0xff; } helper.sendColors(CHANNEL_STRIP_SHORT,BYTES_PER_PIXEL,1,0,2,0,allSame,false); Thread.sleep(1000); } // Fill strip with random colors, short LED strip Random rd=new Random(); for(int i=0;i\u0026lt; 5;i++){ System.out.println(\u0026#34;Random colors \u0026#34;+(i+1)); byte[]random=new byte[NUMBER_OF_LEDS_STRIP_SHORT*BYTES_PER_PIXEL]; rd.nextBytes(random); helper.sendColors(CHANNEL_STRIP_SHORT,BYTES_PER_PIXEL,1,0,2,0,random,false); Thread.sleep(1000); } // Red alert, short LED strip byte[]red=new byte[NUMBER_OF_LEDS_STRIP_SHORT*BYTES_PER_PIXEL]; int i; for(i=0;i\u0026lt;NUMBER_OF_LEDS_STRIP_SHORT; i++){ red[i*BYTES_PER_PIXEL]=(byte)0xff; } for(i=0;i\u0026lt; 5;i++){ System.out.println(\u0026#34;All red\u0026#34;); helper.sendColors(CHANNEL_STRIP_SHORT,BYTES_PER_PIXEL,1,0,2,0,red,false); Thread.sleep(100); helper.sendAllOff(CHANNEL_STRIP_SHORT,NUMBER_OF_LEDS_STRIP_SHORT); Thread.sleep(100); } } The example application also contains demos for a longer strip with 300 LEDs (5 meter) and a 8*32 matrix, connected to the second (index 1) and third channel (index 2).\nprivate static final int CHANNEL_STRIP_LONG = 1; private static final int CHANNEL_MATRIX = 2; private static final int NUMBER_OF_LEDS_STRIP_LONG = 300; private static final int NUMBER_OF_LEDS_MATRIX = 256; // 8*32 // One by one red/green/blue on long strip, 5 meter with 60 LEDs/meter sendOneByOne(CHANNEL_STRIP_LONG, NUMBER_OF_LEDS_STRIP_LONG, (byte) 0xff, (byte) 0x00, (byte) 0x00); sendOneByOne(CHANNEL_STRIP_LONG, NUMBER_OF_LEDS_STRIP_LONG, (byte) 0x00, (byte) 0xff, (byte) 0x00); sendOneByOne(CHANNEL_STRIP_LONG, NUMBER_OF_LEDS_STRIP_LONG, (byte) 0x00, (byte) 0x00, (byte) 0xff); // Flash all red/white on long strip 1, 5 meter with 60 LEDs/meter byte[] fiveMeterRed = new byte[NUMBER_OF_LEDS_STRIP_LONG * BYTES_PER_PIXEL]; byte[] fiveMeterWhite = new byte[NUMBER_OF_LEDS_STRIP_LONG * BYTES_PER_PIXEL]; for (i = 0; i \u0026lt; NUMBER_OF_LEDS_STRIP_LONG; i++) { fiveMeterRed[i*BYTES_PER_PIXEL]= (byte) 0xff; fiveMeterWhite[i*BYTES_PER_PIXEL]= (byte) 0xff; fiveMeterWhite[(i*BYTES_PER_PIXEL) + 1]= (byte) 0xff; fiveMeterWhite[(i*BYTES_PER_PIXEL) + 2]= (byte) 0xff; } for (i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;All RED on LED strip on channel 1\u0026#34;); helper.sendColors(CHANNEL_STRIP_LONG, BYTES_PER_PIXEL, 1, 0, 2, 0, fiveMeterRed, false); Thread.sleep(500); System.out.println(\u0026#34;All RED on LED strip on channel 1\u0026#34;); helper.sendColors(CHANNEL_STRIP_LONG, BYTES_PER_PIXEL, 1, 0, 2, 0, fiveMeterWhite, false); Thread.sleep(500); } // All off, long LED strip helper.sendAllOff(CHANNEL_STRIP_LONG, NUMBER_OF_LEDS_STRIP_LONG); Thread.sleep(100); // All red, 8*32 LED matrix byte[] redMatrix = new byte[NUMBER_OF_LEDS_MATRIX * BYTES_PER_PIXEL]; for (i = 0; i \u0026lt; NUMBER_OF_LEDS_MATRIX; i++) { redMatrix[i*BYTES_PER_PIXEL]= (byte) 0xff; } for (i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;All red on LED matrix on channel 2\u0026#34;); helper.sendColors(CHANNEL_MATRIX, BYTES_PER_PIXEL, 1, 0, 2, 0, redMatrix, false); Thread.sleep(100); helper.sendAllOff(CHANNEL_MATRIX, NUMBER_OF_LEDS_MATRIX); Thread.sleep(100); } Running the Application No sudo is needed for serial communication with the jSerialComm library, so the application can be started with:\n$ jbang PixelblazeOutputExpander.java Initializing serial Opening /dev/ttyS0 All off on channel 0 with 11 All off on channel 1 with 300 All off on channel 2 with 256 One by one on channel 0, will take 2s All red All green All blue Random colors 1 .. All red All off on channel 0 with 11 ... One by one on channel 1, will take 6s ... All red on LED strip on channel 1 All off on channel 1 with 300 All red on LED matrix on channel 2 ... Closing /dev/ttyS0 Conclusion I\u0026rsquo;m still curious to see the reliability of this serial control for LED strips in combination with other loads on the Raspberry Pi, but the Pixelblaze Output Expander is a great way to easily control such strips!\n"},{"uri":"https://pi4j.com/examples/jbang/pixelblaze_output_expander_image/","title":"Controlling a LED Matrix","tags":["JBang","Pixelblaze","LED Strip"],"description":"","content":" GITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; PixelblazeOutputExpanderImageMatrix8x32.java\nA LED strip doesn\u0026rsquo;t only exist as a single strip, the same system is also used in a LED matrix. In this example, we will control such a 8*32 LED matrix.\nFull LED strip code walkthrough, and additional info in this live session with Robert (aka Eitch) and Frank:\nIntro This example is based on the Pixelblaze Output Expander (PBOE) JBang example. Make sure to check out the PBOE example, so you fully understand how to set up and use JBang, and connect and control a LED strip via a PBOE.\nApplication This example uses the same helper.PixelBlazeOutputExpanderHelper to send commands to the PBOE. An additional shared code-file helper.ImageHelper is used to handle images.\nJBang Configuration and Imports As with each JBang example, we need to define the first script line and the dependencies, one in this case, and we need to include the helper-sources. This example also needs some more imports, and we do a static import of the ImageHelper methods, so we can easily use them in the code.\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? //DEPS com.fazecast:jSerialComm:2.10.2 //SOURCES helper/ImageHelper.java //SOURCES helper/PixelBlazeOutputExpanderHelper.java import helper.PixelBlazeOutputExpanderHelper; import java.io.IOException; import java.util.Random; import static helper.ImageHelper.getImageData; import static helper.ImageHelper.imageToMatrix; Enum With Images Within the JBang sample project you can find a data directory. In this directory, a number of test images is available, PNGs with a size of 8 pixels height by 32 pixels width, matching the size of the matrix. By defining them in the code as an enum, we can add extra info, like the duration we want to display them.\nprivate enum TestImage { LINE_1(\u0026#34;image_8_32_line_1.png\u0026#34;, 250), LINE_2(\u0026#34;image_8_32_line_2.png\u0026#34;, 250), LINE_3(\u0026#34;image_8_32_line_3.png\u0026#34;, 250), LINE_4(\u0026#34;image_8_32_line_4.png\u0026#34;, 250), LINE_5(\u0026#34;image_8_32_line_5.png\u0026#34;, 250), LINE_6(\u0026#34;image_8_32_line_6.png\u0026#34;, 250), LINE_7(\u0026#34;image_8_32_line_7.png\u0026#34;, 250), LINE_8(\u0026#34;image_8_32_line_8.png\u0026#34;, 250), RED(\u0026#34;image_8_32_red.png\u0026#34;, 500), GREEN(\u0026#34;image_8_32_green.png\u0026#34;, 500), BLUE(\u0026#34;image_8_32_blue.png\u0026#34;, 500), STRIPES(\u0026#34;image_8_32_stripes.png\u0026#34;, 2000), STRIPES_TEST(\u0026#34;image_8_32_stripes_test.png\u0026#34;, 2000), DUKE(\u0026#34;image_8_32_duke.png\u0026#34;, 2000), RPI(\u0026#34;image_8_32_raspberrypi.png\u0026#34;, 2000); private final String fileName; private final int duration; TestImage(String fileName, int duration) { this.fileName = fileName; this.duration = duration; } public String getFileName() { return fileName; } public int getDuration() { return duration; } } Loading an Image as RGB Byte Array As we need to send a byte array with red, green, blue values to the LED strip, we need a method to load an image file and return each pixel as three values. There are several methods available in Java to achieve this. I used bufferedImage.getRGB(x, y) to be able to validate the color returned from every pixel to make it easy to debug.\nprivate static byte[] getImageData(String imagePath) throws IOException { byte[] imageData = new byte[NUMBER_OF_LEDS * BYTES_PER_PIXEL]; // Open image File imgPath = new File(imagePath); BufferedImage bufferedImage = ImageIO.read(imgPath); // Read color values for each pixel int pixelCounter = 0; for (int y = 0; y \u0026lt; 8; y++) { for (int x = 0; x \u0026lt; 32; x++) { int color = bufferedImage.getRGB(x, y); imageData[pixelCounter * BYTES_PER_PIXEL] = (byte) ((color \u0026amp; 0xff0000) \u0026gt;\u0026gt; 16); // Red imageData[(pixelCounter * BYTES_PER_PIXEL) + 1] = (byte) ((color \u0026amp; 0xff00) \u0026gt;\u0026gt; 8); // Green imageData[(pixelCounter * BYTES_PER_PIXEL) + 2] = (byte) (color \u0026amp; 0xff); // Blue pixelCounter++; } } return imageData; } Detecting the Orientation of the Strip While working on this example, I didn\u0026rsquo;t get the output I was expecting. My assumption was that the LEDs are wired in rows, which would be the easiest way to use them.\nColumn 1 2 3 4 ... 32 Row 1 IN \u0026gt; \u0026gt; OUT, connected to beginning of row 2 Row 2 IN \u0026gt; \u0026gt; OUT, connected to beginning of row 3 Row 3 IN \u0026gt; \u0026gt; OUT, connected to beginning of row 4 ... With the following code, RED is sent to each LED, one by one, from position 0 to the final LED.\n// Check the position of the LEDs, to identify how the LED strip is wired System.out.println(\u0026#34;One by one RED\u0026#34;); for (i = 0; i \u0026lt; NUMBER_OF_LEDS; i++) { byte[] pixelData = new byte[NUMBER_OF_LEDS * BYTES_PER_PIXEL]; pixelData[i * BYTES_PER_PIXEL] = (byte) 0xff; // red helper.sendColors(CHANNEL, BYTES_PER_PIXEL, 1, 0, 2, 0, pixelData, false); Thread.sleep(20); } With this code, I found out the wiring, on the matrix that I use, is actually totally different\n2191\nColumn 1 2 3 4 ... 32 IN OUT IN OUT TO 3 TO 5 \u0026amp;#x2B07; \u0026amp;#x2B06; \u0026amp;#x2B07; \u0026amp;#x2B06; ... Row 1 Row 2 Row 3 ... Row 8 \u0026amp;#x2B07; \u0026amp;#x2B06; \u0026amp;#x2B07; \u0026amp;#x2B06; ... OUT IN OUT IN TO 2 TO 4 As it turns out the order of the LEDs doesn\u0026rsquo;t match the X/Y system of an image, an extra method is needed to \u0026ldquo;flip\u0026rdquo; the X/Y into the actual ordering of the LEDs. Although this method is easy, it took me some iterations to find a correct approach\u0026hellip;\nprivate static byte[] imageToMatrix(byte[] imageData) { byte[] matrixData = new byte[imageData.length]; int indexInImage = 0;; for (int row = 0; row \u0026lt; 8; row++) { for (int column = 0; column \u0026lt; 32; column++) { int indexInMatrix = (column * 8) + (column % 2 == 0 ? row : 7 - row); //System.out.println(\u0026#34;Row : \u0026#34; + row + \u0026#34; / column: \u0026#34; + column + \u0026#34; / index image : \u0026#34; + indexInImage + \u0026#34; / index matrix: \u0026#34; + indexInMatrix); matrixData[indexInMatrix * BYTES_PER_PIXEL] = imageData[indexInImage * BYTES_PER_PIXEL]; matrixData[(indexInMatrix * BYTES_PER_PIXEL) + 1] = imageData[(indexInImage * BYTES_PER_PIXEL) + 1]; matrixData[(indexInMatrix * BYTES_PER_PIXEL) + 2] = imageData[(indexInImage * BYTES_PER_PIXEL) + 2]; indexInImage++; } } return matrixData; } Displaying the Images With the enum and additional methods, we can now very easy display all the images for the duration that is defined in each enum value.\n// Output all defined images for (TestImage testImage : TestImage.values()) { System.out.println(\u0026#34;Image: \u0026#34; + testImage); // Get the bytes from the given image byte[] pixelData = imageToMatrix(getImageData(\u0026#34;data/\u0026#34; + testImage.getFileName())); // Show the image on the LED matrix helper.sendColors(CHANNEL, BYTES_PER_PIXEL, 1, 0, 2, 1, pixelData, false); Thread.sleep(testImage.getDuration()); } Other Effects Some other effects are included in the example which are not using images.\n// All white to test load on power supply System.out.println(\u0026#34;Full RGB\u0026#34;); byte[] allWhite = new byte[NUMBER_OF_LEDS * BYTES_PER_PIXEL]; for (i = 0; i \u0026lt; NUMBER_OF_LEDS * BYTES_PER_PIXEL; i++) { allWhite[i] = (byte) 0xff; } helper.sendColors(CHANNEL, BYTES_PER_PIXEL, 1, 0, 2, 0, allWhite, false); Thread.sleep(5000); // Random colors Random rd = new Random(); for (i = 0; i \u0026lt; 100; i++) { byte[] random = new byte[8 * 32 * BYTES_PER_PIXEL]; rd.nextBytes(random); helper.sendColors(CHANNEL, BYTES_PER_PIXEL, 1, 0, 2, 0, random, false); Thread.sleep(50); } Running the Application No sudo is needed for serial communication with the jSerialComm library, so the application can be started with:\n$ jbang PixelblazeOutputExpanderImageMatrix8x32.java [jbang] Building jar for PixelblazeOutputExpanderImageMatrix8x32.java... Initializing serial Opening /dev/ttyS0 All off on channel 2 with 256 One by one RED Full RGB Image data/image_8_32_line_1.png loaded with W 32 and H 8 Image data/image_8_32_line_2.png loaded with W 32 and H 8 Image data/image_8_32_line_3.png loaded with W 32 and H 8 Image data/image_8_32_line_4.png loaded with W 32 and H 8 Image data/image_8_32_line_5.png loaded with W 32 and H 8 Image data/image_8_32_line_6.png loaded with W 32 and H 8 Image data/image_8_32_line_7.png loaded with W 32 and H 8 Image data/image_8_32_line_8.png loaded with W 32 and H 8 Image data/image_8_32_red.png loaded with W 32 and H 8 Image data/image_8_32_green.png loaded with W 32 and H 8 Image data/image_8_32_blue.png loaded with W 32 and H 8 Image data/image_8_32_stripes.png loaded with W 32 and H 8 Image data/image_8_32_stripes_test.png loaded with W 32 and H 8 Image data/image_8_32_duke.png loaded with W 32 and H 8 Image data/image_8_32_raspberrypi.png loaded with W 32 and H 8 All off on channel 2 with 256 Closing /dev/ttyS0 Controlling an 8x8 matrix Within the GitHub project, you can also find an example to send images to an 8x8 matrix.\nGITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; PixelblazeOutputExpanderImageMatrix8x8.java\nConclusion By reusing the existing Pixelblaze Output Expander helper code, we are able to control a LED matrix and experiment with images.\n"},{"uri":"https://pi4j.com/examples/jbang/pixelblaze_output_expander_javafx/","title":"LED strip with a JavaFX UI","tags":["JBang","Pixelblaze","LED Strip","JavaFX","SDKMAN"],"description":"","content":" GITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; PixelblazeOutputExpanderJavaFX.java\nWe already know how to control a LED strip, so let\u0026rsquo;s add a JavaFX User Interface to control the colors on each of the LEDs on the strip.\nDemo of the JavaFX UI\nFull LED strip code walkthrough, and additional info in this live session with Robert (aka Eitch) and Frank:\nIntro This example is based on the Pixelblaze Output Expander (PBOE) JBang example. Make sure to check out the PBOE example, so you fully understand how to set up and use JBang, and connect and control a LED strip via a PBOE.\nApplication This example uses the same helper.PixelBlazeOutputExpanderHelper to send commands to the PBOE.\nJBang Configuration and Imports As with each JBang example, we need to define the first script line and the dependencies, and we need to include the helper-source. This example needs some more dependencies and imports for JavaFX.\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? //DEPS com.fazecast:jSerialComm:2.10.2 //DEPS org.openjfx:javafx-controls:20.0.2 //DEPS org.openjfx:javafx-graphics:20.0.2:${os.detected.jfxname} //SOURCES helper/PixelBlazeOutputExpanderHelper.java import helper.PixelBlazeOutputExpanderHelper; import javafx.application.Application; import javafx.geometry.Pos; import javafx.scene.control.Button; import javafx.scene.control.ColorPicker; import javafx.scene.control.Label; import javafx.scene.paint.Color; import javafx.scene.Scene; import javafx.scene.layout.StackPane; import javafx.scene.layout.VBox; import javafx.stage.Stage; import java.util.ArrayList; import java.util.List; JavaFX Code Please check the full example code, as we don\u0026rsquo;t explain how to use RGB values, but only the JavaFX part. We want a user-interface that shows a color picker to control the LEDs one-by-one, a color picker to put the same color on all LEDs, and a clear button.\nprivate static final int BYTES_PER_PIXEL = 3; private static final int CHANNEL = 0; private static final int NUMBER_OF_LEDS = 11; private List\u0026lt;ColorPicker\u0026gt; colorPickers = new ArrayList\u0026lt;\u0026gt;(); private PixelBlazeOutputExpanderHelper helper; @Override public void start(Stage stage) { // Depending on the type of board and the connection you are using // (GPIO pin, or other serial connection), this can be a different port. // Most probably it will be `/dev/ttyS0` (Raspberry Pi 4 or earlier), // or `/dev/ttyAMA0` (Raspberry Pi 5). helper = new PixelBlazeOutputExpanderHelper(\u0026#34;/dev/ttyS0\u0026#34;); VBox holder = new VBox(); holder.setFillWidth(true); holder.setAlignment(Pos.CENTER); holder.setSpacing(5); // Color picker to control the LEDs one-by-one holder.getChildren().add(new Label(\u0026#34;One by one\u0026#34;)); for (int led = 0; led \u0026lt; NUMBER_OF_LEDS; led++) { ColorPicker colorPicker = new ColorPicker(); colorPicker.setPrefWidth(200); colorPicker.setOnAction(e -\u0026gt; sendColors()); holder.getChildren().add(colorPicker); colorPickers.add(colorPicker); } // Color picker to put the same color on all LEDs holder.getChildren().add(new Label(\u0026#34;All same color\u0026#34;)); ColorPicker colorPicker = new ColorPicker(); colorPicker.setPrefWidth(200); colorPicker.setOnAction(e -\u0026gt; sendAll(colorPicker.getValue())); holder.getChildren().add(colorPicker); // Clear button holder.getChildren().add(new Label(\u0026#34;Clear\u0026#34;)); Button clearAll = new Button(\u0026#34;All\u0026#34;); clearAll.setPrefWidth(200); clearAll.setOnAction(e -\u0026gt; helper.sendAllOff(CHANNEL, NUMBER_OF_LEDS)); holder.getChildren().add(clearAll); Scene scene = new Scene(new StackPane(holder), 400, 700); stage.setTitle(\u0026#34;Pixelblaze Test\u0026#34;); stage.setScene(scene); stage.show(); } private void sendColors() { byte[] colors = new byte[NUMBER_OF_LEDS * BYTES_PER_PIXEL]; for (int led = 0; led \u0026lt; NUMBER_OF_LEDS; led++) { Color color = colorPickers.get(led).getValue(); colors[BYTES_PER_PIXEL * led] = (byte) (255 * color.getRed()); colors[(BYTES_PER_PIXEL * led) + 1] = (byte) (255 * color.getGreen()); colors[(BYTES_PER_PIXEL * led) + 2] = (byte) (255 * color.getBlue()); } helper.sendColors(CHANNEL, BYTES_PER_PIXEL, 1, 0, 2, 0, colors, true); } private void sendAll(Color color) { byte[] colors = new byte[NUMBER_OF_LEDS * 3]; for (int led = 0; led \u0026lt; NUMBER_OF_LEDS; led++) { colors[BYTES_PER_PIXEL * led] = (byte) (255 * color.getRed()); colors[(BYTES_PER_PIXEL * led) + 1] = (byte) (255 * color.getGreen()); colors[(BYTES_PER_PIXEL * led) + 2] = (byte) (255 * color.getBlue()); } helper.sendColors(CHANNEL, BYTES_PER_PIXEL, 1, 0, 2, 0, colors, true); } Running the Application To run this example, we need a runtime that has JavaFX included. At this moment, only a few are available. In case you are using a 64bit Raspberry Pi 0S, you can use SDKMAN to install and use such a runtime:\n$ curl -s \u0026#34;https://get.sdkman.io\u0026#34; | bash $ source \u0026#34;$HOME/.sdkman/bin/sdkman-init.sh\u0026#34; $ sdk install java 22.0.1.fx-zulu # Or if you already ran the install $ sdk use java 22.0.1.fx-zulu Using java version 22.0.1.fx-zulu in this shell. $ java -version openjdk version \u0026#34;22.0.1\u0026#34; 2024-04-16 OpenJDK Runtime Environment Zulu22.30+13-CA (build 22.0.1+8) OpenJDK 64-Bit Server VM Zulu22.30+13-CA (build 22.0.1+8, mixed mode, sharing) No sudo is needed for serial communication with the jSerialComm library, so the application can be started with:\n$ jbang PixelblazeOutputExpanderJavaFX.java [jbang] Building jar for PixelblazeOutputExpanderJavaFX.java... Initializing serial Opening /dev/ttyS0 Sending colors on channel 0 ff ff ff ff 00 00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff Sending colors on channel 0 ff ff ff ff 00 00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00 ff ff ff ff ff ff ff ff ff Conclusion JavaFX is an easy way to create a user interface and thanks to the reuse of the existing Pixelblaze Output Expander helper code, this example provides a lot of functionality with minimal code.\n"},{"uri":"https://pi4j.com/documentation/io-examples/digital-output/","title":"Digital Output (GPIO)","tags":["Digital Output"],"description":"","content":"A digital output translates a false/true (or 0/1) to an output value of 0V or 3.3V. This means you can control any type of device which works with max 3.3V to off or on. The most basic example is a LED. Always check which is the correct input voltage for your device! For a LED you will need to put a resistor with the correct value between the GPIO and the LED, you can find a lot of examples and calculators online, for example on circuitdigest.com/calculators/led-resistor-calculator.\nThe following example shows the minimal code to configure the DIGITAL_OUTPUT_PIN pin number as an output pin and change the state with different methods which are provided by the Pi4J library. This implementation will operate with a Pi4j default Provider. The default Provider is not a concrete implementation and therefore running this program will not access the GPIO Hardware and the Hardware state will not be modified. To access the Hardware a concrete Provider is required. See Providers\nExamples of the various methods and approaches which can be used to provision the I/O needs are available in the examples project.\n// Initialize Pi4J with an auto context // An auto context includes AUTO-DETECT BINDINGS enabled // which will load all detected Pi4J extension libraries // (Platforms and Providers) in the class path var pi4j = Pi4J.newAutoContext(); // create a digital output instance using the default digital output provider var output = pi4j.dout().create(DIGITAL_OUTPUT_PIN); output.config().shutdownState(DigitalState.HIGH); // setup a digital output listener to listen for any state changes on the digital output output.addListener(System.out::println); // lets invoke some changes on the digital output output.state(DigitalState.HIGH) .state(DigitalState.LOW) .state(DigitalState.HIGH) .state(DigitalState.LOW); // lets toggle the digital output state a few times output.toggle() .toggle() .toggle(); // another friendly method of setting output state output.high() .low(); // lets read the digital output state System.out.print(\u0026#34;CURRENT DIGITAL OUTPUT [\u0026#34; + output + \u0026#34;] STATE IS [\u0026#34;); System.out.println(output.state() + \u0026#34;]\u0026#34;); // pulse to HIGH state for 3 seconds System.out.println(\u0026#34;PULSING OUTPUT STATE TO HIGH FOR 3 SECONDS\u0026#34;); output.pulse(3, TimeUnit.SECONDS, DigitalState.HIGH); System.out.println(\u0026#34;PULSING OUTPUT STATE COMPLETE\u0026#34;); // shutdown Pi4J pi4j.shutdown(); "},{"uri":"https://pi4j.com/examples/components/simplebutton/","title":"Simple Button","tags":["Simple Button","Button"],"description":"","content":"Description The SimpleButton is a template class, that you can use in your own Java-project.\nThe Template Class gives you the option to check the state of the button, and to create simple events if the button is pressed, depressed or while it is being pressed.\nLayout Simple Button Breadboard\nBig Button\nCode A simple example on how to use the Button-Class from the Hardware-Catalog:\n// Initialize the button component final var button = new SimpleButton(pi4j, PIN.D26, Boolean.FALSE); // Register event handlers to print a message when pressed (onDown) and depressed (onUp) button.onDown (() -\u0026gt; System.out.println(\u0026#34;Button pressed\u0026#34;)); button.whilePressed(() -\u0026gt; System.out.println(\u0026#34;Still pressing\u0026#34;), Duration.ofSeconds(1)); button.onUp (() -\u0026gt; System.out.println(\u0026#34;Stopped pressing\u0026#34;)); // Wait for 15 seconds while handling events before exiting System.out.println(\u0026#34;Press the button to see it in action!\u0026#34;); delay(Duration.ofSeconds(15)); // Unregister all event handlers to exit this application in a clean way button.reset(); Further project ideas An application, which includes a button. if the button is pressed, the app will order you a crate of beer from your favorite store. An application, which includes a buzzer and a button. If the button is pressed, the buzzer beeps. "},{"uri":"https://pi4j.com/examples/components/simpleled/","title":"Simple LED","tags":["Simple LED","LED"],"description":"","content":"Description The SimpleLed is a template class, that you can use in your own Java-project.\nThe template Class gives you the option to switch off, switch on or toggle the state of the LED.\nLayout Simple Led Breadboard\nCode A simple example on how to use the LED-Class from the Hardware-Catalog:\nSystem.out.println(\u0026#34;Simple LED demo started ...\u0026#34;); // Create a new SimpleLED component SimpleLed led = new SimpleLed(pi4j, PIN.D26); // Turn on the LED to have a defined state System.out.println(\u0026#34;Turn on LED.\u0026#34;); led.on(); delay(Duration.ofSeconds(1)); // Make a flashing light by toggling the LED every second for (int i = 0; i \u0026lt; 10; i++) { System.out.println(\u0026#34;Current LED state is :\u0026#34; + led.toggle() +\u0026#34;.\u0026#34;); delay(Duration.ofSeconds(1)); } // That\u0026#39;s it so reset all led.reset(); Further project ideas Use an infrared LED to establish communication with an infrared receiver. Use several red LEDs to recreate the running lights of KITT, the car from Knight Rider. "},{"uri":"https://pi4j.com/examples/components/ads1115/","title":"AD Converter ADS1115","tags":["ADS1115"],"description":"","content":"Description The Analog Digital Converter Ads1115 is a template class, that you can use in your own Java-project. The ADS1115 device is a precision, low-power, 16-bit, I2C-compatible, analog-to-digital converter (ADCs). The ADS1115 device incorporates a low-drift voltage reference and an oscillator as well as a programmable gain amplifier (PGA) and a digital comparator. These features, along with a wide operating supply range, makes the ADS1115 well suited for power- and space-constrained, sensor measurement applications.\nThe ADS1115 performs conversions at data rates up to 860 samples per second (SPS). The PGA offers input ranges from ±256 mV to ±6.144 V, allowing precise large- and small-signal measurements. The ADS1115 features an input multiplexer (MUX) that allows two differential or four single-ended input measurements. Use the digital comparator for under- and overvoltage detection.\nThe ADS1115 operates in either continuous-conversion mode or single-shot mode. The device is automatically powered down after one conversion in single-shot mode. Therefore, power consumption is significantly reduced during idle periods.\nThe Template Class gives you the possibility of a single shot recording, or to measure it continuously.\nLayout ADS1115 Breadboard\nADS1115-Front\nADS1115-Back\nCode A simple example on how to use the AD converter from the Hardware-Catalog :\nThe PI4J-Context must add the LinuxFsI2CProvider.newInstance() Provider, which is explained under LinuxFS\npi4j = Pi4J.newContextBuilder() .noAutoDetect() .add(new RaspberryPiPlatform() { @Override protected String[] getProviders() { return new String[]{}; } }) .add(PiGpioDigitalInputProvider.newInstance(piGpio), PiGpioDigitalOutputProvider.newInstance(piGpio), PiGpioPwmProvider.newInstance(piGpio), PiGpioSerialProvider.newInstance(piGpio), PiGpioSpiProvider.newInstance(piGpio), LinuxFsI2CProvider.newInstance() ) .build(); When the right context is loaded, you can use the ADS1115 like following:\npublic class Ads1115_App implements Application { @Override public void execute(Context pi4j) { System.out.println(\u0026#34;ADS1115 demo started ...\u0026#34;); Ads1115 adc = new Ads1115(pi4j); System.out.println(\u0026#34;read all channels in single mode\u0026#34;); singleRead(adc); System.out.println(\u0026#34;read all channels in continuous mode\u0026#34;); continuousRead(adc); //cleanup adc.reset(); System.out.println(\u0026#34;ADS1115 demo finished\u0026#34;); } private void singleRead(Ads1115 adc) { System.out.println(\u0026#34;Single read started ...\u0026#34;); //read analog value from all four channels double aIn0 = adc.readValue(Ads1115.Channel.A0); double aIn1 = adc.readValue(Ads1115.Channel.A1); double aIn2 = adc.readValue(Ads1115.Channel.A2); double aIn3 = adc.readValue(Ads1115.Channel.A3); System.out.printf(\u0026#34;Voltages: a0=%.3f V, a1=%.3f V, a2=%.3f V, a3=%.3f V%n\u0026#34;, aIn0, aIn1, aIn2, aIn3); System.out.println(\u0026#34;Single read done.\u0026#34;); } private void continuousRead(Ads1115 adc) { System.out.println(\u0026#34;Continuous read started ...\u0026#34;); // Register event handlers to print a message on value change adc.onValueChange(Ads1115.Channel.A0, (value) -\u0026gt; System.out.printf(\u0026#34;Value channel 0 : %.2f V%n\u0026#34;, value)); adc.onValueChange(Ads1115.Channel.A1, (value) -\u0026gt; System.out.printf(\u0026#34;Value channel 1 : %.2f V%n\u0026#34;, value)); adc.onValueChange(Ads1115.Channel.A2, (value) -\u0026gt; System.out.printf(\u0026#34;Value channel 2 : %.2f V%n\u0026#34;, value)); adc.onValueChange(Ads1115.Channel.A3, (value) -\u0026gt; System.out.printf(\u0026#34;Value channel 3 : %.2f V%n\u0026#34;, value)); adc.startContinuousReading(0.1); // continue reading for 30 seconds delay(Duration.ofSeconds(30)); adc.stopContinuousReading(); System.out.println(\u0026#34;Continuous read done.\u0026#34;); } } Further project ideas An application, which detects the deflection of an analog joystick. An application, that determines the current position of a potentiometer. "},{"uri":"https://pi4j.com/examples/components/buzzer/","title":"Buzzer","tags":["Buzzer"],"description":"","content":"Description The Buzzer is a template class, that you can use in your own Java-project.\nThe Template Class gives you the option to play a note, and to create your own little melodies to play. The buzzer is controlled via a PWM output. The dutycycle is fixed at 50% and with the frequency the desired sound can be reproduced.\nLayout Buzzer Acitve Breadboard\nBuzzer Active\nCode A simple example on how to use the Buzzer-Class from the Hardware-Catalog:\npublic class Buzzer_App implements Application { //this is how you compose a simple melody //Piano baseline of Seven Nation Army by the white Stripes private final List\u0026lt;Buzzer.Sound\u0026gt; melody = List.of( new Buzzer.Sound(E7 , 11), new Buzzer.Sound(PAUSE, 1), new Buzzer.Sound(E7 , 2), new Buzzer.Sound(PAUSE, 2), new Buzzer.Sound(G6 , 2), new Buzzer.Sound(PAUSE, 3), new Buzzer.Sound(E7 , 2), new Buzzer.Sound(PAUSE, 4), new Buzzer.Sound(D6 , 2), new Buzzer.Sound(PAUSE, 3), new Buzzer.Sound(C7 , 16), new Buzzer.Sound(B5 , 8), new Buzzer.Sound(PAUSE, 8) ); private final List\u0026lt;Buzzer.Sound\u0026gt; imperialMarch = List.of( new Buzzer.Sound(G4, 8), new Buzzer.Sound(G4, 8), new Buzzer.Sound(G4, 8), new Buzzer.Sound(DS4, 6), new Buzzer.Sound(AS4, 2), new Buzzer.Sound(G4, 8), new Buzzer.Sound(DS4, 6), new Buzzer.Sound(AS4, 2), new Buzzer.Sound(G4, 16)); @Override public void execute(Context pi4j) { System.out.println(\u0026#34;Buzzer demo started\u0026#34;); //initialising the buzzer Buzzer buzzer = new Buzzer(pi4j, PIN.PWM13); //playing a simple tone System.out.println(\u0026#34;playing note b6 for 1 sec\u0026#34;); buzzer.playTone(1976, Duration.ofSeconds(1)); //relax for 1 second buzzer.silence(Duration.ofSeconds(1)); System.out.println(\u0026#34;start playing melody\u0026#34;); buzzer.playMelody(60, melody); delay(Duration.ofSeconds(3)); //first melody is stopped and second is played buzzer.playMelody(103, imperialMarch); buzzer.awaitEndOfMelody(); System.out.println(\u0026#34;Second melody has finished\u0026#34;); buzzer.reset(); System.out.println(\u0026#34;buzzer demo finished\u0026#34;); } } Further project ideas An application, which triggers if you walk by and starts beeping, like an alarm. An application, where you use many of them to create a beautiful sounding melody. "},{"uri":"https://pi4j.com/examples/components/camera/","title":"Camera","tags":["Camera"],"description":"","content":"Description The Camera is a template class, that you can use in your own Java-project. Currently, the code is only tested with a Raspberry-Camera and the crowpi-image. You can take pictures or videos, with or without a preview.\nTo connect the camera, use this video. The video is mentioned on the official website. The camera class is using the bash-commands \u0026ldquo;libcamera-hello\u0026rdquo;, \u0026ldquo;libcamera-still\u0026rdquo; and \u0026ldquo;libcamera-vid\u0026rdquo;. To use them, set up the raspberry with the following Introduction\nLayout Raspberry Camera\nCode An example on how to use the Camera-Class from the Hardware-Catalog\nCamera camera = new Camera(); System.out.println(\u0026#34;Taking a default picture\u0026#34;); camera.recordPicture(); System.out.println(\u0026#34;Taking a pic with different parameters\u0026#34;); var config = Camera.newPictureConfigBuilder() .outputPath(\u0026#34;/home/pi/Pictures/\u0026#34;) .delay(3000) .disablePreview(true) .encoding(Camera.PicEncoding.PNG) .useDate(true) .quality(93) .width(1280) .height(800) .build(); camera.recordPicture(config); System.out.println(\u0026#34;Waiting for camera to take pic\u0026#34;); delay(Duration.ofSeconds(4)); System.out.println(\u0026#34;Taking a video for 3 seconds\u0026#34;); var vidconfig = Camera.newVidConfigBuilder() .outputPath(\u0026#34;/home/pi/Videos/\u0026#34;) .recordTime(3000) .useDate(true) .build(); camera.recordVideo(vidconfig); camera.reset(); Further project ideas Use a camera and a motion-sensor to create a wildlife-camera Use a camera to monitor the entrance of a building, by publishing the preview of the camera to a webserver "},{"uri":"https://pi4j.com/documentation/io-examples/digital-input/","title":"Digital Input (GPIO)","tags":["Digital Input"],"description":"","content":"Similar to a digital output pin, a digital input translates an input value of 0V or 3.3V to the value false/true. This means any type of device which can toggle between 3.3V and 0V, can generate an input value to the Raspberry Pi. Here the most basic example is a toggle button. If you use other components, always check which is the voltage provided by the device. Or if you use a power pin from the Raspberry Pi itself, to use a 3.3V pin and not a 5V pin.\nV2+ provides a declarative style of configuration for I/O provisioning instead of the hard-coded approach offered in V1.\nThe following example shows the minimal code to configure the DIGITAL_INPUT_PIN\nas an input pin and monitor the pin state with by adding a Listener. The code uses methods which are provided by the Pi4J library. This implementation will operate with a Pi4j default Provider. The default Provider is not a concrete implementation and therefore running this program will not access the GPIO Hardware and the Hardware state will not be read/monitored. To access the Hardware a concrete Provider is required. See Providers\nExamples of the various methods and approaches which can be used to provision the I/O needs are available in the examples project.\nProperties properties = new Properties(); properties.put(\u0026#34;id\u0026#34;, \u0026#34;my_digital_input\u0026#34;); properties.put(\u0026#34;address\u0026#34;, DIGITAL_INPUT_PIN); properties.put(\u0026#34;pull\u0026#34;, \u0026#34;UP\u0026#34;); properties.put(\u0026#34;name\u0026#34;, \u0026#34;MY-DIGITAL-INPUT\u0026#34;); var config = DigitalInput.newConfigBuilder(pi4j) .load(properties) .build(); var input = pi4j.din().create(config); s Once an input has been initialized, a listener can be attached to execute code on state changes of the input.\ninput.addListener(e -\u0026gt; { if (e.state() == DigitalState.HIGH) { console.println(\u0026#34;Button is pressed\u0026#34;); } }); "},{"uri":"https://pi4j.com/examples/components/joystick/","title":"Joystick","tags":["Joystick"],"description":"","content":"Description The Joystick is a template class, that you can use in your own Java-project. The template is created for a digital joystick with 4 directions (up, right, down, left) and as an option additionally with a push button in direction down. A suitable hardware component is the arcade joystick in the picture bellow. But any joystick with switching contacts will meet the requirements.\nThe template class allows to query the individual joystick positions and can trigger a simple event when the joystick swings out in a direction or when it returns to the center position.\nLayout Joystick Digital Breadboard\nJoystick Digital Breadboard Detail\nJoystick Digital Top View\nJoystick Digital Back View All Axis\nJoystick Digital Back View One Axis\nJoystick Digital Wiring Back\nJoystick Digital Wiring Back Corner\nCode A simple example on how to use the Joystick-Class from the Hardware-Catalog:\n//Initialize the joystick component final var joystick = new Joystick(pi4j, PIN.D5, PIN.D6, PIN.PWM13, PIN.PWM19, PIN.D26); //Register all event handlers joystick.onNorth(() -\u0026gt; System.out.println(\u0026#34;Start NORTH\u0026#34;)); joystick.whileNorth(() -\u0026gt; System.out.println(\u0026#34;Still NORTH\u0026#34;), Duration.ofSeconds(1)); joystick.onWest(() -\u0026gt; System.out.println(\u0026#34;Start WEST\u0026#34;)); joystick.whileWest(() -\u0026gt; System.out.println(\u0026#34;Still WEST\u0026#34;), Duration.ofSeconds(1)); joystick.onSouth(() -\u0026gt; System.out.println(\u0026#34;Start SOUTH\u0026#34;)); joystick.whileSouth(() -\u0026gt; System.out.println(\u0026#34;Still SOUTH\u0026#34;), Duration.ofSeconds(1)); joystick.onEast(() -\u0026gt; System.out.println(\u0026#34; Start EAST\u0026#34;)); joystick.whileEast(() -\u0026gt; System.out.println(\u0026#34;Still EAST\u0026#34;), Duration.ofSeconds(1)); joystick.onPushDown(() -\u0026gt; System.out.println(\u0026#34;Start PUSH\u0026#34;)); joystick.onPushUp(() -\u0026gt; System.out.println(\u0026#34;Still PUSHing\u0026#34;)); // Wait for 15 seconds while handling events before exiting System.out.println(\u0026#34;Move the joystick and push it\u0026#39;s button to see it in action!\u0026#34;); delay(Duration.ofSeconds(15)); // cleanup joystick.reset(); Further application The class is not yet implemented in a project.\nFurther project ideas Realize the popular arcade game Street Fighter on your own Raspberry Pi. Create a claw crane game machine, the hit at every party. "},{"uri":"https://pi4j.com/examples/components/joystickanalog/","title":"Joystick Analog","tags":["Joystick analog","ADS1115"],"description":"","content":"Description The JoystickAnalog is a template class, that you can use in your own Java-project. The template class is created for an analog joystick, for example the KY-023, which consists of two potentiometers, one for the X-axis and one for the Y-axis. But any joystick with two potentiometers will meet the requirements.\nThe basic functions of the template class are:\nreturn of a normalized value, optionally between 0 and 1 or between -1 and 1, of the X-axis and the Y-axis creation of simple events at a value change of the X-axis or the Y-axis, simple event handlers for button pressed, button depressed, while button is pressed calibration of the center position of the joystick (center position 0.5 at a normalized value between 0 and 1, center position 0 at a normalized value between -1 and 1) Layout Joystick Analog Breadboard\nJoystick Analog\nADS1115-Front\nADS1115-Back\nCode A simple example on how to use the JoystickAnalog-Class from the Hardware-Catalog:\n// an analog joystick needs an ADC Ads1115 ads1115 = new Ads1115(pi4j); //joystick with normalized axis from -1 to 1 JoystickAnalog joystick = new JoystickAnalog(ads1115, Ads1115.Channel.A0, Ads1115.Channel.A1, PIN.D26, true); //register all event handlers you need joystick.onMove((xPos, yPos) -\u0026gt; System.out.printf(\u0026#34;Current position of joystick is: %.2f, %.2f%n\u0026#34;, xPos, yPos), () -\u0026gt; System.out.println(\u0026#34;Joystick in home position\u0026#34;)); joystick.onDown (() -\u0026gt; System.out.println(\u0026#34;Pressing the button\u0026#34;)); joystick.onUp (() -\u0026gt; System.out.println(\u0026#34;Stopped pressing.\u0026#34;)); joystick.whilePressed(() -\u0026gt; System.out.println(\u0026#34;Button is still pressed.\u0026#34;), Duration.ofMillis(500)); //start continuous reading after all ADC channels are configured ads1115.startContinuousReading(0.1); System.out.println(\u0026#34;Move the joystick to see it in action!\u0026#34;); //wait while handling events before exiting delay(Duration.ofSeconds(30)); //cleanup joystick.reset(); Further project ideas create your own PlayStation controller use the joystick to control the position of servo motors steplessly "},{"uri":"https://pi4j.com/examples/components/lcddisplay/","title":"LCD Display","tags":["LCD Display"],"description":"","content":"Description The LcdDisplay is a template class, that you can use in your own Java-project. It is used to show Numbers, Text and Symbols on a small Display. The Class supports only LCD Displays with the PCF8574T I2C Backpack. Supported display-dimensions are 40x2, 20x4, 20x2, 16x2, 16x1.\nIF YOU CAN\u0026rsquo;T SEE ANYTHING WRITTEN ON THE DISPLAY, TRY TO SET THE CONTRAST BY TURNING THE CONTRAST-SCREW AT THE BACK WITH A SCREWDRIVER. Also, check if I2C is enabled in your raspberry-config.\nLayout LCD Display 2 Rows Breadboard\nLCD Display 2 Rows Front\nLCD Display 2 Rows Back\nLCD Display 4 Rows Front\nLCD Display 4 Rows Back\nCode An example on how to use the LCD Display-Class from the Hardware-Catalog\nThe PI4J-Context must add the LinuxFsI2C Provider, which is explained under LinuxFS\npi4j = Pi4J.newContextBuilder() .noAutoDetect() .add(new RaspberryPiPlatform() { @Override protected String[] getProviders() { return new String[]{}; } }) .add(PiGpioDigitalInputProvider.newInstance(piGpio), PiGpioDigitalOutputProvider.newInstance(piGpio), PiGpioPwmProvider.newInstance(piGpio), PiGpioSerialProvider.newInstance(piGpio), PiGpioSpiProvider.newInstance(piGpio), LinuxFsI2CProvider.newInstance() ) .build(); When the right Context is loaded, you can use the Display like following:\npublic class LcdDisplay_App implements Application { @Override public void execute(Context pi4j) { System.out.println(\u0026#34;LCD demo started\u0026#34;); //Create a Component, with amount of ROWS and COLUMNS of the device //LcdDisplay lcd = new LcdDisplay(pi4j); //2x16 is default LcdDisplay lcd = new LcdDisplay(pi4j, 4, 20); // Write text to specific position lcd.displayLineOfText(\u0026#34;Hello\u0026#34; , 0); lcd.displayLineOfText(\u0026#34;World!\u0026#34;, 1, 3); // Wait a little to have some time to read it delay(Duration.ofSeconds(3)); lcd.clearDisplay(); lcd.centerTextInLine(\u0026#34;Hi\u0026#34;, 0); delay(Duration.ofSeconds(1)); // To write some text there are different methods. The simplest one is this one which automatically inserts // linebreaks if needed. lcd.displayText(\u0026#34;Boohoo that\u0026#39;s so simple to use!\u0026#34;); delay(Duration.ofSeconds(3)); // Of course, it is also possible to use linebreaks lcd.displayText(\u0026#34;Some big text \\nwith a new line\\nonly displayed on 4 row LCD\u0026#34;); delay(Duration.ofSeconds(4)); // Long text are cut to the bone lcd.displayText(\u0026#34;Some big text with no new lines, just to test how many lines will get filled\u0026#34;); delay(Duration.ofSeconds(4)); // Clear the display to start next parts lcd.clearDisplay(); // Let\u0026#39;s try to draw a house. // To keep this method short and clean we create the characters in a separate method below. createCharacters(lcd); // Now all characters are ready. Just draw them on the right place by moving the cursor and writing the // created characters to specific positions lcd.writeCharacter(\u0026#39;\\1\u0026#39;, 0, 1); lcd.writeCharacter(\u0026#39;\\2\u0026#39;, 0, 2); lcd.writeCharacter(\u0026#39;\\3\u0026#39;, 1, 1); lcd.writeCharacter(\u0026#39;\\4\u0026#39;, 1, 2); delay(Duration.ofSeconds(3)); // we\u0026#39;ve built a rolling home for (int i = 0; i \u0026lt; 5; i++) { lcd.scrollRight(); delay(Duration.ofSeconds(1)); } for (int i = 0; i \u0026lt; 5; i++) { lcd.scrollLeft(); delay(Duration.ofSeconds(1)); } lcd.reset(); System.out.println(\u0026#34;LCD demo finished\u0026#34;); } public void createCharacters(LcdDisplay lcd) { // Create upper left part of the house lcd.createCharacter(1, new byte[]{ 0b00000, 0b00000, 0b00000, 0b00001, 0b00011, 0b00111, 0b01111, 0b11111 }); // Create upper right part of the house lcd.createCharacter(2, new byte[]{ 0b00000, 0b00000, 0b00010, 0b10010, 0b11010, 0b11110, 0b11110, 0b11111 }); // Create lower left part of the house lcd.createCharacter(3, new byte[]{ 0b11111, 0b11111, 0b11111, 0b11111, 0b10001, 0b10001, 0b10001, 0b10001 }); // Create lower right part of the house lcd.createCharacter(4, new byte[]{ 0b11111, 0b11111, 0b11111, 0b10001, 0b10001, 0b10001, 0b11111, 0b11111 }); } } If you want to create an own character or symbol, then use the following tutorial. Right at the bottom, you can click on the bitmap to see the byte-code. Create an own Symbol\nFurther project ideas A Temperature Sensor hooked to a display, where it constantly shows how warm it is A microphone, which listens what is said, and writing on the display what is said "},{"uri":"https://pi4j.com/examples/components/ledbutton/","title":"LED Button","tags":["LED Button","LED","Button"],"description":"","content":"Description The LedButton is a template class, that you can use in your own Java-project. You can take any Button with a LED you want to. Like for example the big button bellow in the picture gallery.\nThe Template Class gives you the option to check the state of the button, and to create simple events if the button is pressed or depressed, or the whole time is is being pressed. Also it lets you control the LED.\nLayout Led Button Breadboard\nBig Button\nCode A simple example on how to use the Button-Class from the Hardware-Catalog:\n// Initialize the button component final LedButton ledButton = new LedButton(pi4j, PIN.D26, false, PIN.D5); // Make a flashing light by toggling the LED for (int i = 0; i \u0026lt; 4; i++) { ledButton.toggleLed(); delay(Duration.ofMillis(500)); } // Register event handlers to turn LED on when pressed (onDown) and off when depressed (onUp) ledButton.onDown(() -\u0026gt; ledButton.ledOn()); ledButton.onUp (() -\u0026gt; ledButton.ledOff()); // Wait for 15 seconds while handling events before exiting System.out.println(\u0026#34;Press the button to see it in action!\u0026#34;); delay(Duration.ofSeconds(15)); // Unregister all event handlers to exit this application in a clean way ledButton.reset(); System.out.println(\u0026#34;LED button demo finished.\u0026#34;); Further project ideas An application, which includes a button. if the button is pressed, the app will order you a crate of beer from your favorite store. An application, where you can play \u0026ldquo;whack a mole\u0026rdquo;. If the LED is on and you hit the right button, you get points. "},{"uri":"https://pi4j.com/examples/components/ledmatrix/","title":"LED Matrix","tags":["LED Matrix"],"description":"","content":" Although this example is still valid, an easier approach for the control of an array of LEDs can be achieved with the PixelBlaze Output Expander as described here.\nDescription The LedMatrix is a template class, that you can use in your own Java-project. It is an extension of the class LEDStrip. An LED matrix can be built from one LED strip. To do this, separate the LED strip at the desired point and place the individual strips under each other or next to each other. The individual ends can then be connected to each other with a wire. The constructor can be passed either as a rectangular matrix or a user-defined matrix with different numbers of LEDs in the individual strips. A software compatible LED strip is for example the WS28xx-chip set LED Strip.\nMake sure to check if SPI is enabled in your RaspberryPI. Check the SPI Address. Default is \u0026ldquo;SPI0 MOSI\u0026rdquo; Pin (#19).\nLayout LED Matrix Breadboard\nLED Matrix\nCode A simple example on how to use the LEDMatrix-Class from the Hardware-Catalog:\nSystem.out.println(\u0026#34;LED matrix app started ...\u0026#34;); int Rows = 3; int Columns = 4; double brightness = 0.5; System.out.println(\u0026#34;Initialising the matrix\u0026#34;); LedMatrix ledMatrix = new LedMatrix(pi4j, Rows, Columns, brightness); System.out.println(\u0026#34;Setting all LEDs to Red.\u0026#34;); ledMatrix.setMatrixColor(LedStrip.PixelColor.RED); ledMatrix.render(); delay(3000); System.out.println(\u0026#34;setting the second strip to green\u0026#34;); ledMatrix.setStripColor(1, LedStrip.PixelColor.GREEN); ledMatrix.render(); delay(3000); System.out.println(\u0026#34;Setting the third led of the third strip to Yellow\u0026#34;); ledMatrix.setPixelColor(2, 2, LedStrip.PixelColor.YELLOW); ledMatrix.render(); delay(3000); ledMatrix.close(); System.out.println(\u0026#34;LED matrix app done.\u0026#34;); Further application The class is not yet implemented in a project.\nFurther project ideas A suit with a sewn-on LED matrix, which can be used to display images and animations. A LED-strip which can be used as a backlight of a screen. The color and brightness can change to the volume and mood of the displayed images. "},{"uri":"https://pi4j.com/examples/components/ledstrip/","title":"LED Strip","tags":["LED Strip"],"description":"","content":" Although this example is still valid, an easier approach for the control of an array of LEDs can be achieved with the PixelBlaze Output Expander as described here.\nDescription The LedStrip is a template class, that you can use in your own Java-project. You can take a LED Strip with the WS28xx-chip set.\nThe Template Class gives you the option to set the LED\u0026rsquo;s of the strip to a desired RGB-Color. If you have many strips, you can use the LEDMatrix\nMake sure to check if SPI is enabled in your RaspberryPI. Check the SPI Address. Default is \u0026ldquo;SPI0 MOSI\u0026rdquo; Pin (#19).\nLayout LED Strip 4 LED Breadboard\nLED Strip 4 LED\nCode A simple example on how to use the LEDStrip-Class from the Hardware-Catalog:\nSystem.out.println(\u0026#34;LED strip app started ...\u0026#34;); // Initialize the RGB int pixels = 4; final LedStrip ledStrip = new LedStrip(pi4j, pixels, 0.5); //set them all off, so nothing is shining System.out.println(\u0026#34;Starting with setting all leds off\u0026#34;); ledStrip.allOff(); System.out.println(\u0026#34;setting the LEDs to RED\u0026#34;); ledStrip.setStripColor(LedStrip.PixelColor.RED); ledStrip.render(); delay(3000); System.out.println(\u0026#34;setting the LEDs to Light Blue\u0026#34;); ledStrip.setStripColor(LedStrip.PixelColor.LIGHT_BLUE); ledStrip.render(); delay(3000); System.out.println(\u0026#34;setting the first led to Purple\u0026#34;); ledStrip.setPixelColor(0, LedStrip.PixelColor.PURPLE); ledStrip.render(); delay(3000); System.out.println(\u0026#34;setting the brightness to full and just show the first led as White\u0026#34;); ledStrip.allOff(); ledStrip.setBrightness(1); ledStrip.setPixelColor(0, LedStrip.PixelColor.WHITE); ledStrip.render(); delay(3000); //finishing and closing ledStrip.close(); System.out.println(\u0026#34;closing the app\u0026#34;); System.out.println(\u0026#34;Color \u0026#34;+ ledStrip.getPixelColor(0)); System.out.println(\u0026#34;LED strip app done.\u0026#34;); Further project ideas A suit with LED-Strips sewn on, on which different animations can run. A LED-strip which can be used as a backlight of a screen. The color and brightness can change to the volume and mood of the displayed images. "},{"uri":"https://pi4j.com/examples/components/potentiometer/","title":"Potentiometer","tags":["Potentiometer"],"description":"","content":"Description The Potentiometer is a template class, that you can use in your own Java-project. The constructor of the class requires an ADS1115 object. In addition, the channel, with which the AD converter evaluates the current position of the sliding contact must be defined. For normalization, the maximum voltage that can drop across the sliding contact must also be specified. Any commercially available potentiometer with three connections (fixed resistor and the slider) can be evaluated with this class.\nThe current position of the slider can be defined with a single shot. The return value is either in volts or as a normalized value between 0 and 1.\nFor continuous monitoring either a slow method can be selected or a fast one. In this case, individual measurements (single shots) are started and evaluated cyclically. With this method, up to 4 devices can be attached to the AD converter. The maximum sampling frequency of the signal depends on how many channels of the AD converter are used simultaneously and how high the sampling rate of the AD converter is set to.\nUsing the fast method, a continuous measurement is started in the AD converter. The maximum sampling frequency is now only dependent on the sampling rate of the AD converter. However, in this mode only one device can be attached to the AD converter simultaneously.\nIf continuous measurement is active, a customized event can be triggered when the position of the slider changes. The threshold can be used to set the sensitivity at which the event should be triggered.\nLayout Potentiometer Breadboard\nPotentiometer\nADS1115-Front\nADS1115-Back\nCode A simple example on how to use the potentiometer from the Hardware-Catalog:\n// a potentiometer needs an ADC Ads1115 ads1115 = new Ads1115(pi4j); Potentiometer poti = new Potentiometer(ads1115, Ads1115.Channel.A0); //read current value from poti one time System.out.printf(\u0026#34;P0 raw value is %.2f V%n\u0026#34;, poti.readCurrentVoltage()); //read current value from the poti in percent one time System.out.printf(\u0026#34;P0 normalized value is %.2f %%%n\u0026#34;, poti.readNormalizedValue()); // Register event handlers to print a message when potentiometer is moved poti.onNormalizedValueChange((value) -\u0026gt; System.out.printf(\u0026#34;P0 slider is at %.2f %%%n\u0026#34;, value)); //you have to start continuous reading on ADC (because you can use up to 4 channels and all of them need to be fully configured before starting to read the values) ads1115.startContinuousReading(0.1); System.out.println(\u0026#34;Move the potentiometer to see it in action!\u0026#34;); // Wait while handling events before exiting delay(Duration.ofSeconds(15)); ads1115.stopContinuousReading(); System.out.println(\u0026#34;No new values should be reported\u0026#34;); delay(Duration.ofSeconds(5)); ads1115.reset(); System.out.println(\u0026#34;Potentiometer demo finished\u0026#34;); Further project ideas An application, to control the brightness of some lights. The speed and direction of a drone can be controlled with a potentiometer. "},{"uri":"https://pi4j.com/examples/components/servo/","title":"ServoMotor","tags":["Servo Motor"],"description":"","content":"Description The ServoMotor is a template class, that you can use in your own Java-project. You can set the servo to a specific location, likewise to 110 degrees of it\u0026rsquo;s range.\nYou can use a wide variety of analog servo motors such as the SG92R or the SG-5010 (for a little more torque).\nLayout Servo Breadboard\nServo SG-5010 Top View\nServo SG-5010 Side View\nServo SG92R Side View\nMini Power Supply Module\nMini Power Supply Module Front Back\nCode An example how to use the Servo-Class from the Hardware-Catalog:\n// Initialize servo motor component final var servoMotor = new ServoMotor(pi4j, PIN.PWM18, 50, -90.0f, 90.0f, 2.0f, 12f); // Demonstrate the percentage mapping on the servo System.out.println(\u0026#34;In 2 seconds, the servo motor will move to the left-most position which is 0%\u0026#34;); delay(Duration.ofSeconds(2)); servoMotor.setPercent(0); System.out.println(\u0026#34;In another 2 seconds, the servo motor will show 100% by moving to the right-most position\u0026#34;); delay(Duration.ofSeconds(2)); servoMotor.setPercent(100); System.out.println(\u0026#34;Last but not least, in 2 more seconds the servo will be centered to display 50%\u0026#34;); delay(Duration.ofSeconds(2)); servoMotor.setPercent(50); // Sweep once from left to right using the setAngle function System.out.println(\u0026#34;We will sweep once to the left in 2 seconds...\u0026#34;); delay(Duration.ofSeconds(2)); servoMotor.setAngle(-45); System.out.println(\u0026#34;... and now to the right in 2 more seconds!\u0026#34;); delay(Duration.ofSeconds(2)); servoMotor.setAngle(45); // Use a custom range for displaying the data System.out.println(\u0026#34;Imagine a pointer on the servo positioned above a label between -20ºC and +40ºC\u0026#34;); System.out.println(\u0026#34;By using the setRange() method, we can automatically map our temperature range to the servo range!\u0026#34;); System.out.println(\u0026#34;As an example, in five seconds the servo will show -10º which should be on the far left of the servo.\u0026#34;); delay(Duration.ofSeconds(2)); servoMotor.setRange(-20, +40); // This will define our range as values between -20 and +40 servoMotor.moveOnRange(-10); // This will map -10 based on the previously defined range servoMotor.reset(); Further project ideas As a Servo can cover up to 180 degrees, it could be used as a steering-wheel hooked to a potentiometer As a pointer, to show how much time is left in a timer "},{"uri":"https://pi4j.com/documentation/io-examples/pwm/","title":"Pulse Width Modulation (PWM)","tags":["PWM"],"description":"","content":"What is it? The abbreviation PWM stands for \u0026ldquo;Pulse Width Modulation\u0026rdquo; and is also often referred to in German as pulse width modulation or pulse duration modulation. This technology is used, among other things, to control servomotors and is also used, for example, for the fans of a regular computer.\nWith PWM, it is possible to control a component such as a motor no longer purely binary, i.e. off (0% power) or on (100% power), but to control them almost at will. The functionality of PWM works in such a way that the component is switched off and on again and again within a certain period of time.\nPigpio Provider (pigpio-pwm) Software vs. Hardware When using the pigpio-pwm provider two different types of PWM are available on the Raspberry Pi, specifically a software and a hardware implementation. Both basically offer the same options, but the software version cannot achieve precise or particularly fast frequencies. When using the linuxfs-pwm provider only hardware PWM is available.\nSoftware PWM limitation The reason for this is that in the software implementation for each individual cycle (on / off) a new control command must be transmitted from the JVM (Java Virtual Machine) to the corresponding component, while in the hardware implementation of the Raspberry Pi notices the desired frequency and regulates it independently directly on the board.\nThe Raspberry Pi supports 2 hardware based PWM channels. You can access these two channels via 2 separate sets of 4 GPIO header pins, but still limited to only 2 channels (2 unique PWM timing configurations).\nPWM GPIOs The same PWM channel is available on multiple GPIOs. The latest frequency and dutycycle setting will be used by all GPIO which share a PWM channel.\nThe GPIO must be one of the following:\n12 PWM channel 0 All models but A and B 13 PWM channel 1 All models but A and B 18 PWM channel 0 All models 19 PWM channel 1 All models but A and B 40 PWM channel 0 Compute module only 41 PWM channel 1 Compute module only 45 PWM channel 1 Compute module only 52 PWM channel 0 Compute module only 53 PWM channel 1 Compute module only The GPIO number in the above chart is supplied as the buildPwmConfig config value address.\nAs Pi4J is using PiGPIO \u0026ldquo;under the hood\u0026rdquo;, you can take advantage of the additional PWM functionalities of it. PiGPIO is providing additional (soft) PWM support to any of the GPIO pins (0-31) and its using some hardware timing technique to optimize performance \u0026mdash; but its not the same as the actual hardware PWM pins natively on the RaspberryPi. In the Pi4J API, we call this \u0026ldquo;Software\u0026rdquo; PWM and you would need to set .pwmType(PwmType.SOFTWARE). We consider this software-based PWM because its being provided at a software layer, in this case by the PIGPIO library.\nIf you need more than 2 PWM pins, use the software PWM functionality, it may be perfectly fine for your application. If they are not good enough, then you will probably need a PWM expander board/chip (controlled by I2C/SPI) to provide additional PWM support.\nLinuxfs Provider (linuxfs-pwm) As of version 2.6.0 of Pi4J, linuxfs-pwm also supports hardware PWM on the Raspberry Pi 5. More information and an example implementation is available in the blog post PWM Hardware Support on Raspberry Pi5.\nHardware only Only hardware PWM is supported.\nPWM GPIOs The channel number in the following charts are supplied as the buildPwmConfig config value address.\nThe user must modify config.txt to enable PWM.\nRaspberry OS Bullseye: /boot/config.txt Raspberry OS Bookworm /boot/firmware/config.txt To take effect after file modification the Raspberry Pi must be rebooted.\nRaspberry Pi 4 Use one of the following configurations:\n[all] dtoverlay=pwm # GPIO 18 = channel 0 [all] dtoverlay=pwm-2chan # GPIO 18 = channel 0 # GPIO 19 = channel 1 [all] dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4 # GPIO 12 = channel 0 # GPIO 13 = channel 1 You can test the PWM channels in the terminal like this:\n# With dtoverlay=pwm-2chan in config.txt $ pinctrl get 18 18: a5 pd | lo // GPIO18 = PWM0_0 $ pinctrl get 19 19: a5 pd | lo // GPIO19 = PWM0_1 Raspberry Pi 5 Use one of the following configurations:\n[all] dtoverlay=pwm # GPIO 18 = channel 2 [all] dtoverlay=pwm-2chan # GPIO 18 = channel 2 # GPIO 19 = channel 3 [all] Dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4 # GPIO 12 = channel 0 # GPIO 13 = channel 1 The statement added to config.txt will determine which GPIOs will exhibit the PWM behavior. The channel number in the above charts are supplied as the buildPwmConfig value for the address.\nYou can test the PWM channels in the terminal like this:\n# With dtoverlay=pwm-2chan in config.txt $ pinctrl get 18 18: a3 pd | lo // GPIO18 = PWM0_CHAN2 $ pinctrl get 19 19: a3 pd | lo // GPIO19 = PWM0_CHAN3 Technical implementation For the technical control of a component with PWM, two values must be defined:\nPulse-pause ratio (English: Duty Cycle): This value defines the ratio between the switched-on and switched-off status and is represented by a number between 0% and 100%. A value of 50% means that within one cycle the component is switched on exactly half the time and then switched off. A value of 25%, on the other hand, would mean that the component is switched on only a quarter of the time and the component remains switched off for the remaining three quarters of the cycle. Frequency: This value defines how often per second a cycle (on / off) takes place for this component and is usually specified in the unit Hertz (Hz). With a value of 10Hz, the component would alternate 10 times between being switched on and switched off in one second. These two values can be controlled via the Pi4J library and are also used internally by this project.\nAdditional Information Choosing an I/O Provider Wikipedia on PWM Wikipedia with audio frequencies Code example The following example is an extract of the CrowPi example project which includes a component to control a buzzer with PWM. Of importance, this example executes on a Raspberry Pi4, the buildPwmConfig(Context pi4j, int address) example code uses pigpio-pwm and the value passed for \u0026lsquo;address\u0026rsquo; is the BCM pin number.\npublic class BuzzerComponent extends Component { protected final Pwm pwm; /** * Creates a new buzzer component with a custom BCM pin. * * @param pi4j Pi4J context * @param address Custom BCM pin address */ public BuzzerComponent(Context pi4j, int address) { this.pwm = pi4j.create(buildPwmConfig(pi4j, address)); } /** * Plays a tone with the given frequency in Hz indefinitely. * This method is non-blocking and returns immediately. * A frequency of zero causes the buzzer to play silence. * * @param frequency Frequency in Hz */ public void playTone(int frequency) { playTone(frequency, 0); } /** * Plays a tone with the given frequency in Hz for a specific duration. * This method is blocking and will sleep until the specified duration has passed. * A frequency of zero causes the buzzer to play silence. * A duration of zero to play the tone indefinitely and return immediately. * * @param frequency Frequency in Hz * @param duration Duration in milliseconds */ public void playTone(int frequency, int duration) { if (frequency \u0026gt; 0) { // Activate the PWM with a duty cycle of 50% and the given frequency in Hz. // This causes the buzzer to be on for half of the time during each cycle, resulting in the desired frequency. pwm.on(50, frequency); // If the duration is larger than zero, the tone should be automatically stopped after the given duration. if (duration \u0026gt; 0) { sleep(duration); this.playSilence(); } } else { this.playSilence(duration); } } /** * Silences the buzzer and returns immediately. */ public void playSilence() { pwm.off(); } /** * Silences the buzzer and waits for the given duration. * This method is blocking and will sleep until the specified duration has passed. * * @param duration Duration in milliseconds */ public void playSilence(int duration) { this.playSilence(); sleep(duration); } /** * Returns the created PWM instance for the buzzer * * @return PWM instance */ protected Pwm getPwm() { return this.pwm; } /** * Builds a new PWM configuration for the buzzer using pigpio-pwm * * @param pi4j Pi4J context * @param address BCM pin address * @return PWM configuration */ protected static PwmConfig buildPwmConfig(Context pi4j, int address) { return Pwm.newConfigBuilder(pi4j) .id(\u0026#34;BCM\u0026#34; + address) .name(\u0026#34;Buzzer\u0026#34;) .address(address) .pwmType(PwmType.HARDWARE) .provider(\u0026#34;pigpio-pwm\u0026#34;) .initial(0) .shutdown(0) .build(); } /** Builds a new PWM configuration for the buzzer using linuxfs-pwm * @param pi4j Pi4J context * @param channel Channel * @return PWM configuration */ protected static PwmConfig buildPwmConfig(Context pi4j, int channel) { return Pwm.newConfigBuilder(pi4j) .id(\u0026#34;Channel\u0026#34; + channel) .name(\u0026#34;Buzzer\u0026#34;) .address(channel) .pwmType(PwmType.HARDWARE) .provider(\u0026#34;linuxfs-pwm\u0026#34;) .initial(0) .shutdown(0) .build(); } } "},{"uri":"https://pi4j.com/documentation/io-examples/i2c/","title":"Inter-Integrated Circuit (I²C)","tags":["I2C"],"description":"","content":"What is it? I²C (spoken as I-Squared-C) is a bus originally invented by Philips. It is designed as a classic master-slave bus. A data transfer is always i nitiated by a master. It can also be set up in a multi-master system. I²C is connected via two signal lines (data line and clock line). The transmission rate of the bus can be between 0.1 Mbit/s up to 3.4 Mbit/s depending on the clock rate. If only a unidirectional connection is required, even 5.0 Mbit/s would be possible. It should be noted: the higher the clock rate, the more susceptible to failure the overall system becomes. The low operating voltage of only 3.3V does not contribute to interference resistance either.\nUses I²C is mainly used for communication between microcontrollers. The advantage that a whole series of microcontrollers can be controlled via just 2 lines is of course very interesting for the circuit board layout. The main advantages of I²C are its simplicity. There are certainly newer bus systems with better transmission rates. Hardly any bus system is as easy to use as I²C. Even “hot plugging”, ie plugging in and unplugging the devices during operation, is possible with I²C.\nAddressing I²C uses an address space of 7 bits. This allows up to 112 nodes on one bus. The remaining 16 addresses are reserved for special applications. Usually the address of a device is defined directly by the manufacturer. It can therefore be found in the relevant data sheets. Due to the shortage of addresses, there is also a variant with a 10-bit address space. Up to 1136 nodes are possible, and the protocol is compatible with the smaller 7-bit address space.\nCommand line tool to output a list of installed busses:\nroot@rp5:~# i2cdetect -l i2c-1\ti2c Synopsys DesignWare I2C adapter I2C adapter i2c-11\ti2c 107d508200.i2c I2C adapter i2c-12\ti2c 107d508280.i2c I2C adapter Command line tool to immediately scan the standard addresses on I2C bus 1 (i2c-1)\nroot@rp5:~# i2cdetect -y 1 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 3f 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- -- 1 device found with address of 0x3f.\nTransfer rates Mode Max. transfer rate Direction Standard Mode 0.1 Mbit/s bidirektional Fast Mode 0.4 Mbit/s bidirektional Fast Mode Plus 1.0 Mbit/s bidirektional High Speed Mode 3.4 Mbit/s bidirektional Ultra Fast-mode 5.0 Mbit/s unidirektional Additional information Wikipedia I²C I²C Bus Code example Feel free to check the Kotlin DSL for I²C\nThe following code shows setting the pins on a TCA 9534 which can be found on \u0026ldquo;Sequent Microsystems\u0026rdquo;\nTo use the LinuxFS provider, which provides I2C, add the proper dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-linuxfs\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Now we can use the following example:\nimport com.pi4j.Pi4J; import com.pi4j.context.Context; import com.pi4j.io.i2c.I2C; import com.pi4j.io.i2c.I2CConfig; import com.pi4j.io.i2c.I2CProvider; public class SimpleTca9534I2cTest { private static final byte TCA9534_REG_ADDR_OUT_PORT = 0x01; private static final byte TCA9534_REG_ADDR_CFG = 0x03; public static void main(String[] args) throws Exception { Context pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j).id(\u0026#34;TCA9534\u0026#34;).bus(1).device(0x3f).build(); try (I2C tca9534Dev = i2CProvider.create(i2cConfig)) { int config = tca9534Dev.readRegister(TCA9534_REG_ADDR_CFG); if (config \u0026lt; 0) throw new IllegalStateException( \u0026#34;Failed to read configuration from address 0x\u0026#34; + String.format(\u0026#34;%02x\u0026#34;, TCA9534_REG_ADDR_CFG)); byte currentState = (byte) tca9534Dev.readRegister(TCA9534_REG_ADDR_OUT_PORT); if (config != 0x00) { System.out.println(\u0026#34;TCA9534 is not configured as OUTPUT, setting register 0x\u0026#34; + String .format(\u0026#34;%02x\u0026#34;, TCA9534_REG_ADDR_CFG) + \u0026#34; to 0x00\u0026#34;); currentState = 0x00; tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, currentState); tca9534Dev.writeRegister(TCA9534_REG_ADDR_CFG, (byte) 0x00); } // bit 8, is pin 1 on the board itself, so set pins in reverse: currentState = setPin(currentState, 8, tca9534Dev, true); Thread.sleep(500L); currentState = setPin(currentState, 8, tca9534Dev, false); Thread.sleep(500L); currentState = setPin(currentState, 7, tca9534Dev, true); Thread.sleep(500L); currentState = setPin(currentState, 7, tca9534Dev, false); Thread.sleep(500L); } } public static byte setPin(byte currentState, int pin, I2C tca9534Dev, boolean high) { byte newState; if (high) newState = (byte) (currentState | (1 \u0026lt;\u0026lt; pin)); else newState = (byte) (currentState \u0026amp; ~(1 \u0026lt;\u0026lt; pin)); System.out.println(\u0026#34;Setting TCA9534 to new state \u0026#34; + asBinary(newState)); tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, newState); return newState; } public static String asBinary(byte b) { StringBuilder sb = new StringBuilder(); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 7) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 6) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 5) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 3) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 0) \u0026amp; 1)); return sb.toString(); } } "},{"uri":"https://pi4j.com/documentation/io-examples/i2c/clock-stretching/","title":"I²C Clock Stretching","tags":["I2C"],"description":"","content":"Clock Stretching Please be aware there are some hardware issues when using the Raspberry Pi with devices that expect to be able to use clock stretching, for more info see \u0026ldquo;Adventures in I2C: clock stretching on the Raspberry Pi\u0026rdquo; and \u0026ldquo;I2C stretch bug. Been fixed or not?\u0026rdquo;.\nClock stretching in I2C allows a slave device to halt the master before a more data is sent. This is often the case when the slave device writes to an EEPROM etc. which takes longer than a usual read or write to a register.\nOn the Raspberry Pi clock stretching can be configured by using a higher timeout while waiting for a slave to respond. This is something that can not be done by the pi4j, as it requires root privileges.\nThere are two ways to change the clkt_tout value. This repository path has two files, a i2c1_get_clkt_tout.c and i2c1_set_clkt_tout.c. Build them as follows:\nPrepare:\n# install gcc to compile the c files apt install build-essential mkdir clkt_tout cd clkt_tout/ wget wget https://raw.githubusercontent.com/raspihats/raspihats/master/clk_stretch/i2c1_get_clkt_tout.c wget wget https://raw.githubusercontent.com/raspihats/raspihats/master/clk_stretch/i2c1_set_clkt_tout.c Makefile\nSave as Makefile\nCC=gcc CFLAGS=-Wall .PHONY: all install uninstall clean all: i2c1_set_clkt_tout i2c1_get_clkt_tout i2c_get_clkt_tout: i2c1_get_clkt_tout.c $(CC) -o i2c1_get_clkt_tout i2c1_get_clkt_tout.c i2c_set_clkt_tout: i2c1_set_clkt_tout.c $(CC) -o i2c1_set_clkt_tout i2c1_set_clkt_tout.c install: cp i2c1_get_clkt_tout /usr/local/bin/i2c1_get_clkt_tout cp i2c1_set_clkt_tout /usr/local/bin/i2c1_set_clkt_tout uninstall: rm -f /usr/local/bin/i2c1_get_clkt_tout rm -f /usr/local/bin/i2c1_set_clkt_tout clean: rm -f i2c1_set_clkt_tout i2c1_get_clkt_tout Build and install\nmake sudo make install Usage\n# read current clkt_tout: $ sudo i2c1_get_clkt_tout i2c1_get_clkt_tout: CLKT.TOUT = 1000 # set timeout to 1 second: i2c_set_clkt_tout 1000 "},{"uri":"https://pi4j.com/documentation/io-examples/spi/","title":"Serial Peripheral Interface (SPI)","tags":["SPI","MAX7219"],"description":"","content":"What is it? The Serial Peripheral Interface, abbreviated to SPI, is a bus system which enables communication between a main device (called “master”) and one or more secondary devices (called “slave”). A direct communication between all participants is not possible here, much more the master can choose at any time with which slave he would like to exchange data.\nIn order to address only one slave, a total of 3 signal lines are required, two of which are used for bidirectional data transmission and one as a clock generator for serial transmission. If further slaves are to be addressed, additional signal lines are required depending on the desired topology.\nUses In addition to communication between microcontrollers, SPI is also used to address many sensors and actuators. Similar to I²C, a large number of control commands and data can be transmitted in both directions with a relatively high clock rate over 3 lines. A particular advantage here is the support for “full duplex”, ie the simultaneous transmission of data in both directions.\nThe technical implementation is very simple and is also used, for example, to communicate with SD cards. The Nintendo Game Boy already used this protocol to connect several game consoles via the Game Boy Link Cable.\nAddressing As already mentioned in the first section, multiple slaves can be connected to SPI. The number of available SPI-buses depends on the hardware being used. On the Raspberry Pi, the standard SPI0 with two different slaves, uses what is called \u0026ldquo;Chip Select Pins\u0026rdquo;.\nWith the following command you can list the available interfaces:\n$ ls -l /dev/*spi* ls: cannot access \u0026#39;/dev/*spi*\u0026#39;: No such file or directory If none show up, you need to enable SPI with raspi-config:\n$ raspi-config Interface Options SPI Would you like the SPI interface to be enabled? Yes Now when you list the available interfaces, you should get a result like this:\n$ ls -l /dev/*spi* crw-rw---- 1 root spi 153, 0 Sep 11 09:58 /dev/spidev0.0 There is one interface that can be accessed in two ways:\n/dev/spidev0.0 drives CE0 Low /dev/spidev0.1 drives CE1 Low Additional Information Wikipedia SPI SPI pinout for Raspberry Pi Code example Initialize the Pi4J Context with a provider which supports SPI fully, e.g. the PiGpioSpiProvider. The minimal example would be:\nvar piGpio = PiGpio.newNativeInstance(); var pi4j = Pi4J.newContextBuilder() .noAutoDetect() .add( PiGpioSpiProvider.newInstance(piGpio) ) .build(); Depending on the type of GPIOs you need in your project this could be further extended to e.g.:\nvar piGpio = PiGpio.newNativeInstance(); var pi4j = Pi4J.newContextBuilder() .noAutoDetect() .add( PiGpioDigitalInputProvider.newInstance(piGpio), PiGpioDigitalOutputProvider.newInstance(piGpio), PiGpioPwmProvider.newInstance(piGpio), PiGpioI2CProvider.newInstance(piGpio), PiGpioSerialProvider.newInstance(piGpio), PiGpioSpiProvider.newInstance(piGpio) ) .build(); The following example is an extract of the CrowPi example project which includes a component to control an 8x8 LED matrix display with an MAX7219 driver chip which is controlled via SPI.\npublic class MAX7219 extends Component { // MAX7219: Internal Commands private static final byte CMD_SET_FIRST_ROW = 0x01; private static final byte CMD_DECODE_MODE = 0x09; private static final byte CMD_INTENSITY = 0x0A; private static final byte CMD_SCAN_LIMIT = 0x0B; private static final byte CMD_SHUTDOWN = 0x0C; private static final byte CMD_DISPLAY_TEST = 0x0F; /** * Width of MAX7219 LED matrix */ public static final int WIDTH = 8; /** * Height of MAX7219 LED matrix */ public static final int HEIGHT = 8; /** * Internal buffer to store the 8x8 matrix * A byte[] array is used as each of the 8 bits is used to represent a column */ protected final byte[] buffer = new byte[HEIGHT]; /** * Pi4J SPI instance */ protected final Spi spi; /** * Creates a new MAX7219 instance using the given SPI instance from Pi4J. * * @param spi SPI instance */ public MAX7219(Spi spi) { this.spi = spi; } /** * Clears the internal buffer without refreshing the display. * This means that the current contents of the displays are still being shown until {@link #refresh()} is called. */ public void clear() { Arrays.fill(buffer, (byte) 0); } /** * Flushes the internal buffer for all rows to the chip, causing it to be displayed. * The contents of the buffer will be preserved by this command. */ public void refresh() { for (int row = 0; row \u0026lt; HEIGHT; row++) { refreshRow(row); } } /** * Flushes the internal buffer for a single row to the chip, causing it to be displayed. * The contents of the buffer will be preserved by this command. * * @param row Row to be flushed */ protected void refreshRow(int row) { if (row \u0026lt; 0 || row \u0026gt;= HEIGHT) { throw new IllegalArgumentException(\u0026#34;Row must be an integer in the range 0-\u0026#34; + HEIGHT); } execute((byte) (CMD_SET_FIRST_ROW + row), buffer[row]); } /** * Specifies if the LED matrix should be enabled or disabled. * This will also setup the proper decoding mode and scan limit when enabling the chip. * * @param enabled LED matrix state (true = ON, false = OFF) */ public void setEnabled(boolean enabled) { if (enabled) { execute(CMD_SHUTDOWN, (byte) 0x01); execute(CMD_DECODE_MODE, (byte) 0x00); execute(CMD_SCAN_LIMIT, (byte) 0x07); } else { execute(CMD_SHUTDOWN, (byte) 0x00); } } /** * Enables or disables the testing mode of the LED matrix. * When enabled, all other options (including {@link #setEnabled(boolean)} are ignored and all LEDs are turned on. * To actually control the chip, the test mode MUST be disabled. * * @param enabled Test mode state (true = ON, false = OFF) */ public void setTestMode(boolean enabled) { execute(CMD_DISPLAY_TEST, (byte) (enabled ? 0x01 : 0x00)); } /** * Changes the desired brightness for the LED matrix. * This method expects an integer value within the range 0-15, with 0 being the dimmest and 15 the brightest possible value. * The whole display is affected by this command which gets immediately applied. * * @param brightness Desired brightness from 0-15 */ public void setBrightness(int brightness) { if (brightness \u0026lt; 0 || brightness \u0026gt; 15) { throw new IllegalArgumentException(\u0026#34;Brightness must be an integer in the range 0-15\u0026#34;); } execute(CMD_INTENSITY, (byte) brightness); } /** * Enables or disables the pixel at the given X/Y position within the internal buffer. * This change will not be visible until {@link #refresh()} or {@link #refreshRow(int)} gets called. * * @param x X position to change * @param y Y position to change * @param enabled Desired pixel state (true = ON, false = OFF) */ public void setPixel(int x, int y, boolean enabled) { // Ensure coordinates are within boundaries checkPixelBounds(x, y); // Generate bitmask and set/unset specific bit final byte mask = (byte) (1 \u0026lt;\u0026lt; (WIDTH - 1 - x)); if (enabled) { buffer[y] |= mask; } else { buffer[y] \u0026amp;= ~mask; } } /** * Retrieves the pixel at the given X/Y position within the internal buffer. * * @param x X position to change * @param y Y position to change * @return Current state of specified pixel (true = ON, false = OFF) */ public boolean getPixel(int x, int y) { // Ensure coordinates are within boundaries checkPixelBounds(x, y); // Generate bitmask and retrieve specific bit final byte mask = (byte) (1 \u0026lt;\u0026lt; (WIDTH - 1 - x)); return (buffer[y] \u0026amp; mask) != 0; } /** * Ensures the given X and Y coordinates are within the boundaries of this LED matrix. * An {@link IllegalArgumentException} will be thrown if outside. * * @param x X coordinate to check * @param y Y coordinate to check */ private void checkPixelBounds(int x, int y) { if (x \u0026lt; 0 || x \u0026gt;= WIDTH) { throw new IllegalArgumentException(\u0026#34;X must be an integer in the range 0-\u0026#34; + WIDTH); } if (y \u0026lt; 0 || y \u0026gt;= WIDTH) { throw new IllegalArgumentException(\u0026#34;Y must be an integer in the range 0-\u0026#34; + HEIGHT); } } /** * Helper method for sending a command to the MAX7219 chip with data. Communication happens over SPI by simply sending two pieces of * data, more specifically the desired command as a byte value, followed by the data as another byte value. * * @param command Command to be executed * @param data Data for the given command */ private void execute(byte command, byte data) { spi.write(command, data); } } "},{"uri":"https://pi4j.com/documentation/io-examples/serial/","title":"Serial (UART/RS232)","tags":["Serial"],"description":"","content":" As of version 3 of the Pi4J library, the serial methods have been marked as deprecated, and we advise to use the jSerialComm library, as discussed in #308: Remove serial support from Pi4J?. The example code below is still applicable, but serial support will be fully removed in later versions of Pi4J.\nGITHUB PROJECT: https://github.com/Pi4J/pi4j-example-components/blob/main/src/main/java/com/pi4j/catalog/applications/SerialGps_App.java\nWhat is it? Serial communication can be used to transfer data between different boards, devices, etc. Data is transfered bit-by-bit in a sequence, through a single wire from a transmitter (= TX) to a receiver (= RX). On the receiver side the bits are combined to bytes.\nWhen you need two-way communication, two wires are needed between RX and TX from both sides:\nThe communication between these two devices can happen in different ways:\nsimplex: one direction only without a message back to confirm the receiving half-duplex: devices can only send or receive at once full-duplex: both devices can send and receive at the same time Serial communication is done at a predefined speed which needs to be known on both sides, as both the sender and receiver need to handle the data at the same speed. This speed is called the \u0026ldquo;baud rate\u0026rdquo; with a value indicating the number of bits per second (bps). The most used speed is 9600 bps, but you can use lower (1200, 2400, 4800) or higher (19200, 38400, 57600, 115200) speeds, depending on the speed which can be handled reliably by the device.\nThe Pi has two built-in connections to GPIOs BCM number 14 (TX) and 15 (RX). Identical to the other GPIOs, they use 3.3V so make sure, when you connect other devices, the same voltage is used.\nFeel free to check the Kotlin DSL for Serial\nUart Types The following details are located in the Pi4 BCM2711-peripherals document. The BCM2711 device has six UARTs. One mini UART (UART1) and five PL011 UARTs (UART0, UART2, UART3, UART4, and UART5).\nMini UART Raspberry Pi GPIO14 and GPIO15 support operation as a mini UART.\n7-bit or 8-bit operation 1 start and 1 stop bit No parities Break generation 8 symbols deep FIFOs for receive and transmit SW controlled RTS, SW readable CTS Auto flow control with programmable FIFO level 16550 like registers Baudrate derived from system clock PL011 The fuller function PL011 uarts are available via GPIO Alternative Function Assignments. See Pi command raspi-gpio funcs.\nLimitations At the present time the PiGpio library supports only Parity None on any/all uarts. Any future additional UART functionality within the PiGpio library will require changes within the Pi4J code base.\nCode example The following example demonstrates how you can connect to a GPS module to read the data. This example is based on an example from the book \u0026ldquo;The Definitive Guide to Modern Java Clients with JavaFX\u0026rdquo; by Stephen Chin, Johan Vos and James Weaver. That example uses V1 of Pi4J with a listener provided by the library. In V2+ this listener is no longer provided but can easily be achieved with a Thread to handle the incoming data.\nThis example has been used by Mark Baird to create an application to record GPS tracks with the ArcGIS Maps SDK for Java. He has written a full explanation in a very nice post on the Esri ArcGIS blog.\nWiring The GPS module used in this example: NEO-7M.\nNEO-7M Raspberry Pi VCC Power 5V (e.g. pin 2) GND Ground (e.g. pin 6) RX UART TX, GPIO 15 TX UART RX, GPIO 16 In the readme of the coding example, you can find the description how you can test the GPS module in the terminal with gpsd.socket.\nInitialize the serial port First Pi4J needs to be initialized. Within this context we can then configure and open the serial port. As long as the serial port is open, we run a thread to handle the incoming data.\nvar console = new Console(); var pi4j = Pi4J.newAutoContext(); var serial = pi4j.create(Serial.newConfigBuilder(pi4j) .use_9600_N81() .dataBits_8() .parity(Parity.NONE) .stopBits(StopBits._1) .flowControl(FlowControl.NONE) .id(\u0026#34;my-serial\u0026#34;) .device(SERIAL_ADDRESS) .provider(\u0026#34;pigpio-serial\u0026#34;) .build()); serial.open(); // Wait till the serial port is open console.print(\u0026#34;Waiting till serial port is open\u0026#34;); while (!serial.isOpen()) { Thread.sleep(250); } // Start a thread to handle the incoming data from the serial port SerialReader serialReader = new SerialReader(console, serial); Thread serialReaderThread = new Thread(serialReader, \u0026#34;SerialReader\u0026#34;); serialReaderThread.setDaemon(true); serialReaderThread.start(); while (serial.isOpen()) { Thread.sleep(500); } serialReader.stopReading(); Serial reader The reader itself implements a Runnable and waits till data is available from the serial port. As the GPS module sends its data as readable String lines seperated by a line separator, we only need to handle the bytes which are higher than 32 (see the ASCII code table). All lower values are handled as line separators.\npublic class SerialReader implements Runnable { private final Console console; private final Serial serial; private boolean continueReading = true; public SerialReader(Console console, Serial serial) { this.console = console; this.serial = serial; } public void stopReading() { continueReading = false; } @Override public void run() { // We use a buffered reader to handle the data received from the serial port BufferedReader br = new BufferedReader(new InputStreamReader(serial.getInputStream())); try { // Data from the GPS is recieved in lines String line = \u0026#34;\u0026#34;; // Read data until the flag is false while (continueReading) { // First we need to check if there is data available to read. // The read() command for pigio-serial is a NON-BLOCKING call, // in contrast to typical java input streams. var available = serial.available(); if (available \u0026gt; 0) { for (int i = 0; i \u0026lt; available; i++) { byte b = (byte) br.read(); if (b \u0026lt; 32) { // All non-string bytes are handled as line breaks if (!line.isEmpty()) { // Here we should add code to parse the data to a GPS data object console.println(\u0026#34;Data: \u0026#39;\u0026#34; + line + \u0026#34;\u0026#39;\u0026#34;); line = \u0026#34;\u0026#34;; } } else { line += (char) b; } } } else { Thread.sleep(10); } } } catch (Exception e) { console.println(\u0026#34;Error reading data from serial: \u0026#34; + e.getMessage()); System.out.println(e.getStackTrace()); } } } Running the application on Raspberry Pi You can get the full working example from GitHub and run on a Raspberry Pi after you correctly connected a GPS module. As you can see in the output, each data line (starting with $GP...) is logged.\n[main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - \u0026lt;-- The Pi4J Project --\u0026gt; [main] INFO com.pi4j.util.Console - Serial Example project [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] ... [main] INFO com.pi4j.util.Console - Waiting till serial port is open [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - Serial port is open ... [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPVTG,,T,,M,2.349,N,4.351,K,A*2C\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGGA,143723.00,5054.02265,N,00301.10531,E,1,04,10.46,86.2,M,45.9,M,,*5C\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGSA,A,3,09,16,05,07,,,,,,,,,17.19,10.46,13.64*33\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGSV,2,1,06,05,33,304,20,07,67,101,21,09,39,079,29,11,38,228,20*7E\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGSV,2,2,06,16,11,030,24,20,63,283,*73\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGLL,5054.02265,N,00301.10531,E,143723.00,A,A*6A\u0026#39; "},{"uri":"https://pi4j.com/documentation/io-examples/1-wire/","title":"1-Wire","tags":["1-Wire"],"description":"","content":"What is it? Based on Wikipedia:\n1-Wire is a wired half-duplex serial bus that provides low-speed (16.3 kbit/s) data communication and supply voltage over a single conductor. It\u0026rsquo;s similar in concept to I2C, but with lower data rates and longer range. It is typically used to communicate with small inexpensive devices such as digital thermometers and weather instruments.\nReceive Data At this moment, 1-Wire is not supported by Pi4J, but there is work-in-progress, see draft pull request #435.\nA possible code-only approach is reading the kernel\u0026rsquo;s relevant sys files, for example:\nString devicePath = \u0026#34;/sys/bus/w1/devices/28-0316a2791cff/w1_slave\u0026#34;; try (BufferedReader br = new BufferedReader(new FileReader(devicePath))) { String line1 = br.readLine(); // e.g. \u0026#34;00 00 00 00 00 ... : crc=00 YES\u0026#34; String line2 = br.readLine(); // e.g. \u0026#34;00 00 00 00 00 t=12345\u0026#34; // Typically you look for \u0026#34;t=NNNNN\u0026#34; to get the temperature // Here, parse the integer after \u0026#34;t=\u0026#34; String tempStr = line2.split(\u0026#34;t=\u0026#34;)[1]; double tempC = Double.parseDouble(tempStr) / 1000.0; System.out.println(\u0026#34;Temperature: \u0026#34; + tempC + \u0026#34;°C\u0026#34;); } catch (IOException e) { e.printStackTrace(); } "},{"uri":"https://pi4j.com/architecture/pi4j-logo/","title":"The Pi4J Logo","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-logo\nThe Pi4J logo has been designed by Gerrit Grunwald and is nicely combines a raspberry pie with Duke, the Java Masqot.\n"},{"uri":"https://pi4j.com/blog/2025/20250625-java-21-not-working-on-zero-2/","title":"Java 21+ Not Working on Zero 2","tags":["Zero 2"],"description":"","content":"2025-06-25 by Frank Delporte\nDieter Holz reported an issue was experimenting with Pi4J V3 on a Raspberry Pi Zero 2. Because this version requires Java 21 or newer, he upgraded his OS to a newer Java version and found out that no Java code could be executed. He tried with both Java 21 and 24 and none of these worked correctly, although Java 17 runs without problems.\nThe same SD card with Java 24, which didn\u0026rsquo;t work on the Zero 2, worked perfectly on a Raspberry Pi 4. So what is happening under the hoods? What is the difference between these two boards causing this problem? Let\u0026rsquo;s dive in\u0026hellip;\nDifferences Between RPi Zero 2 and RPi 4 As the same SD card was used to test on two different boards, the problem has to be related to the board itself and not the software. I repeated the test as done by Dieter, and used the latest Azul Zulu version 24.30.13, based on OpenJDK 24.0.1.\nOn both boards, the Java version could be read without any issues:\n$ java -version openjdk version \u0026#34;24.0.1\u0026#34; 2025-04-15 OpenJDK Runtime Environment Zulu24.30+13-CA (build 24.0.1+9) OpenJDK 64-Bit Server VM Zulu24.30+13-CA (build 24.0.1+9, mixed mode, sharing) But trying to execute or compile the simplest \u0026ldquo;Hello World\u0026rdquo; code, resulted in errors on the Zero 2:\n$ java HelloWorld.java An exception has occurred in the compiler ((version info not available)). Please file a bug against the Java compiler via the Java bug reporting page (https://bugreport.java.com) after checking the Bug Database (https://bugs.java.com) for duplicates. Include your program, the following diagnostic, and the parameters passed to the Java compiler in your report. Thank you. java.lang.NoClassDefFoundError: com/sun/tools/javac/processing/JavacProcessingEnvironment$DiscoveredProcessors at jdk.compiler/com.sun.tools.javac.processing.JavacProcessingEnvironment.initProcessorIterator(JavacProcessingEnvironment.java:331) ... $ javac HelloWorld.java Exception in thread \u0026#34;main\u0026#34; java.lang.InternalError: Cannot find requested resource bundle for locale en_US at jdk.compiler/com.sun.tools.javac.util.JavacMessages.getBundles(JavacMessages.java:145) ... Let\u0026rsquo;s try to find the difference between the two boards by executing a few commands\u0026hellip;\nCommand RPi Zero 2 RPi 4 cat /proc/cpuinfo Raspberry Pi Zero 2 W Rev 1.0 Raspberry Pi 4 Model B Rev 1.2 uname -a Linux pizero2 6.12.25+rpt-rpi-v8 \u0026hellip; aarch64 GNU/Linux idem uname -m aarch64 aarch64 lscpu \u0026hellip; Model name: Cortex-A53 \u0026hellip; \u0026hellip; Model name: Cortex-A72 \u0026hellip; Bingo! lscpu shows a different type of ARM processor. Could this be the reason for this problem?\nChanges in Java 21 Thanks to my colleagues at Azul it immediately became clear it\u0026rsquo;s indeed the Cortex-A53 which causes Java to fail\u0026hellip;\nIn Java 21 the Just-In-Time (JIT) compiler has been improved, but this change doesn\u0026rsquo;t work correctly on the ARM Cortex-A53 processor as used in the Zero 2. This is another type of processor compared to, for instance, the Raspberry Pi 4 (Cortex-A72) and 5 (Cortex-A76).\nA bug has been reported in the OpenJDK project: [AArch64] Incorrect result of VectorizedHashCode intrinsic on Cortex-A53. At this moment, it\u0026rsquo;s already marked as \u0026ldquo;Resolved\u0026rdquo; and will be included in the update releases of July \u0026lsquo;25 for versions 21, 24, and 25.\nThe issue stems from the fact that the VectorizedHashCode intrinsic was implemented with assumptions about ARM64 processors that don\u0026rsquo;t hold true for the Cortex-A53 specifically. The Cortex-A53 has different microarchitectural characteristics compared to other ARM64 processors, and the vectorized hash code implementation doesn\u0026rsquo;t account for these differences.\nThis bug causes:\nIncorrect hash code calculations when the VectorizedHashCode intrinsic is used. ClassNotFoundException and other runtime failures because hash codes are fundamental to how the JVM manages classes, strings, and other objects. Spring Boot applications failing to start (as shown in the bug report) because the incorrect hash codes break class loading mechanisms. If you want to dive deep into the details of the JIT, you can read this technical overview of the intrinsics and vector optimization systems in the OpenJDK JIT compiler (C2).\nWorkaround As described on Running Java 21+ on Raspberry Pi Zero 2, a workaround is available to execute Java code until the fix is included in the next release:\njava -XX:+UnlockDiagnosticVMOptions -XX:-UseVectorizedHashCodeIntrinsic HelloWorld.java Hello World Compare Boards To help identify these kind of issues which behave differently on different types of Raspberry Pi boards, the Board Info Service has been extended with a Compare view where you can easily see the differences between two boards.\n"},{"uri":"https://pi4j.com/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/","title":"Welcome to Pi4J","tags":[],"description":"","content":"Welcome to Pi4J Latest release: V3.0.2 (2025-05-20, see Release Notes).\nThis project is intended to provide a friendly object-oriented I/O API and implementation libraries for Java Programmers to access the full I/O capabilities of the Raspberry Pi platform. This project abstracts the low-level native integration and interrupt monitoring to enable Java programmers to focus on implementing their application business logic.\nIf you immediately want to \u0026ldquo;dive\u0026rdquo; into Pi4J development, check these resources:\nPrepare a Raspberry Pi for Java development. Starter examples: Creating a single file application with JBang. For experienced Java developers: Creating an application with Maven or Gradle. Brief History The Pi4J Project was started in 2012, the same year the Raspberry Pi was introduced as a tool to provide Java developers a simple and familiar object-oriented interface library to access the low-level I/O capabilities of the Raspberry Pi including GPIO, I2C, SPI, PWM and Serial communications.\nThe Pi4j project has evolved in all these years as the whole Java eco-system and Raspberry Pi systems have been evolving. This resulted in the following main versions:\nV1.X: Deprecated, based on Java 8, later Java 11. V2.X.X: Completely reworked code base, based on Java 11. In 2.5.0, support for the Raspberry Pi 5 was added. Because of the new GPIO chip RP1, a new GPIO Provider was needed. See the this interview. V3.X.X: Based on Pi4J 2.8.0 and Java 21. Please read this blog post for more info. Project Mission/Goals The Pi4J Project\u0026rsquo;s mission is to provide a rich and powerful, yet simple to use, Java-friendly API library enabling programmatic access to the low-level hardware I/O capabilities of embedded platforms such as the Raspberry Pi.\n"},{"uri":"https://pi4j.com/tags/zero-2/","title":"Zero 2","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2025/20250507-start-program-with-desktop-icon/","title":"Starting with a Desktop Icon","tags":["UI"],"description":"","content":"2025-05-07 by Frank Delporte\nRichard Norrie created an oscilloscope with Pi4J and was looking for a way to start his application with a desktop icon. Unfortunately, he ran into a few issues as the icon led to \u0026ldquo;Java not found\u0026rdquo; error. This was likely due to environment variables not being properly set in the desktop launcher context.\nHere are the steps how this got fixed as you can see in this screenshot:\nEnsure Java is properly installed and the PATH is set system-wide: echo \u0026#39;export JAVA_HOME=/path/to/your/java\u0026#39; \u0026gt;\u0026gt; ~/.bashrc echo \u0026#39;export PATH=$JAVA_HOME/bin:$PATH\u0026#39; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc Create a desktop entry file (with .desktop extension) in ~/.local/share/applications/ or /usr/share/applications/: [Desktop Entry] Name=Oscilloscope Type=Application Exec=bash -ic \u0026#39;/path/to/your/script.sh\u0026#39; Icon=/path/to/an/icon.png Terminal=false Categories=Application The key parts here are:\nUsing bash -ic which ensures the bash environment (including PATH) is properly loaded. Using absolute paths for both the Exec and Icon entries. The script.sh should also use absolute paths to the Java jar file. Make both your shell script and the .desktop file executable: chmod +x /path/to/your/script.sh chmod +x /path/to/your/oscilloscope.desktop Your shell script should point to the full path of your .jar file: #!/bin/bash java -jar /full/path/to/oscilloscope.jar This approach ensures all necessary environment variables are properly set regardless of how the application is launched.\n"},{"uri":"https://pi4j.com/tags/ui/","title":"UI","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2025/20250211-welcome-java-21/","title":"Pi4J welcomes Java 21","tags":[],"description":"","content":"2025-02-11 by Frank Delporte\nThe development of the Pi4J library faced a decision point\u0026hellip;: \u0026ldquo;Should we stick to Java 11 for existing projects and old Raspberry Pi\u0026rsquo;s (with ARMv6), versus moving on and making use of better and more performant Java code with the latest Long Term Support (LTS) version?\u0026rdquo;\nWe actually wanted to move on to Java 22, as it brings a new way of interacting with C-code, thanks to JEP 454: Foreign Function \u0026amp; Memory API. As this is the core behavior of Pi4J to interact with the GPIOs, it would make it much easier to implement new ways to control electronics, as confirmed with a first test by Robert \u0026ldquo;Eitch\u0026rdquo;. But as Java 22 is not an LTS release, we won\u0026rsquo;t make this move yet.\nWe asked our users which minimal Java version we should use, but there was no one clear answer, as expected ;-) So with the core team we made a few decisions that are allowing us to bring the project to \u0026ldquo;the next level\u0026rdquo; and\u0026hellip; Java 21!.\nWe renamed the repository with the sources of Pi4J V2+ from pi4j-v2 to pi4j as it holds the sources of all V2 and future V3, V4,\u0026hellip; versions. The minimal supported Java version for future releases (V3 and newer) is 21. When the next LTS becomes available, we can easily bump again (to V4?). When critical bugs are found, we can still backport them to V2 and make a new release. This is also used in the OpenJDK development, as described in JEP 14: The Tip \u0026amp; Tail Model of Library Development. This documentation website got reviewed: To have the correct links to the renamed repository. Make it clear that V1 is deprecated and a separate repository. V2, V3, and future versions are based on the same repository. With this bump to Java 21, we are also preparing to more easily bump to the next LTS, which will be Java 25 in September 2025. Bumping to the latest LTS makes it possible to make use of many newer Java language and runtime improvements, simplify some of the code, etc. 3.0.0-SNAPSHOT of Pi4J is already available for testing from the Maven Repository if you enable snapshots in your pom-file. See Pi4J Downloads \u0026gt; Snapshot Archives for more info.\nMore info about V3 will be documented on the page What\u0026rsquo;s New in V3.\n"},{"uri":"https://pi4j.com/tags/maven/","title":"Maven","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2025/20250115-miami-jug/","title":"Pi4J presentation for Miami JUG","tags":["Maven"],"description":"","content":"2025-01-15 by Frank Delporte\nFrank Delporte was invited by the Miami JVM Group to present his journey into Java development on the Raspberry Pi. This video contains the part of the presentation that introduces Pi4J, some of its history, and its current state. We also look at a basic and more extended example, with a demo of a Vaadin and Spring Boot application controlling several electronic components.\nThis is the 30\u0026rsquo; version about Pi4J:\nThe full recording of 60\u0026rsquo; is here:\n"},{"uri":"https://pi4j.com/blog/2024/20241114-floss-weekly-podcast/","title":"Pi4J in Floss Weekly","tags":["Maven"],"description":"","content":"2024-11-14 by Frank Delporte\nFrank Delporte was a guest on the Floss Weekly podcast. He talked with Jonathan Bennett and David Ruggles about the Pi4J Project, the friendly Java libraries for the Raspberry Pi that expose GPIO, SPI, I2C, and other IO interfaces. Why would anyone want to use Java for the Pi? And what’s changed since the project started? You can find it in your favorite podcast app or watch the video below.\nShownotes and links to the other episodes are available on hackaday.com.\n"},{"uri":"https://pi4j.com/blog/2024/20241104-download-stats/","title":"Maven Downloads","tags":["Maven"],"description":"","content":"2024-11-04 by Frank Delporte\nAs an open-source project it\u0026rsquo;s very difficult to understand how much it\u0026rsquo;s used \u0026ldquo;in the wild\u0026rdquo;. The only stats we have, are the number of downloads from the Maven repository. So end of October I made a few screenshots to share here with the statistics including September 2024.\nThese are the numbers for all Pi4J libraries combined. Is this much? I have no clue as I can\u0026rsquo;t compare it with a similar project. ;-)\nWhat I notice is the quick pickup of a new version. For instance, for 2.6.1 which was released on 2024-07-29.\nAnother remarkable conclusion: there are a lot of Kotlin Pi4J users!\n"},{"uri":"https://pi4j.com/tags/signed/","title":"Signed","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2024/20240927-bits-bytes-signed-unsigned/","title":"Signed versus unsigned values","tags":["Signed","Unsigned"],"description":"","content":"2024-09-27, by Frank Delporte\nWhen using bits and bytes to control electronic components, the conversion from a byte to, e.g., logging output can be a bit confusing as Java uses signed values. This means a byte value has a range of -128 till 127, while you would expect 0 (0x00) till 255 (0xFF).\nFor example, the hex value 0x8F (10001111) is handled like this:\nvar b = (byte) Integer.parseInt(\u0026#34;10001111\u0026#34;, 2); System.out.println(\u0026#34;Byte value 10001111: \u0026#34; + b); // Output Byte value 10001111: -113 You can use Byte.toUnsignedInt(b) to get the expected, unsigned value:\nvar unsignedInt = Byte.toUnsignedInt(b); System.out.println(\u0026#34;Byte to unsigned integer: \u0026#34; + unsignedInt); // Output Byte to unsigned integer: 143 This gets explained more in detail in this blog post and this video:\n"},{"uri":"https://pi4j.com/tags/unsigned/","title":"Unsigned","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/bme280/","title":"BME280","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/bme680/","title":"BME680","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/bme688/","title":"BME688","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/bmp280/","title":"BMP280","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2024/20240517_bosch_sensor_gas_measurement/","title":"Bosch sensor gas measurement","tags":["BME280","BMP280","BME680","BME688"],"description":"","content":"2024-05-17, by Frank Delporte\nBosch has several sensors which are extremely small to measure temperature, humidity, pressure, and gas. We also have several example implementations documented on the Pi4J website:\nBME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang. BMP280 Sensor, example implementation by Thomas Aarts. LED Matrix with SPI MAX7219, work-in-progress for a weather station. Sensor drivers, project by Juraj Veverka. You can find easy-to-use boards with such a sensor, for instance, on:\nAdafruit SparkFun Important Information Regarding Gas Measurements On the Pi4J GitHub Discussion page, there is an interesting discussion going on about the BME688 gas sensor that I want to share here\u0026hellip; crogialli shared the following info:\nI\u0026rsquo;ve been using BME680 in my application for a year, and I am also implementing BME 688. It is entirely possible to read Temp, Pressure, Humidity and gas resistances from plain Java code (I do it, and I can submit my code for that, albeit I have an abstraction layer between the BME68X management and Pi4J so that the code could be not immediately usable). Readings for temp, pressure and humidity from BME68X are astonishingly accurate and quick.\nHowever, I want you to know that it is not possible to get sensible air-quality (gas) estimations in that way. You can get a gas sensor resistance reading, but it is entirely meaningless and random, as a matter of fact. It cannot be reconnected to any air quality measure without the Bosh Sensortec Libraries (see below).\nMoreover, I\u0026rsquo;ve been reading a BME680 gas sensor \u0026ldquo;manually\u0026rdquo; every 5 seconds by setting arbitrary heating patterns for a couple of years now. I\u0026rsquo;m pretty sure I have damaged the BME 680 MEMS gas sensor since current resistance readings are now very low (1..3K), whilst at the beginning, they used to be relatively higher (15K \u0026hellip;150K). The sensor has always been in the same protected ambient (a boiler room with some natural ventilation hosting a diesel-fueled burner).\nTo get a correct gas estimation and preserve the sensor\u0026rsquo;s life, the only way I know is to integrate BSEC 2.4.0.0 libraries from Bosch, which implement a few adaptive algorithms for sampling the gas estimates with specific (AI-Calibrated) sensor heating patterns and at specific instants, thus providing reliable indexes and safeguarding the MEMS device.\nIntegrating BSEC libraries poses a few challenges:\nThe library, written in C, is Bosch proprietary The source is not available; BSEC 2.4.0.0 is provided as a C binary library, statically linked It is unclear at the moment if they provide a 64bit binary for Raspberry Pi4 (I want to run on Rasbian 64) A Python wrapper exists, but not a Java one. I\u0026rsquo;m looking into developing a Java (or Groovy) wrapper for integrating BSEC 2.4.0.0 into my app. Should I be unable to wrap it in Java, I will likely implement a call to external C or Python code (disgusting but likely functional, provided that a solution to run on 64-bit Raspbian exists).\nBME68X sensors give exceptional results for their price. I advise avoiding messing with air quality if you don\u0026rsquo;t need it; if you do, you shall find a way to integrate BSEC libraries.\nBosch software Download API and Bosch Sensortec Environmental Cluster (BSEC) Software BME680 Software "},{"uri":"https://pi4j.com/tags/interview/","title":"Interview","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2024/20240425_interview_tom_aarts/","title":"Interview Tom Aarts","tags":["Interview","Pi4J"],"description":"","content":"2024-04-25, by Frank Delporte\nTom Aarts started contributing to the Pi4J project when he did his first commit in the pi4j-example-devices repository. At this moment, you can find example implementations for a long list of devices (see screenshot below), using V2 of Pi4J. While creating these implementations he found and fixed some missing pieces and bugs in the core library. See, for instance, this blog post about the ongoing PWM improvements for the Raspberry Pi 5. Furthermore, you can find Tom often in assisting users who filed a Pi4J V2 issue or started a discussion.\nLet\u0026rsquo;s learn more about him\u0026hellip;\nTom Aarts\nDevices implemented in pi4j-example-devices\nToms desk\nCan you introduce yourself? What is your history in software (Java) development?\nHi I\u0026rsquo;m Tom. My degree and career started in hardware. In 1971, I was working on HF transmitters that used vacuum tubes the size of your fist. By the eighties, I transitioned to firmware and software engineering.\nMy first Java involvement was at IBM in the 90\u0026rsquo;s when Java was first implemented on the AS400 to support the SOM (SystemObjectModel) architecture. This was the initial Java compiler, JIT and Garbage collector for the AS400. So although I was doing Java implementations, I interacted with these teams learning from them.\nThen next was WebSphere, implementing a distributed Java financial application. After this time, my work was in server firmware development and later hardware simulation. Although the languages being used were not Java, Java remained my preferred language to code any tools my work required.\nHow did you get involved in the Pi4J development?\nAs I neared retirement I looked for future activities of interest and selected Raspberry Pi to be one of those activities. At that time, Pi4J was V1 and I used it to use some I2C chips. When V2 was released, and I migrated my existing code to V2, I became more interested in the Pi4J implementation.\nThe direction in V2 was no longer to provide device specific implementations. I offered to make my existing device implementations public if they could assist new users to understand Pi4J. Ongoing, while assisting on the discussions, I used the chip in question to create an example to demonstrate a way to solve a question. Along the way, I supplied a couple Pi4J fixes and enhancements becoming more involved in maintenance of the Pi4J V2 code base.\nWhat are you focusing on in the Pi4J project?\nMy focus remains device support and examples to assist in issues and discussions. Also, helping with the work brought on by the new Raspberry Pi 5 to support the RP1 chip and bug fix and enhancements that result from various questions.\nHow do you use Pi4J in your own personal or company projects?\nI have a couple home projects for clocks and temperature, and a great number of prototype boards to support the various chips I implemented.\nTest setup\nTest setup\nTest setup\nYou answer a lot of questions in the Pi4J discussions and tickets. What is the most challenging part to be able to help users?\nUsers usually ask a specific question. The difficulty is determining what level of response they need. Based on some questions, the details that are given, and what is asked, I think this particular user is experienced and understands Pi4J and the Raspberry Pi so a technical response to just their question will be good.\nSome questions include details that make me conclude this person is new to Pi4J. So I need to think about what \u0026rsquo;newbie\u0026rsquo; mistakes could be made and provide a larger list of recommended steps and references of where more detail is available.\nIt are the questions that fall between these two categories that are more difficult to rapidly help the user. If I think they have more understanding, than they actually feel my response is too short and the user tries to accomplish what I suggested, and they make little or no progress and likely get frustrated. On the other hand if I think they are not experienced and give a great deal of information, the user then views it as a waste of their time as they already correctly completed what I suggest, and that certainly frustrates that user.\nHow do you think the Pi4J project can evolve further?\nBy adding more demonstration cases of Pi4J we can increase the interest and users. Pi4J doesn\u0026rsquo;t intend to implement IOT devices or supply Machine Learning applications, but we need these as reference projects. These should be simple but fully functional projects to demonstrate the capability of a Raspberry Pi using Pi4J. I believe this will bring in more users wanting to implement Home or Work IOT and do the implementation themselves. In addition, it can encourage STEM learning centers to use the Raspberry Pi and Pi4J as the Raspberry Foundation originally intended: a learning tool.\nWhat is the future of Java on embedded or small systems like the Raspberry Pi?\nI think Java will remain a valuable choice for these cases. Currently, there is emphasis on languages that prevent memory leaks and provide security, Java does both these items. I think we can assume the Java Runtime Environments will continue to improve performance and memory usage of Java. Also, there are very useful IDEs available for development, and of course Java portability.\n"},{"uri":"https://pi4j.com/tags/pi4j/","title":"Pi4J","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/linuxfs/","title":"LinuxFS","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/pwm/","title":"PWM","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2024/20240423_pwm_rpi5/","title":"PWM Hardware Support on RPi5","tags":["PWM","LinuxFS"],"description":"","content":"2024-04-23, by Tom Aarts\nThe next version of Pi4J (are now already in 2.5.2-SNAPSHOT) will add PWM support via a new provider linuxfs-pwm. The previous PWM PiGpio provider does not support the Raspberry Pi 5 RP1 chip. To use this new provider, changes are required in your pom.xml dependencies and Java code. The details of using this new provider are explained in the Pi4J documentation in Pulse Width Modulation. In this blog post, I want to provide extra details and an example implementation. This post reference changes when using the Bookworm OS on a Raspberry Pi 5. If you are using the linuxfs-pwm provider on a Raspberry Pi 4, consult the Pulse Width Modulation for config.sys and channel differences.\nWith this new version of Pi4J, additional improvements of the PWM integration are improved, based on this discussion \u0026ldquo;java.nio.file.AccessDeniedException: /sys/class/pwm/pwmchip0/pwm0/duty_cycle\u0026rdquo; on the Raspberry Pi Forum.\nWhat Changes Are Required Update pom.xml dependencies to add the linuxfs provider. Modify config.txt: after deciding which GPIO you want to present the PWM, the required dtoverlay statement must be added as described below. Reboot the Raspberry Pi5 to enable the config.txt modification. Modify the java application to use the new provider and set the address. Connect LED. Run the sample program. Update pom.xml You projects pom.xml requires an additional dependency.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-linuxfs\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Modify config.txt Modification of this files requires `sudo. In addition, while opening the file to edit OS settings, will display a warning that an error in this file might prevent successful reboot. Consider if you want to backup your system.\nThese are optional values to place into the file. Only one item should be added. Which one you use is based upon whether you want one or two GPIOs for PWM, and which GPIO(s) you want to use.\nThe selected value dtoverlay must be placed after the [all] statement.\nOne active PWM on GPIO 18, this is channel 2, so the address attribute will be 2: [all] dtoverlay=pwm Two active PWMs. First one on GPIO 18, this is channel 2 (= address attribute 2). The other active PWM on GPIO 19, this is channel 3 (= address attribute 3): [all] dtoverlay=pwm-2chan Two active PWM. First one on GPIO 12, this is channel 0 (= address attribute 0). The other active PWM on GPIO 13, this is channel 1 (= address attribute 1). [all] dtoverlay=pwm-2chan,pin=12,func=4,pin2=13,func2=4 For example, see screenshot on how to edit config.sys to set to a single PWM GPIO18:\nReboot Close your open applications. Enter: sudo shutdown -r. This will terminate all remaining applications and reboot. Modify the application Your system is now ready to use the linuxfs-pwm provider. Previously the application\u0026rsquo;s `PwmConfigBuilder address was the GPIO number, but now you need to use the channel number as the address parameter. package com.pi4j.test.devices.pwmTest; import com.pi4j.Pi4J; import com.pi4j.context.Context; import com.pi4j.io.pwm.Pwm; import com.pi4j.io.pwm.PwmType; import com.pi4j.util.Console; import java.util.Scanner; public class UserTest { private static Pwm pwm = null; private static Context pi4j; public static void main(String[] args) throws Exception { pi4j = Pi4J.newAutoContext(); var console = new Console(); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); System.out.println(\u0026#34;PI4J PROVIDERS\u0026#34;); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); pi4j.providers().describe().print(System.out); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); int address = 2; for (int i = 0; i \u0026lt; args.length; i++) { String o = args[i]; if (o.contentEquals(\u0026#34;-a\u0026#34;)) { // pin String a = args[i + 1]; address = Short.parseShort(a.substring(0), 10); i++; } else { console.println(\u0026#34; No valid Parm, -a address \u0026#34;); System.exit(42); } } initGPIO(address); System.out.println(\u0026#34;linuxfs pin after creation at duty_cycle 50 \u0026#34;); waitForInput(console); pwm.on(50, 2); System.out.println(\u0026#34;linuxfs pin after pin.on freq 2 \u0026#34;); waitForInput(console); pwm.off(); pwm.on(50, 10); System.out.println(\u0026#34;linuxfs pin after pin.on freq 10 \u0026#34;); waitForInput(console); pwm.off(); pwm.on(50, 50); System.out.println(\u0026#34;linuxfs pin after pin.on freq 50 \u0026#34;); waitForInput(console); pwm.off(); pwm.on(50, 1); System.out.println(\u0026#34;linuxfs pin after pin.on freq 1\u0026#34;); waitForInput(console); System.out.println(\u0026#34;linuxfs pin call pwm.shutdown \u0026#34;); waitForInput(console); pwm.shutdown(pi4j); System.out.println(\u0026#34;linuxfs pi4j call pi4j.shutdown \u0026#34;); waitForInput(console); pi4j.shutdown(); // Wait a bit for shutdown Thread.sleep(2000); } private static int waitForInput(Console console) { int rval = 0; Scanner scan = new Scanner(System.in); console.println(\u0026#34;Hit any key to continue\u0026#34;); scan.next(); return (rval); } private static void initGPIO(int address) { var configPwm = Pwm.newConfigBuilder(pi4j) .address(address) .pwmType(PwmType.HARDWARE) .provider(\u0026#34;linuxfs-pwm\u0026#34;) .initial(50) .frequency(1) .build(); try { pwm = pi4j.create(configPwm); } catch (Exception e) { System.out.println(\u0026#34;Error in initGPIO \u0026#34; + e.getMessage()); e.printStackTrace(); } } } Connect LED Use appropriate Resistor in LED Cathode path. Connect Cathode lead to ground, Anode lead to GPIO18.\nTo calculate the resistor size, you can use this LED Series Resistor Calculator by DigiKey.\nRun sample program The example program can be called passing the parameter -a for the address, for example, in this configuration -a 2. But the program defaults to address 2. This means no parameter is required with this example when using dtoverlay=pwm.\n"},{"uri":"https://pi4j.com/blog/2024/20240419_interview_robert_von_burg/","title":"Interview Robert von Burg","tags":["Interview","Pi4J"],"description":"","content":"2024-04-19, by Frank Delporte\nThe Pi4J project has two important Roberts. The first one is Robert Savage (living in the US), who started the Pi4J development. You can read more about him and the reason Pi4J was created in this interview on Foojay. He also created V2 of Pi4J, but hasn\u0026rsquo;t been involved a lot in the project since its release. Luckily, we have another Robert in the Pi4J team! Robert von Burg (living in Switzerland), also known as Eitch, is the main maintainer now of the Pi4J V2 sources and takes care of the releases.\nLet\u0026rsquo;s learn more about him\u0026hellip;\nCan you introduce yourself? What is your history in software (Java) development?\nMy name is Robert von Burg. I\u0026rsquo;ve started programming in 1998 learning a bit of C, but quickly moved to Java, which became my favourite language. I first worked on programming workflow control systems, taking orders from ERP systems, and controlling the shop floor by communicating with PLCs, e.g. Siemens using TCP/IP. Later i worked a bit on enterprise clinical information systems using Java Enterprise Beans, and it\u0026rsquo;s ecosystem. For the last decade I\u0026rsquo;ve been working at Atexxi, of which I\u0026rsquo;m a co-owner and founder. We are developing our eSyNet platform, with which we enable hospitals, pharmacies and elderly/nursing homes to digitize their drug logistics. Our platform is software based, but could not work without our electronic cabinets and accessories, with which the users of our system interact and thus allow to track inventory. Our goal is to unburden nurses, and move the administrative work surrounding drug logistics of nurses to the pharmacy.\nRobert von Burg\neSyBox using pi4j to communicate with the Raspberry Pi\u0026#39;s I2C bus\neSyBox slot detection in action\nHow did you get involved in the Pi4J development?\nFor our electronic cabinets we use Raspberry Pis as the embedded platform to communicate with our custom PCBs using I2C. As we want to use the same programming language and domain model on the server and the cabinets, we looked for a Java library giving us access to the Raspberry Pi\u0026rsquo;s I/Os. Thus, the Pi4J project was selected. During our use we detected a bug, and since the Pi4J maintainer was a little busy, I offered to send a merge request for the fix. Over time, this lead to more involvement with the core project.\nWhat are you focusing on in the Pi4J project?\nMy focus is on code review and testing of GPIO and I2C interfaces, as these are the interfaces where I have a certain amount of understanding.\nDo you use Pi4J in any personal projects?\nYes, I use it for a bit of LED and power outlet control.\nDo you think Java on Raspberry Pi is a valid choice for business use?\nAbsolutely. Thanks to the community, of which Azul has done a lot, we have a robust JVM on the Raspberry Pi, and we can stay in our domain model on the server and the embedded systems, which makes developing the software easier.\nHow do you think the Pi4J project can evolve further?\nWe are focusing on making the API easier to understand and use, make it work on the different Raspberry Pi versions and then help the community create a standard suite of components to communicate with different hardware which people use in their projects. This makes it easier for newcomers to start using Java on the Raspberry Pi and thus strengthen the Java community as a whole.\nWhat is the future of Java on embedded or small systems like the Raspberry Pi?\nThese devices, as they become more and more powerful with each generation, make it easier to implement more and more features at home. If we think how people use them to extend their home networks for security, media playback, or home automation, I see a bright future. Our goal with the Pi4J project is to make it as easy as possible to onboard newcomers.\n"},{"uri":"https://pi4j.com/tags/i2c/","title":"I2C","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2024/20240418_i2c_improvements/","title":"Ongoing I2C Improvements","tags":["Pi4J","I2C"],"description":"","content":"2024-04-17, by Frank Delporte\nRobert von Burg is working on improvements of the I2C implementation in Pi4J in preparation for the next release. The changes are in pull request #351. It\u0026rsquo;s still work-in-progress but will bring these improvements:\nNew I2C.execute(Callable) method to allow to atomically execute multiple I2C calls in a thread in a safe way. New I2C.writeRead(byte[], byte[]) method to atomically perform a write, immediately followed by a read on the I2C bus. Fix an issue where the LinuxFsI2CBus was closed when closing an I2C device. This can lead to errors as another device might still be open on the same bus, and an operation on the underlying RandomAccessFile would lead to exceptions. Fix a workaround that required an I2C.read() on a newly created LinuxFsI2C device, if the first call was an ioctl. The device was not selected prior to the ioctl call. Additional code cleanup and more to come\u0026hellip; This kind of methods is hard to test in unit tests as they interact with real components and need to handle the data and I2C devices depending on the interaction. As a solution, Robert is using a test project that has an implementation for an OLED display over I2C, using these commands.\n"},{"uri":"https://pi4j.com/blog/2024/20240417_led_matrix_max7219_spi_web/","title":"LED Matrix with SPI MAX7219","tags":["Pi4J","SPI","MAX7219","BME280"],"description":"","content":"2024-04-18, by Frank Delporte\nRoberto Marquez shared a project with us that uses Java to interface with a MAX7219 SPI device to control an LED matrix. It\u0026rsquo;s inspired by the blog Raspberry Pi and SPI 8×8 LED matrix example with Java and Pi4j, but differs in that it is Web-enabled via Spring Boot. This project is the starting point to create a weather station in combination with the BMP280, see BME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang.\nWiring diagram\nDefinition of the number 8 for the LED matrix\nWhile working on his project, Roberto contributed extra LED character definitions for the Pi4JLedMatrixSpi.java single-file application in the Pi4J V2 JBang project.\nDemos Wiring This demo project uses:\nRaspberry Pi 2 Model B V1.1 8x8 LED Matrix with Max7219 SPI Connections:\nDIN -\u0026gt; blue -\u0026gt; MOSI -\u0026gt; header 19 CS -\u0026gt; purple -\u0026gt; CE0 -\u0026gt; header 24 CLK -\u0026gt; white -\u0026gt; SCLK -\u0026gt; header 23 VCC -\u0026gt; 5V -\u0026gt; header 2 GND -\u0026gt; ground -\u0026gt; header 9 Project and Code Check the README in the project sources of Roberto for more info.\n"},{"uri":"https://pi4j.com/tags/max7219/","title":"MAX7219","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/spi/","title":"SPI","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2024/20240318_interview_alexander_liggesmeyer/","title":"Alexander Liggesmeyer and RPi5","tags":["Interview","Pi4J"],"description":"","content":"2024-03-18, by Frank Delporte\nInterview with Alexander Liggesmeyer about Pi4J for Raspberry Pi 5 Today, version 2.5.0 of Pi4J got released with many changes, fixes and improvements. The most important one being support for the Raspberry Pi 5. Short after the release of this new board, several issues were raised on GitHub as Pi4J was not compatible. The Raspberry Pi 5 uses a completely new way to interact with the GPIOs: the RP1 chip. Thanks to this chip, GPIO, SPI, I2C, USB, ethernet,\u0026hellip; are seperated from the SoC to make it easier to develop newer boards. But this new approach wasn\u0026rsquo;t supported by the PiGpio library used in Pi4J V2\u0026hellip; Until Alexander Liggesmeyer took up the challenge to find a solution!\nThanks Alexander for your amazing work! Can you introduce yourself?\nI’m Alexander, and I’m currently doing a PhD at Saarland University’s HCI Lab. The research chair is working in the area of human computer interaction, which also often involves prototyping hardware.\nWhat is your interest in the Pi4J project and how are you using it?\nI first used it to develop a Cocktail mixing machine, whose software is based on Spring Boot. Spring Boot is a well-known Java framework for developing APIs. Pi4J allows me to control the Raspberry Pi\u0026rsquo;s GPIO interfaces directly from Java.\nWhen you discovered that Pi4J wasn’t compatible with this new chip, what made you decide to dive into the problem and add a new provider?\nI got the new Raspberry Pi 5 and ran a few applications on it. I saw that the CocktailPi application which could take about 60 seconds to start on a Raspberry Pi 4, can now start in less than 15 seconds. So I wanted to use the new Raspberry. Unfortunately, Pi4J wasn\u0026rsquo;t yet compatible with the new platform. I also saw that nobody was actively working on changing this, so I thought, why shouldn\u0026rsquo;t I do that myself? I\u0026rsquo;m actively using this library and wanted a feature that it hasn\u0026rsquo;t got yet. The library is open source and one of the advantages of that is that everybody can contribute. So why not do that? In the end, everybody profits.\nThis new provider is backwards compatible with earlier Raspberry Pi boards, how did you achieve this?\nThe new provider interfaces with LibGpioD, the library directly interacting with Gpio devices. I didn\u0026rsquo;t dig into how it actually manipulates the gpiochip device files, but I don\u0026rsquo;t think that they differ significantly (if at all) between Raspberry Pi versions. This is more something on the operating system level. The only thing the provider needs to do is find the correct gpiochip device. On the Raspberry Pi, this device always contains the name pinctrl in its name, so finding it is straightforward.\nAn OOS-project can only improve thanks to contributions of the community. Was it easy to understand how to add functionality to the Pi4J project? How can the code or website be improved to attract more contributors?\nI think Pi4J is very well documented. Adding a new provider was a bit tricky, since I needed some libraries that were not part of the builder Docker images initially. But this could be solved by cloning and updating the builders as well. The only thing that I see could be improved is making the link to Slack more prominent.\nHow do you see the future of Java on embedded devices like the Raspberry Pi?\nIt depends on what a person wants to achieve. I personally like to use Python to develop small prototypes. For larger projects, I prefer type-safe programming languages because they already prevent most type errors at compile time. Java requires the developer to add the type of a variable every time it is defined, which adds to readability. On the other hand, Python does not force the developer to add type hints, leading to many developers not adding them. This makes refactoring code harder and more prone to errors.\n"},{"uri":"https://pi4j.com/blog/2022/20221128_led_strip_with_jbang/","title":"LED strip with Pi4J and JBang","tags":[],"description":"","content":"2022-11-28, by Robert von Burg\nIntro In an earlier post, JBang and Pi4J were used to control a LED and button connected to a Raspberry Pi.\nThis week Robert von Burg, one of the main contributors of the Pi4J project, shared on Mastodon another project where a LED strip is controlled via I2C.\nThis is the result, notice the Foojay.io startup artwork 😉\nWiring The Raspberry Pi in the video is attached to a custom PCB used by Robert in medical cabinets.\nThis PCB contains a few different connectors:\nAn 8 port I2C multiplexer for connecting up to 8 additional I2C devices, thus nesting I2C buses. An 8 port 1-Wire over I2C bridge to connect 8 1-Wire buses over I2C. In the middle of the board is an extension of the Raspberry Pi\u0026rsquo;s I2C bus. The LED strip itself is connected to a custom PCB with a PIC16F18344 from Microchip. This chips firmware communicates with the LED, allowing to be configured over I2C. For a simple Raspberry Pi-only setup, connect the wires of the LED strip to:\n5V Ground GPIO 2, physical pin 3, I2C data (see https://pinout.xyz/pinout/i2c) In this case, make sure to only use a short LED strip, as the board can not provide enough power for a large number of LEDs.\nCode As this is a JBang project, all the dependencies and code are combined into one single file.\nThe structure of this file is:\n. \u0026ldquo;Trick\u0026rdquo; the system to run this file with JBang using the comment in the first line . Tell JBang which dependencies are needed with the //DEPS \u0026hellip; comment lines . And the rest is just a normal Java class\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? //DEPS org.slf4j:slf4j-api:2.0.3 //DEPS org.slf4j:slf4j-simple:2.0.3 //DEPS com.github.lalyos:jfiglet:0.0.8 //DEPS com.pi4j:pi4j-core:2.2.1 //DEPS com.pi4j:pi4j-plugin-raspberrypi:2.2.1 //DEPS com.pi4j:pi4j-plugin-pigpio:2.2.1 //DEPS com.pi4j:pi4j-plugin-linuxfs:2.2.1 import com.github.lalyos.jfiglet.FigletFont; import com.pi4j.Pi4J; import com.pi4j.context.Context; import com.pi4j.io.i2c.I2C; import com.pi4j.io.i2c.I2CConfig; import com.pi4j.io.i2c.I2CProvider; class LedStrip { static final byte ADDR_LED_STRIP = 0x48; static final byte CMD_COLOR = 0x01; static final byte CMD_CONTRAST = 0x02; static final byte CMD_PATTERN = 0x03; static final byte CMD_PTR_GRB_LED_1 = 0x10; static final byte CMD_PTR_GRB_LED_2 = 0x13; static final byte CMD_PTR_GRB_LED_3 = 0x16; static final byte CMD_PTR_GRB_LED_4 = 0x19; static final byte PATTERN_ON = (byte) 0xFF; static final byte PATTERN_OFF = 0x00; static final byte PATTERN_BLINK_1S = (byte) 0xAA; static final byte PATTERN_BLINK_2S = (byte) 0xCC; static final byte PATTERN_BLINK_4S = (byte) 0xF0; static final byte COL_A_AZURE = 0x41; static final byte COL_B_BLUE = 0x42; static final byte COL_C_CYAN = 0x43; static final byte COL_D_DARK = 0x44; static final byte COL_F_FUSCHIA = 0x46; static final byte COL_G_GREEN = 0x47; static final byte COL_L_LIME = 0x4C; static final byte COL_M_MAGENTA = 0x4D; static final byte COL_O_ORANGE = 0x4F; static final byte COL_R_RED = 0x52; static final byte COL_S_SPRING = 0x53; static final byte COL_V_VIOLET = 0x56; static final byte COL_W_WHITE = 0x57; static final byte COL_Y_YELLOW = 0x59; static final byte[] COLORS = new byte[] {COL_A_AZURE, COL_B_BLUE, COL_C_CYAN, COL_D_DARK, COL_F_FUSCHIA, COL_G_GREEN, COL_L_LIME, COL_M_MAGENTA, COL_O_ORANGE, COL_R_RED, COL_S_SPRING, COL_V_VIOLET, COL_W_WHITE, COL_Y_YELLOW}; public static void main(String... args) throws Exception { System.out.println(FigletFont.convertOneLine(\u0026#34;Hello foojay.io!\u0026#34;)); Context pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j).bus(1).device(0x48).build(); try (I2C ledStrip = i2CProvider.create(i2cConfig)) { ledStrip.writeRegister(CMD_COLOR, COL_W_WHITE); Thread.sleep(10); ledStrip.writeRegister(CMD_CONTRAST, 0x50); Thread.sleep(10); ledStrip.writeRegister(CMD_PATTERN, PATTERN_ON); Thread.sleep(10); // cycle all colors int green = 0; int red = 0; int blue = 0; while(true) { if (red \u0026lt; 254) { red++; } else if (green \u0026lt; 254) { green++; } else if (blue \u0026lt; 254) { blue++; } else { break; } ledStrip.writeRegister(CMD_PTR_GRB_LED_2, new byte[] {(byte) green, (byte) red, (byte) blue}); Thread.sleep(10); } // turn all off ledStrip.writeRegister(CMD_PATTERN, PATTERN_OFF); } } } Conclusion The Raspberry Pi, Pi4J and JBang are a perfect combination to experiment with electronics! Give it a try!!!\n"},{"uri":"https://pi4j.com/blog/2022/20221117_kotlin_on_raspberrypi/","title":"Kotlin on the Raspberry Pi","tags":[],"description":"","content":"2022-11-17, by Muhammad Hashim\nIntro Pi4J is considered the project that brought the JVM to the RaspberryPi.\nIt has been up for more than a decade allowing developers to write sophisticated, high-level, yet simple software on the RaspberryPi.\nAnd we’re glad to make it even more simpler and powerful!\nFor quite some years now Kotlin has been a most welcome language in the JVM ecosystem and the modern development toolchain.\nMany factors led to this great reality, most notable to me is Kotlin’s non-disruptive integration and seamless developer experience.\nEnough reasons for us to bring it over to the RaspberryPi Community!\nPi4J-Kotlin Our latest project, Pi4J-Kotlin, provides a Kotlin DSL for the already-mature \u0026amp; capable Pi4J V2+ API. You can take full advantage of Kotlin on the RaspberryPi and write even more capable and concise code for your projects. Blink if you can hear me\nA blinking LED example is a benchmark for code simplicity (at least for me, just pretend). Here’s how to blink with Pi4J-Kotlin:\nfun blink() = digitalOutput(22).run { while (true) { toggle() sleep(500) } } We also have a minimal example to get you started with more components.\nDeclarative API All you have to do to access everything-RaspberryPi is to use the pi4j block:\npi4j { // beautiful code goes here } Here, you created a Pi4J Context that will take care of loading the right Platform and Providers. It will also automatically shutdown the Context after you finish the block. That’s right you no longer have to worry about opening or closing doors; you don’t have time for that!\nPlease never mind my bitter alter ego and let’s discover some other exciting APIs: Using the digitalInput function you can easily create and customise your “pin” using this intuitive DSL:\ndigitalInput(address = 24) { name(“Button”) pull(PULL_DOWN) debounce(3000L) } In the same fashion, Analog and PWM get their fair share of sweetness:\nanalogOutput(24).run { whenInRange(0..5) { // fires when value is in the supplied range } whenOutOfRange(0..5) { // fires when value is not in the supplied range } onMin(0..5) { // fires when value changes to the minimum of the range } onMax(0..5) { // fires when value changes to the maximum of the range } } And of course we would take full advantage of the intuitive \u0026amp; inlined lambdas of Kotlin to create APIs like these:\nlisten { … } onLow { … } onHigh { … } Be it Digital or Analog IO you’ll find a little API that makes life even more convenient for you (as if what you had wasn’t already enough). Confused as you are, you might want to check the full documentation on these new APIs and lots more.\nThe story doesn’t end There are still more DSLs on their way for communication protocols and standards like SPI, I²C and more!\nTell us what you think Try it out! Tell us what you think and give us some ideas! Here is the GitHub Repository.\n"},{"uri":"https://pi4j.com/blog/2022/20220113_javafx_pi4j_template/","title":"Getting Started Template","tags":[],"description":"","content":"2022-01-13, by Frank Delporte\nIntro The Pi4J project wants to be the starting point for everyone who wants to use Java on the Raspberry Pi, being it a headless, JavaFX-user interface and/or GPIO-controller project.\nPi4J is intended to provide a friendly object-oriented I/O API and implementation libraries for Java Programmers to access the full I/O capabilities of the Raspberry Pi platform. This project abstracts the low-level native integration and interrupt monitoring to enable Java programmers to focus on implementing their application business logic.\nDieter Holz (FHNW University) and Robert von Burg (strolch.li) created a template project which is now part of the Pi4J example repositories. This project makes it even easier to get started and aims to:\nProvide a clear step-by-step how to prepare your Raspberry Pi Provide multiple test and start applications Explain the use of a MVC-model (Model-View-Controller) to clearly split data, actions and user interface Explain the use of JUnit test Sources and info Please check the README of the sources of the project for a full description of the setup process of the Raspberry Pi and to fully understand the example applications and the MVC-model. This page is only intended to give you a quick overview.\nExample applications HelloFX A simple application to test if the JavaFX libraries are installed correctly. Should not be used as a template for one\u0026rsquo;s own JavaFX applications.\nWiring The two other example applications use an LED and a button. These must be wired as is shown in the following diagram:\nMinimalPi4J The MinimalPi4j application is a Pi4j only application without a GUI. This application is also only used to test the setup and can be deleted after testing.\nPressing the button should generate a message in the console.\nOnce the Pi4J setup has been tested, MinimalPi4J can be deleted.\nTemplateApp This application shows the interaction between a JavaFX based Graphical User Interface (GUI) and the Raspberry Pi connected sensors and actuators, the Physical User Interface (PUI).\nThis application is to be used as a template for one\u0026rsquo;s own applications. This includes the existing test cases.\nYou should first get to know and understand the example. For your own applications you should then copy the TemplateApp and modify it for your project, however without violating the rules of the MVC concept.\nTemplatePUIApp The MVC concept should also be used for applications without a GUI.\nWhen developing PUI only applications, or when adding the GUI later, then one should use the TemplatePUIApp as template.\nThe MVC concept The classic Model-View-Controller concept contains in addition to the starter class at least 3 more classes. The interaction is clearly defined:\nThis way the GUI and PUI are completely separated from each other, i.e a GUI button to turn an LED on has no direct access to the LED component of the PUI. Instead the GUI button triggers a corresponding action in the controller which then sets the on state property in the model. The PUI listening on this state then turns the actual LED on or off.\nGUI and PUI work with the same identical controller and thus also the same identical model.\nIn the MVC concept, every user interaction traverses the exact same cycle:\nConclusion You can use the same architecture (MVC) to implement a JavaFX-based GUI, a PUI attached to a Raspberry Pi, and integrate both in a clean, modular way.\n"},{"uri":"https://pi4j.com/tags/1-wire/","title":"1-Wire","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/1602a/","title":"1602A","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/ads1115/","title":"ADS1115","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/ads1256/","title":"ADS1256","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/annotated-provisioning/","title":"Annotated provisioning","tags":[],"description":"","content":" To simplify the initial V2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations\nNext to the declarative approach, Java annotations are available for the configuration of I/O provisioning instead of the hard-coded approach offered in V1.\nThis implementation still needs to be further fine-tuned and unified somehow to make things cleaner and more straightforward, but would provide a way to initialize a I/O for instance like this:\n@Register(0) @Address(\u0026#34;my.digital.input.pin.zero\u0026#34;) @Name(\u0026#34;My Digital Input Pin\u0026#34;) @Debounce(300000) // microseconds @WithProvider(type=PiGpioDigitalInputProvider.class) private DigitalInput input; "},{"uri":"https://pi4j.com/tags/bh1750/","title":"BH1750","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/bmp180/","title":"BMP180","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/button/","title":"Button","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/buzzer/","title":"Buzzer","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/camera/","title":"Camera","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/crowpi/","title":"CrowPi","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/dac8552/","title":"DAC8552","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/dependency-injection/","title":"Dependency injection","tags":[],"description":"","content":" To simplify the initial V2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations\nAlong with the annotated I/O configuration the ability to support I/O provisioning via dependency injection also makes a lot of sense. There is some basic brute-force stuff working but this needs more work to make this a compatible implementation for Spring or CDI.\n@Inject private Context pi4j; // register a digital input listener to listen for any value changes on the digital input pin @Register(DIGITAL_INPUT_PIN_ID) private DigitalStateChangeListener changeListener = event -\u0026gt; System.out.println(\u0026#34; (LISTENER #1) :: \u0026#34; + event); // setup a digital input event listener to listen for any value changes on the digital input // using a custom method with a single event parameter @OnEvent(DIGITAL_INPUT_PIN_ID) private void onDigitalInputChange(DigitalStateChangeEvent event){ System.out.println(\u0026#34; (LISTENER #2) :: \u0026#34; + event); } "},{"uri":"https://pi4j.com/tags/dht22/","title":"DHT22","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/digital-input/","title":"Digital Input","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/digital-output/","title":"Digital Output","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/fatjar/","title":"FatJAR","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/gpiod/","title":"GpioD","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/gradle/","title":"Gradle","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/htu21d/","title":"HTU21D","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/intellij-idea/","title":"IntelliJ IDEA","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/is31fl3731/","title":"IS31FL3731","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/java/","title":"Java","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/javac/","title":"Javac","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/javafx/","title":"JavaFX","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/jbang/","title":"JBang","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/joystick/","title":"Joystick","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/joystick-analog/","title":"Joystick Analog","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/lcd-display/","title":"LCD Display","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/led/","title":"LED","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/led-button/","title":"LED Button","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/led-matrix/","title":"LED Matrix","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/led-strip/","title":"LED Strip","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/mcp23008/","title":"MCP23008","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/mcp23017/","title":"MCP23017","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/mcp3008/","title":"MCP3008","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/mcp4725/","title":"MCP4725","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/library-path/","title":"Native Library Path","tags":[],"description":"","content":"Overview Some Pi4J plugins, such as the Pi4J PiGpio Provider plugin, depend on native JNI libraries to communicate with the underlying system. By default Pi4J embeds these native libraries as resources inside the plugin\u0026rsquo;s JAR file. At runtime Pi4J extracts the native library into a temporary directory so the JVM can load the library from the filesystem. Upon termination the temporary file is automatically removed.\nThis automatic extration behavior works well for most users; however, there are certain edge cases where this may fail. On failure, its common to see a UnsatisfiedLinkError on startup of your application or when you create a Pi4J context. Edge cases such as the following may require customization of the runtime to deal with native library loading.\nSystems that do not support a writable temporary directory (/tmp) may encounter the UnsatisfiedLinkError and fail to load the native library. Systems with very strict security policies may encounter the UnsatisfiedLinkError and fail to load the native library if unable to extract the resource from the JAR at runtime. Users attempting to use Pi4J under Android may also experience the UnsatisfiedLinkError and fail to load the native library. Explicitly Define the Library Path In the event of a failure to extract and load the embedded native library from the JAR file at runtime, a user can override this default behavior by defining the system property: pi4j.library.path.\nUsage: pi4j.library.path=(system|/some/directory) Values: Property Value Description system The default system defined library path for the JVM (java.library.path) will be used to resolve the native libraries. local Native libraries will be resolved in the same local directory as the plugin JAR file on the file system. absolute file path(/some/directory) This user defined library path (absolute filesystem path) will be used to resolve the native libraries. Examples: The pi4j.library.path system property can be assigned in the command line used to launch your Java application using the -D flag.\njava --Dpi4j.library.path=\u0026#34;system\u0026#34; ... -or- java --Dpi4j.library.path=\u0026#34;local\u0026#34; ... -or- java --Dpi4j.library.path=\u0026#34;/some/directory\u0026#34; ... The pi4j.library.path system property can be assigned in your code at startup and prior to creating a Pi4J Context.\nSystem.setProperty(\u0026#34;pi4j.library.path\u0026#34;, \u0026#34;/some/directory\u0026#34;); -or- System.setProperty(\u0026#34;pi4j.library.path\u0026#34;, \u0026#34;system\u0026#34;); -or- System.setProperty(\u0026#34;pi4j.library.path\u0026#34;, \u0026#34;local\u0026#34;); For more details about the native library loading behavior, please see the NativeLibraryLoader.java class: https://github.com/Pi4J/pi4j/blob/master/libraries/pi4j-library-pigpio/src/main/java/com/pi4j/library/pigpio/util/NativeLibraryLoader.java\nWhere To Get The Native Libraries The Pi4J native libraries can be obtained by extracting the architecture specific libpi4j-xxx.so file from the plugin JAR file\u0026rsquo;s resources.\nAdditionally, the Pi4J native libraries are published as independant artifacts in the Maven Repository: https://oss.sonatype.org/#nexus-search;quick~pi4j-library-pigpio\n"},{"uri":"https://pi4j.com/tags/pcf8575/","title":"PCF8575","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/pcf8591/","title":"PCF8591","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/pi4j-os/","title":"Pi4J OS","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/pigpio/","title":"PiGpio","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/pir/","title":"PIR","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/pixelblaze/","title":"Pixelblaze","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/plugins/","title":"Plug-ins","tags":[],"description":"","content":"The goal of Pi4J V2+ is to provide a solid base with all required \u0026ldquo;minimal functionality\u0026rdquo; while at the same time, promote third-party development and extensibility, thus enabling developers to build and maintain their extensions outside of the Pi4J core projects codebase.\nThis will enable us to deliver a stable, fully tested framework as the number of features inside of Pi4J can be limited and support for specific I/O hardware can be provided with an extension for Pi4J.\nMore info about how this extensibility is achieved:\nExtensible I/O hardware PROVIDERS: things like GPIO expanders, I2C bus expanders, GertBoard, add-on hardware shields, etc. Extensible SBC platforms PLATFORMS: the core project may only support Raspberry Pi, but the platform and libraries should be written to allow a third party to create plugins for alternate hardware platforms/boards. Extensible plugins. Plugins are extensible service modules that interact with or augment the Pi4J infrastructure. The most common plugins are I/O Providers and Platforms. Other plugin examples could be a web app to view/control the Pi4J runtime state/status, some third-party observer to the Pi4J runtime state/status,\u0026hellip;\nPlugins are implemented as Java modules using Service Provider Interfaces (SPI).\nPlugins must declare their pluggable interface in their \u0026ldquo;module-info.java\u0026rdquo; config file. Example from the Raspberry plugin:\nmodule com.pi4j.plugin.raspberrypi { requires com.pi4j; exports com.pi4j.plugin.raspberrypi; exports com.pi4j.plugin.raspberrypi.platform; exports com.pi4j.plugin.raspberrypi.provider.gpio.digital; exports com.pi4j.plugin.raspberrypi.provider.pwm; exports com.pi4j.plugin.raspberrypi.provider.serial; exports com.pi4j.plugin.raspberrypi.provider.spi; exports com.pi4j.plugin.raspberrypi.provider.i2c; provides com.pi4j.extension.Plugin with RaspberryPiPlugin; } ServiceLoader overview by Piotr Mińkowski.\n"},{"uri":"https://pi4j.com/tags/potentiometer/","title":"Potentiometer","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/prototype/","title":"Prototype","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/documentation/platforms/raspberry-pi/","title":"Raspberry Pi","tags":[],"description":"","content":"Pi4J was designed for the Raspberry Pi, so this is the only supported platform (at this moment), although the architecture of the project allows other platforms to be added.\nAdd this dependency to include the Raspberry Pi Platform Plugin.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "},{"uri":"https://pi4j.com/architecture/advanced/remote-support/","title":"Remote support","tags":[],"description":"","content":"One of the big features on the wish-list for V2+: native support for remote I/O capability. Predominantly to support the ability for a user to perform development work on their desktop/laptop and be able to run their project with remote support slaving the I/O to a daemon running on the Raspberry Pi (or other supported SBC).\nTO BE DECIDED: the V2+ codebase does support this currently by using the PiGpio daemon.\nThis may be an OK place to start for the first release, but a separate Pi4J daemon may be ideal for a long term solution to capture some of the edge cases and provide remote I/O capability no matter which underlying I/O library is being used.\n"},{"uri":"https://pi4j.com/tags/sdkman/","title":"SDKMAN","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/serial/","title":"Serial","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/servo-motor/","title":"Servo Motor","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/simple-button/","title":"Simple Button","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/simple-led/","title":"Simple LED","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/sn74hc595/","title":"SN74HC595","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/spring/","title":"Spring","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/spring-boot/","title":"Spring Boot","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/tca9548/","title":"TCA9548","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/visual-studio-code/","title":"Visual Studio Code","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/vl53l0x/","title":"VL53L0X","tags":[],"description":"","content":""}]