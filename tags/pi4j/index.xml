<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pi4J</title><link>https://pi4j.com/tags/pi4j/</link><description>Recent content on Pi4J</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 25 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://pi4j.com/tags/pi4j/index.xml" rel="self" type="application/rss+xml"/><item><title>Interview Tom Aarts</title><link>https://pi4j.com/blog/2024/20240425_interview_tom_aarts/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240425_interview_tom_aarts/</guid><description>&lt;p&gt;2024-04-25, by Frank Delporte&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tom Aarts&lt;/strong&gt; started contributing to the Pi4J project when he did his first commit in the &lt;a href="https://github.com/Pi4J/pi4j-example-devices/" target="_blank" rel="noopener"&gt;pi4j-example-devices repository&lt;/a&gt;. At this moment, you can find example implementations for a long list of devices (see screenshot below), using V2 of Pi4J. While creating these implementations he found and fixed some missing pieces and bugs in the core library. See, for instance, this &lt;a href="https://pi4j.com/blog/2024/20240423_pwm_rpi5/" target="_blank" rel="noopener"&gt;blog post about the ongoing PWM improvements for the Raspberry Pi 5&lt;/a&gt;. Furthermore, you can find Tom often in assisting users who &lt;a href="https://github.com/Pi4J/pi4j/issues" target="_blank" rel="noopener"&gt;filed a Pi4J V2 issue&lt;/a&gt; or &lt;a href="https://github.com/Pi4J/pi4j/discussions" target="_blank" rel="noopener"&gt;started a discussion&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Interview Robert von Burg</title><link>https://pi4j.com/blog/2024/20240419_interview_robert_von_burg/</link><pubDate>Fri, 19 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240419_interview_robert_von_burg/</guid><description>&lt;p&gt;2024-04-19, by Frank Delporte&lt;/p&gt;
&lt;p&gt;The Pi4J project has two important Roberts. The first one is &lt;strong&gt;Robert Savage&lt;/strong&gt; (living in the US), who started the Pi4J development. You can read more about him and the reason Pi4J was created in &lt;a href="https://foojay.io/today/interviews-with-robert-savage-and-johan-vos-on-the-state-of-java-on-raspberry-pi/" target="_blank" rel="noopener"&gt;this interview on Foojay&lt;/a&gt;. He also created V2 of Pi4J, but hasn&amp;rsquo;t been involved a lot in the project since its release. Luckily, we have another Robert in &lt;a href="https://pi4j.com/about/team/" target="_blank" rel="noopener"&gt;the Pi4J team&lt;/a&gt;! &lt;strong&gt;Robert von Burg&lt;/strong&gt; (living in Switzerland), also known as &lt;strong&gt;Eitch&lt;/strong&gt;, is the &lt;a href="https://github.com/Pi4J/pi4j" target="_blank" rel="noopener"&gt;main maintainer now of the Pi4J V2 sources&lt;/a&gt; and takes care of the releases.&lt;/p&gt;</description></item><item><title>Ongoing I2C Improvements</title><link>https://pi4j.com/blog/2024/20240418_i2c_improvements/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240418_i2c_improvements/</guid><description>&lt;p&gt;2024-04-17, by Frank Delporte&lt;/p&gt;
&lt;p&gt;Robert von Burg is working on improvements of the I2C implementation in Pi4J in preparation for the next release. The changes are in &lt;a href="https://github.com/Pi4J/pi4j/pull/351/files" target="_blank" rel="noopener"&gt;pull request #351&lt;/a&gt;. It&amp;rsquo;s still work-in-progress but will bring these improvements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;New &lt;code&gt;I2C.execute(Callable)&lt;/code&gt; method to allow to atomically execute multiple I2C calls in a thread in a safe way.&lt;/li&gt;
&lt;li&gt;New &lt;code&gt;I2C.writeRead(byte[], byte[])&lt;/code&gt; method to atomically perform a &lt;code&gt;write&lt;/code&gt;, immediately followed by a &lt;code&gt;read&lt;/code&gt; on the I2C bus.&lt;/li&gt;
&lt;li&gt;Fix an issue where the &lt;code&gt;LinuxFsI2CBus&lt;/code&gt; was closed when closing an I2C device. This can lead to errors as another device might still be open on the same bus, and an operation on the underlying &lt;code&gt;RandomAccessFile&lt;/code&gt; would lead to exceptions.&lt;/li&gt;
&lt;li&gt;Fix a workaround that required an &lt;code&gt;I2C.read()&lt;/code&gt; on a newly created &lt;code&gt;LinuxFsI2C&lt;/code&gt; device, if the first call was an &lt;code&gt;ioctl&lt;/code&gt;. The device was not selected prior to the &lt;code&gt;ioctl&lt;/code&gt; call.&lt;/li&gt;
&lt;li&gt;Additional code cleanup and more to come&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This kind of methods is hard to test in unit tests as they interact with real components and need to handle the data and I2C devices depending on the interaction. As a solution, Robert is using a &lt;a href="https://github.com/eitch/pi4j-test/tree/feature/eitch-leds" target="_blank" rel="noopener"&gt;test project&lt;/a&gt; that has an implementation for an OLED display over I2C, using these commands.&lt;/p&gt;</description></item><item><title>LED Matrix with SPI MAX7219</title><link>https://pi4j.com/blog/2024/20240417_led_matrix_max7219_spi_web/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240417_led_matrix_max7219_spi_web/</guid><description>&lt;p&gt;2024-04-18, by Frank Delporte&lt;/p&gt;
&lt;p&gt;Roberto Marquez shared a project with us that uses Java to interface with a MAX7219 SPI device to control an LED matrix. It&amp;rsquo;s inspired by the blog &lt;a href="https://www.hackerspacetech.com/raspberry-pi-and-spi-8x8-led-matrix-example-with-java-and-pi4j/" target="_blank" rel="noopener"&gt;Raspberry Pi and SPI 8Ã—8 LED matrix example with Java and Pi4j&lt;/a&gt;, but differs in that it is Web-enabled via Spring Boot. This project is the starting point to create a weather station in combination with the BMP280, see &lt;a href="https://pi4j.com/examples/jbang/bme280_temperature_humidity_pressure/" target="_blank" rel="noopener"&gt;BME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Alexander Liggesmeyer and RPi5</title><link>https://pi4j.com/blog/2024/20240318_interview_alexander_liggesmeyer/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240318_interview_alexander_liggesmeyer/</guid><description>&lt;p&gt;2024-03-18, by Frank Delporte&lt;/p&gt;
&lt;h2 id="interview-with-alexander-liggesmeyer-about-pi4j-for-raspberry-pi-5"&gt;Interview with Alexander Liggesmeyer about Pi4J for Raspberry Pi 5&lt;/h2&gt;
&lt;p&gt;Today, &lt;a href="https://pi4j.com/about/release-notes/"&gt;version 2.5.0 of Pi4J got released with many changes, fixes and improvements&lt;/a&gt;. The most important one being support for the &lt;a href="https://www.raspberrypi.com/products/raspberry-pi-5/" target="_blank" rel="noopener"&gt;Raspberry Pi 5&lt;/a&gt;. Short after the release of this new board, &lt;a href="https://github.com/Pi4J/pi4j/issues/321" target="_blank" rel="noopener"&gt;several issues were raised on GitHub&lt;/a&gt; as Pi4J was not compatible. The Raspberry Pi 5 uses a completely new way to interact with the GPIOs: the &lt;a href="https://www.raspberrypi.com/documentation/microcontrollers/rp1.html" target="_blank" rel="noopener"&gt;RP1 chip&lt;/a&gt;. Thanks to this chip, GPIO, SPI, I2C, USB, ethernet,&amp;hellip; are seperated from the SoC to make it easier to develop newer boards. But this new approach wasn&amp;rsquo;t supported by the PiGpio library used in Pi4J V2&amp;hellip; Until Alexander Liggesmeyer took up the challenge to find a solution!&lt;/p&gt;</description></item></channel></rss>