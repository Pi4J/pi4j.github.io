<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pi4J Kotlin DSL on Pi4J</title><link>https://pi4j.com/kotlin/</link><description>Recent content in Pi4J Kotlin DSL on Pi4J</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://pi4j.com/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>Minimal Kotlin Pi4J example</title><link>https://pi4j.com/kotlin/minimal-kotlin-example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/minimal-kotlin-example/</guid><description>Full Example on GitHub: https://github.com/Pi4J/pi4j-kotlin/blob/master/example/src/main/kotlin/MinimalExample.kt
For full documentation, visit the Kotlin Docs
This is a minimal working example, make sure to check it out from the link above for the full introduction and comments.
It does exactly the same functionality of the Minimal Example using the Java API:
The application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.</description></item><item><title>Kotlin API &amp; DSL Documentation</title><link>https://pi4j.com/kotlin/kotlin-api-docs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/kotlin-api-docs/</guid><description>Here you can find the provided APIs and the dead-simple DSLs of the Kotlin package.
Components Context To create a new Pi4J context, use the pi4j function. It creates a new auto Context object and uses it as a receiver for your lambda:
pi4j { // You have access to a newly created auto context describe() } You don&amp;rsquo;t need to call shutdown(), it&amp;rsquo;s called automatically at the end of the block.</description></item><item><title>Coroutines Support</title><link>https://pi4j.com/kotlin/coroutines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/coroutines/</guid><description>pi4jAsync Same with the pi4j DSL, you can create a pi4j block to execute within a CoroutineScope using the pi4jAsync DSL.
pi4jAsync { delay(100) // suspended call describe() } Inside pi4jAsync you have access to a newly created auto context and you can run your code in the provided CoroutineScope.
Custom CoroutineScope You can also use a custom CoroutineScope instance.
pi4jAsync(CoroutineScope(Dispatchers.Default)) { delay(100) // suspended call describe() } Minimal Example with Coroutines This is a the same as the minimal example, but leveraging Kotlin&amp;rsquo;s Coroutines</description></item><item><title>I²C Kotlin DSL</title><link>https://pi4j.com/kotlin/i2c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/i2c/</guid><description>Feel free to checkout the Pi4J docs on I²C
Installation Add LinuxFs dependency
dependencies { implementation(&amp;#34;com.pi4j:pi4j-plugin-linuxfs:2.3.0&amp;#34;) } I²C DSL i2c(1, 0x3f) { id(&amp;#34;TCA9534&amp;#34;) linuxFsI2CProvider() }.use { tca9534Dev -&amp;gt; // use here. Will auto close } Writing i2c(1, 0x3f) { id(&amp;#34;TCA9534&amp;#34;) linuxFsI2CProvider() }.use { tca9534Dev -&amp;gt; val newState = tca9534Dev.setPin(currentState, pin = 8, TCA9534_REG_ADDR_OUT_PORT) } Minimal I²C Example This is the Kotlin DSL version of the same I²C example here, but leveraging the Kotlin DSL</description></item><item><title>Serial Kotlin DSL</title><link>https://pi4j.com/kotlin/serial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/serial/</guid><description>Feel free to checkout the Pi4J docs on Serial
Installation Add PiGPIO dependency
dependencies { implementation(&amp;#34;com.pi4j:pi4j-plugin-pigpio:2.3.0&amp;#34;) } Serial DSL serial(&amp;#34;/dev/ttyS0&amp;#34;) { use_9600_N81() dataBits_8() parity(Parity.NONE) stopBits(StopBits._1) flowControl(FlowControl.NONE) piGpioSerialProvider() }.open { // use here. } Minimal Serial Example This is the Kotlin DSL version of the same Serial example here, but leveraging the Kotlin DSL
serial(&amp;#34;/dev/ttyS0&amp;#34;) { // .. }.open { console { +&amp;#34;Waiting till serial port is open&amp;#34; while (!</description></item></channel></rss>