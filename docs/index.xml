<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome to Pi4J on Pi4J</title><link>https://pi4j.com/</link><description>Recent content in Welcome to Pi4J on Pi4J</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://pi4j.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Direct Download</title><link>https://pi4j.com/architecture/about-the-code/download/direct-download/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/download/direct-download/</guid><description>Direct downloads are not yet available.
Please build the project from sources available on GitHub Or acquire the compiled artifacts from the Maven SNAPSHOT repository.</description></item><item><title>Previous versions (V.1)</title><link>https://pi4j.com/about/previous-version-v1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/previous-version-v1/</guid><description>Documentation of the 1.X versions Pi4J Version 1.4 Released 2021-03-03 Support for JDK/JRE 11 and 64-bit ARM platforms This release is the final release for the Pi4J Version 1.x codebase The Pi4J project is now prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform Changed project to Apache License, Version 2.0 Removed pi4j-device and pi4j-gpio-extension library Removed platform support for Odroid, BananaPi, BPi, NanoPi, OrangePi Various improvements and bug fixes listed here: GitHub Issues (v1.</description></item><item><title>Build Instructions</title><link>https://pi4j.com/architecture/about-the-code/build-instructions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/build-instructions/</guid><description>Building the Pi4J Project is simple and requires minimal effort. Pi4J is primarily built using Apache Maven and Java 11. Pi4J can be built directly on your host computer or inside a Docker container where all toolchains and dependencies are already installed, configuired and cached.
If you wish to build using a Docker container, please skip ahead to the Building with Docker topic.
Prerequsites In order to build Pi4J, the host system must have the following toolchains pre-installed.</description></item><item><title>Maven Repository</title><link>https://pi4j.com/architecture/about-the-code/download/repository/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/download/repository/</guid><description>Pi4J V.2 is not yet released or published to Maven Central.
Please build the project from sources available on GitHub Or acquire the compiled artifacts from this Maven SNAPSHOT repository.</description></item><item><title>Set up a new Raspberry Pi</title><link>https://pi4j.com/getting-started/set-up-a-new-raspberry-pi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/set-up-a-new-raspberry-pi/</guid><description>Introduction The Raspberry Pi is a powerful machine with many use-cases. A lot of this power is based on the operating system you use. For our &amp;ldquo;Getting Started&amp;rdquo; examples we will be using the &amp;ldquo;official Raspberry Pi OS&amp;rdquo; (formerly known as &amp;ldquo;Raspbian OS&amp;rdquo;) but there is a long list of other possibilities which is listed for example on the&amp;ldquo;Awesome Raspberry Pi&amp;rdquo; list on GitHub.
In this article we start with a brand new Raspberry Pi board.</description></item><item><title>What's New (V.2)</title><link>https://pi4j.com/about/new-in-v2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/new-in-v2/</guid><description>What&amp;rsquo;s New in 2.0? Pi4J version 2.0 brings with it many new features, and an entirely new architecture that focuses on extensibility, simplified integration and a modern Java API including the following:
Fluent APIs/Interfaces Immutable Runtime Context Extensible Provider/Platform/Plug-in Architecture Builder-patterns for creating new I/O instances Well-documented source code Hardware PWM Support Java 11 Future plans:
Dependency Injection via Pi4J Annotations Remote I/O Support (via TCP/IP) In addition to the features listed above, Pi4J version 2.</description></item><item><title>Understanding the GPIO pins</title><link>https://pi4j.com/getting-started/understanding-the-pins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/understanding-the-pins/</guid><description>Connecting electronic components to the Pi is done via one or more of the pins in the so-called header. The number of pins has &amp;ldquo;grown&amp;rdquo; between the different Raspberry Pi board versions, but all recent ones have a 40-pin header. It&amp;rsquo;s of course important to be aware of the correct numbering to not correct components the wrong way.
Type of pins The pins have different uses
Power and ground Both 5V and 3.</description></item><item><title>Installation</title><link>https://pi4j.com/architecture/about-the-code/download/install/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/download/install/</guid><description>This project is still in development and thus no package installers are available at this time.</description></item><item><title>Java development with VSC</title><link>https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/</guid><description>Java on the Raspberry Pi To use Pi4J V2 you&amp;rsquo;ll need Java 11 or newer. Luckily this version is included in the current version of Raspberry Pi OS. In the release notes you can see that the version of 2019-06-20 includes OpenJDK Java 11:
2019-06-20: Based on Debian Buster Oracle Java 7 and 8 replaced with OpenJDK 11 But you will need to keep in mind this version is only compatible with ARMv7 or higher and doesn&amp;rsquo;t support all Raspberry Pi board versions.</description></item><item><title>Maven settings</title><link>https://pi4j.com/architecture/about-the-code/maven-settings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/maven-settings/</guid><description>To simplify development but not commit sensitive information, you can add personal or PC-specific settings in the Maven settings.xml file. This file is stored or needs to be created in the &amp;ldquo;.m2&amp;rdquo; directory in your home directory:
Windows: C:\Users\YOUR_NAME.m2 Linux: /home/YOUR_NAME/.m2 Mac: /Users/YOUR_NAME/.m2 For more info see this article on Baeldung.
This is an example settings file, including settings for compiling of Pi4J and credentials to upload the generated code to a Raspberry Pi.</description></item><item><title>Pin numbering</title><link>https://pi4j.com/documentation/pin-numbering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/pin-numbering/</guid><description>Pi4J V.1 took a pretty opinionated approach to pin numbering as the scheme was based on the underlying WiringPi. This scheme was incompatibility with other pin diagrams and pin numbering used by other development platforms and libraries.
As Pi4J V.2 is build as a &amp;ldquo;pass thru library&amp;rdquo;, and uses PiGpio as the underlying framework, the more well-known BCM numbering is being used now.
This drawing shows the different numbers for WiringPi and BCM in a 40-pins Raspberry Pi header:</description></item><item><title>Release Notes</title><link>https://pi4j.com/about/release-notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/release-notes/</guid><description>2021-08-26 2.0 Yoohoo it&amp;rsquo;s here! After a lot of work we present you the totally renewed Pi4J library!
Most important info on V2:
Java 11 and up Breaking change with V1 as the framework has been completely re-architected (see pi4j.com/architecture) No longer include support for peripheral devices and add-on chipsets/boards as part of the core project Easier to extend, maintain and test Uses PiGpio as the native library (WiringPi which was used in V1 got deprecated in 2019) Builds as modules to fully support future evolutions in Java Uses minimal dependencies (only SLF4J) Different examples how to get started (also with JavaFX) are available on pi4j.</description></item><item><title>Developing on a remote PC</title><link>https://pi4j.com/getting-started/developing-on-a-remote-pc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/developing-on-a-remote-pc/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-maven-archetype
Developing Java programs using a remote PC workstation Writing your Java program, compiling and running it directly on the Raspberry Pi board as shown in the previous chapter is perfectly fine, of course, but there is an alternative way to arrange your developing laboratory, using a normal desktop computer as Remote Developing Workstation (RDW).
This Maven Archetype will give you a tool to generate Pi4J-V2 skeleton Java projects.</description></item><item><title>Code styling</title><link>https://pi4j.com/architecture/about-the-code/code-styling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/code-styling/</guid><description>To prevent unnecessary code (tabs versus spaces, number of characters per line&amp;hellip;) we have defined an editorconfig for IntelliJ IDEA. You can find more info here about its use.
Some tips to keep the code clean and readable:
Short methods with a clear name Use SonarLint to get improvement tips while code Use shortcuts CTRL+ALT+L: Reformat code CTRL+ALT+O: Optimize imports</description></item><item><title>Hardware testing</title><link>https://pi4j.com/architecture/about-the-code/hardware-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/hardware-testing/</guid><description>This is an experimental project which will need a lot of love&amp;hellip; The new Raspberry Pi Pico with a lot of GPIOs for a very low price, seems even to be a better fit for this project compared to the Arduino Due&amp;hellip; To be further investigated!
To minimize the required time and efforts to test a new release, V.2 aims to include an automated test which performs I/O testing on each I/O interface on each model of RPi.</description></item><item><title>Java for ARMv6/7/8</title><link>https://pi4j.com/documentation/java-installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/java-installation/</guid><description>Raspberry Pi OS Full comes with Java 11 pre-installed. But this version only works on board-versions with an ARMv7 or ARMv8. In some cases you will need to do some additional steps to install a Java version which works on your board.
Board versions With ARMv6 processor Raspberry Pi 1 A and A+ Raspberry Pi 1 B and B+ Compute Module 1 Zero 1.2, 1.3 and W With ARMv7 or ARMv8 processor Model A+, version 3 Model B, version 2, 3 and 4 Compute Module, version 3 How to check and install Java Check the current version If you prepared a microSD card with the latest version of Raspbian OS (full version), Java is already installed!</description></item><item><title>License (Open Source)</title><link>https://pi4j.com/about/license/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/license/</guid><description>The Pi4J Version 2.0 project is distributed and licensed under the Apache License, Version 2.0 license (A business-friendly OSS license).
apache.org/licenses/LICENSE-2.0 github.com/Pi4J/pi4j-v2/blob/master/LICENSE.txt Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
Definitions.
&amp;ldquo;License&amp;rdquo; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.
&amp;ldquo;Licensor&amp;rdquo; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</description></item><item><title>Minimal example application</title><link>https://pi4j.com/getting-started/minimal-example-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/minimal-example-application/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal
In the &amp;ldquo;pi4j-example-minimal&amp;rdquo; GitHub project you can find a project which contains the minimal code to control a digital input and output with Pi4J. The project is further described on this page. The application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.
Wiring This minimal example application uses this wiring:</description></item><item><title>Soft real time PLC with Strolch</title><link>https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/</guid><description>Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available.
Conveyors for containers filled by a dispensing robot</description></item><item><title>Logging with SLF4J</title><link>https://pi4j.com/documentation/logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/logging/</guid><description>Pi4J uses SLF4J for logging. To include it in your project, add this Maven dependency:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-simple&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.0-alpha0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; There are different ways to configure the logging output, as described on the SLF4J website, but the shortest is probably with this property in your main-method:
public static void main(String[] args) throws Exception { // Configure default lolling level, accept a log level as the first program argument System.setProperty(&amp;#34;org.slf4j.simpleLogger.defaultLogLevel&amp;#34;, &amp;#34;INFO&amp;#34;); // Your code comes here }</description></item><item><title>PiJukeBox by Daniel Mårtensson</title><link>https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/</guid><description>Daniel used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators.
Features: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi&amp;rsquo;s, terminal based.</description></item><item><title>The Team</title><link>https://pi4j.com/about/team/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/team/</guid><description>Robert Savage, Project Founder, Architect, Lead Developer. Principal Software Architect/Engineer. Consultant, technology enthusiast, entrepreneur, open source contributor, technology blogger. Founder at shadeBlue, LLC and SavageSoftware, LLC. Robert has a more than 20 year career working in the professional audio visual and home/commercial automation industry and an extensive background in developing technology solutions with a special focus on home automation and hardware/firmware/software integration.</description></item><item><title>CrowPi OS</title><link>https://pi4j.com/getting-started/crowpi/crowpi-os/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/crowpi/crowpi-os/</guid><description>You can start experimenting with the default Raspberry Pi OS, but to make things easier a prepackaged OS is available with additional tools. Follow these steps to get started quickly with this CrowPi OS.
Install the Raspberry Pi Imager The official Imager Tool can be downloaded directly from the Raspberry Pi website. This simple tool works on all common operating systems and can be installed very easily with just a few keystrokes.</description></item><item><title>Develop with Intellij IDEA</title><link>https://pi4j.com/getting-started/crowpi/develop-with-intellij/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/crowpi/develop-with-intellij/</guid><description>In this tutorial, IntelliJ IDEA is used for the development. The articles, instructions and pictures are created accordingly. IntelliJ IDEA is from available Jetbrains in different versions. The community version has enough functionality for development with the CrowPi and is available for Windows, MacOS and Linux, but NOT for Raspberry Pi. The download can be found here.
The subsequent setup of IntelliJ IDEA is identical on all platforms.
Clone the repository As soon as we have installed the development environment, it is time to clone the entry-level project for the CrowPi.</description></item><item><title>Creating a Pi4J Context</title><link>https://pi4j.com/documentation/create-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/create-context/</guid><description>The context is an immutable runtime object that holds the configured state and manages the lifecycle of a Pi4J instance. It includes all loaded plugins, providers, platforms, I/O instance registry, environmental configuration and runtime objects including executor thread pools, I/O event listeners, etc.
Terminating/destroying the context stops and releases all resources, threads, listeners, and provisioned I/O instances held by the context.
Version 1 was implemented using a static singleton, while version 2 uses a &amp;ldquo;Context&amp;rdquo; to avoid static singletons.</description></item><item><title>User interface with JavaFX</title><link>https://pi4j.com/getting-started/user-interface-with-javafx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/user-interface-with-javafx/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-javafx
JavaFX is a framework to create user interfaces for desktop (Windows, Mac, Linux) and mobile phones. JavaFX is an opensource project which is documented on openjfx.io and the sources are available in this GitHub project.
The main goal of Java has always been to be able to create applications which are &amp;ldquo;write once, run everywhere&amp;rdquo;. JavaFX promises the same for Graphical User Interface applications.
Gluon is the main maintainer of the OpenJFX project and offers commercial support to companies who want to use JavaFX in critical applications.</description></item><item><title>FXGl to Picade</title><link>https://pi4j.com/getting-started/fxgl/fxgl-to-picade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/fxgl/fxgl-to-picade/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl
In this section we demonstrate how to convert existing FXGL projects to work on a RaspberryPi
If you don&amp;rsquo;t have an existing FXGL project, go grab one from FXGLGames
Steps to get your app running on a RaspberryPi Add Maven support to your project In our project we use Maven to manage dependencies and build the application, other build tools such as gradle are also viable but not covered in this tutorial.</description></item><item><title>JavaFX kiosk mode</title><link>https://pi4j.com/getting-started/fxgl/kiosk-mode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/fxgl/kiosk-mode/</guid><description>Visit webtechie.be for the full blogpost
Kiosk Mode With Gluon&amp;rsquo;s JavaFX 17-ea, we are able to run applications in different modes: Desktop and Kiosk mode. In this post we focus on the Kiosk mode only.
With this approach, the application is the only thing you see on the screen. This prevents the user to open any other applications, or mess up your system. In this case, there is no need for a window manager, and the application directly uses the underlying (hardware) framebuffer.</description></item><item><title>Building an I/O Instance</title><link>https://pi4j.com/documentation/build-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/build-io/</guid><description>TODO</description></item><item><title>Learn more...</title><link>https://pi4j.com/getting-started/learn-more/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/learn-more/</guid><description>Pi4J is used in a lot of projects, and you can find a lot of examples online. On this page we want to keep an up-to-date list. Do you want to add something? Please hit &amp;ldquo;Edit this page&amp;rdquo; on the top and create a pull request!
Twitter Please share your personal or professional projects where you combine Java and the Raspberry Pi on Twitter with the hashtag #JavaOnRaspberryPi.
Online articles Foojay.</description></item><item><title>Devices examples</title><link>https://pi4j.com/documentation/device-examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/device-examples/</guid><description>The core Pi4J V.2 library doesn&amp;rsquo;t contain any specific support for devices like buttons, motors, LCD&amp;hellip; This was part of V.1 but made it much more difficult to maintain and fully test the library.
On this page we want to keep a list of projects which contain implementation code for specific devices using the Pi4J V.2 core library. Please let us know through the forum if you want to have your project added to this list.</description></item><item><title>I/O Registry</title><link>https://pi4j.com/documentation/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/registry/</guid><description>An additional V.2 feature is an I/O registry where all I/O instances that have been created can be maintained, managed, re-accessed, etc. As the library keeps track of all the created I/O instances, they become publicly accessible through a registry where users can interrogate, iterate, identify and access all created I/O instances that Pi4J is managing.
This is very useful for add-ons/plugins that want to provide runtime information about the state of all I/O, for example a web app illustrating the current state of I/O.</description></item><item><title>Shutting down the Pi4J Context</title><link>https://pi4j.com/documentation/shutdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/shutdown/</guid><description>At the end of our application, the context needs to be shutdown to release the I/O and clean up the used resources.
# Start of program var pi4j = Pi4J.newAutoContext(); # YOUR CODE GOES HERE # End of program pi4j.shutdown();</description></item><item><title>Digital Output (GPIO)</title><link>https://pi4j.com/documentation/io-examples/digital-output/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/digital-output/</guid><description>A digital output translates a false/true (or 0/1) to an output value of 0V or 3.3V. This means you can control any type of device which works with max 3.3V to off or on. The most basic example is a LED. Always check which is the correct input voltage for your device! For a LED you will need to put a resistor with the correct value between the GPIO and the LED, you can find a lot of examples and calculators online, for example on circuitdigest.</description></item><item><title>Digital Input (GPIO)</title><link>https://pi4j.com/documentation/io-examples/digital-input/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/digital-input/</guid><description>Similar to a digital output pin, a digital input translates an input value of 0V or 3.3V to the value false/true. This means any type of device which can toggle between 3.3V and 0V, can generate an input value to the Raspberry Pi. Here the most basic example is a toggle button. If you use other components, always check which is the voltage provided by the device. Or if you use a power pin from the Raspberry Pi itself, to use a 3.</description></item><item><title>Pulse Width Modulation (PWM)</title><link>https://pi4j.com/documentation/io-examples/pwm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/pwm/</guid><description>What is it? The abbreviation PWM stands for &amp;ldquo;Pulse Width Modulation&amp;rdquo; and is also often referred to in German as pulse width modulation or pulse width modulation. This technology is used, among other things, to control servomotors and is also used, for example, for the fans of a regular computer.
With PWM, it is possible to control a component such as a motor no longer purely binary, i.e. off (0% power) or on (100% power), but to control them almost at will.</description></item><item><title>I²C Clock Stretching</title><link>https://pi4j.com/documentation/io-examples/i2c/clock-stretching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/i2c/clock-stretching/</guid><description>Clock Stretching Please be aware there are some hardware issues when using the Raspberry Pi with devices that expect to be able to use clock stretching, for more info see &amp;ldquo;Adventures in I2C: clock stretching on the Raspberry Pi&amp;rdquo; and &amp;ldquo;I2C stretch bug. Been fixed or not?&amp;quot;.
Clock stretching in I2C allows a slave device to halt the master before a more data is sent. This is often the case when the slave device writes to an EEPROM etc.</description></item><item><title>Serial Peripheral Interface (SPI)</title><link>https://pi4j.com/documentation/io-examples/spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/spi/</guid><description>What is it? The Serial Peripheral Interface, abbreviated to SPI, is a bus system which enables communication between a main device (called “master”) and one or more secondary devices (called “slave”). A direct communication between all participants is not possible here, much more the master can choose at any time with which slave he would like to exchange data.
In order to address only one slave, a total of 3 signal lines are required, two of which are used for bidirectional data transmission and one as a clock generator for serial transmission.</description></item><item><title>Serial (UART/RS232)</title><link>https://pi4j.com/documentation/io-examples/serial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/serial/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-serial/
What is it? Serial communication can be used to transfer data between different boards, devices, etc. Data is transfered bit-by-bit in a sequence, through a single wire from a transmitter (= TX) to a receiver (= RX). On the receiver side the bits are combined to bytes.
When you need two-way communication, two wires are needed between RX and TX from both sides:
The communication between these two devices can happen in different ways:</description></item><item><title>Annotated provisioning</title><link>https://pi4j.com/architecture/advanced/annotated-provisioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/annotated-provisioning/</guid><description>To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations
Next to the declarative approach, Java annotations are available for the configuration of I/O provisioning instead of the hard-coded approach offered in V.1.
This implementation still needs to be further fine-tuned and unified somehow to make things cleaner and more straightforward, but would provide a way to initialize a I/O for instance like this:</description></item><item><title>Dependency injection</title><link>https://pi4j.com/architecture/advanced/dependency-injection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/dependency-injection/</guid><description>To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations
Along with the annotated I/O configuration the ability to support I/O provisioning via dependency injection also makes a lot of sense. There is some basic brute-force stuff working but this needs more work to make this a compatible implementation for Spring or CDI.</description></item><item><title>LinuxFS</title><link>https://pi4j.com/documentation/providers/linuxfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/providers/linuxfs/</guid><description>The current implementation of the LinuxFS plugin implements a file based I2C provider. The file based provider opens /dev/i2c-1 using a RandomAccessFile to perform I2C reads and writes.
Providers in the LinuxFS plugin:
linuxfs-i2c To use the LinuxFS provider first add the proper dependency:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.pi4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;pi4j-plugin-linuxfs&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${pi4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; And then one can get access to the provider as follows:
Context pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(&amp;#34;linuxfs-i2c&amp;#34;); I2CConfig i2cConfig = I2C.</description></item><item><title>Native Library Path</title><link>https://pi4j.com/architecture/advanced/library-path/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/library-path/</guid><description>Overview Some Pi4J plugins, such as the Pi4J PiGpio Provider plugin, depend on native JNI libraries to communicate with the underlying system. By default Pi4J embeds these native libraries as resources inside the plugin&amp;rsquo;s JAR file. At runtime Pi4J extracts the native library into a temporary directory so the JVM can load the library from the filesystem. Upon termination the temporary file is automatically removed.
This automatic extration behavior works well for most users; however, there are certain edge cases where this may fail.</description></item><item><title>PiGpio</title><link>https://pi4j.com/documentation/providers/pigpio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/providers/pigpio/</guid><description>The current implementation of the PiGpio exposes the GPIO functions available on the Raspberry Pi.
Providers in the PiGpio plugin:
pigpio-digital-input pigpio-digital-output pigpio-pwm pigpio-i2c pigpio-spi pigpio-serial To use the LinuxFS provider first add the proper dependency:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.pi4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;pi4j-plugin-raspberrypi&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${pi4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;</description></item><item><title>Plug-ins</title><link>https://pi4j.com/architecture/advanced/plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/plugins/</guid><description>The goal of Pi4J V.2 is to provide a solid base with all required &amp;ldquo;minimal functionality&amp;rdquo; while at the same time, promote third-party development and extensibility, thus enabling developers to build and maintain their extensions outside of the Pi4J core projects codebase.
This will enable us to deliver a stable, fully tested framework as the number of features inside of Pi4J can be limited and support for specific I/O hardware can be provided with an extension for Pi4J.</description></item><item><title>Raspberry Pi</title><link>https://pi4j.com/documentation/platforms/raspberry-pi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/platforms/raspberry-pi/</guid><description>TODO</description></item><item><title>Remote support</title><link>https://pi4j.com/architecture/advanced/remote-support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/remote-support/</guid><description>One of the big features on the wish-list for V.2: native support for remote I/O capability. Predominantly to support the ability for a user to perform development work on their desktop/laptop and be able to run their project with remote support slaving the I/O to a daemon running on the Raspberry Pi (or other supported SBC).
TO BE DECIDED: the V.2 codebase does support this currently by using the PiGpio daemon.</description></item><item><title>Third-Party Integration</title><link>https://pi4j.com/architecture/advanced/3rd-party/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/3rd-party/</guid><description>TODO</description></item></channel></rss>