[{"uri":"https://pi4j.com/about/","title":"About","tags":[],"description":"","content":"Project Status/Summary Pi4J V.2 is a complete re-write and does not maintain API compatibility with previous versions. It is not intended to be a drop-in replacement for previous versions of Pi4J. Pi4J V.2 is a completely new design bringing modern conventions, development practices, extensibility support and simplified integration experience for Pi4J users.\nThis website aims to be the source of documentation for all things Java on Raspberry Pi. As such, you will not only find info on Pi4J, but also getting started examples for basic Java Pi4J projects, JavaFX user interface applications, FXGL games, etc.\nThis is a true open-source project, meaning it can only evolve, grow and improve by the support of the community. Any idea, documentation improvement, bug fix\u0026hellip; is greatly welcomed through the normal GitHub flow!\n"},{"uri":"https://pi4j.com/architecture/about-the-code/","title":"Project source structure","tags":[],"description":"","content":"To ensure the Pi4J V.2 project is easy to maintain, there is a clear separation between the core functions and isolated test, example and plugin projects.\nOn this page we want to give you an overview of the projects which are part of the GitHub Pi4J Project.\nPi4J V.2 Main project  github.com/Pi4J/pi4j-v2 This is the main Pi4J V.2 project providing all (basic) I/O functionalities.  Pi4J Parent POM  /pom.xml This is \u0026ldquo;the grandparent POM\u0026rdquo; and the place to build the entire project.  Pi4J Libraries  /libraries/* This folder contains (JNI native) libraries that Pi4J or Pi4J plugins may require for runtime. Libraries are not Pi4J extension, plugins, providers, platforms, etc. At this moment only a PiGpio library is included, but could be extended in the future. By isolation the native functions in libraries, the underlying I/O interface can easily be replaced later without breaking the core library.  Pi4J Libraries Parent POM  /libraries/pi4j-library/pom.xml Base library to be used when creating a new library. Contains the parent pom.xml-file for all library implementations.  Pi4J PiGPIO JNI Wrapper Library  /libraries/pi4j-library-pigpio This library is a Java library to wrap the PiGPIO API and implement the JNI layer to facilitate use of PiGPIO in Java. There is no Pi4J specific API or code in this library. This PiGPIO wrapper can be used directly without using the Pi4J-core but in that case your application highly depends on the methods of PiGPIO and will be very hard to refactor if you need to use another wrapper.  Pi4J Core Library  /pi4j-core This is the Pi4J V.2 API and core implementation of the framework and runtime. Doesn\u0026rsquo;t contain any actual I/O providers, platforms or IO/platform implementation \u0026ndash;\u0026gt; those are all provided via extensions/plugins.  Pi4J Unit/Integration Test  /pi4j-test This is intended to be a place for unit and integration tests to test the APIs and features. It only performs tests using MOCK I/O via the Mock IO Provider (plugin). It should not attempt to perform any real I/O testing.  Pi4J Plugins: the actual I/O providers, platforms and implementations  /plugins/* This folder contains any plugins for use with Pi4J such as IO providers, platforms, or extensions. Plugins must implement the Pi4J Plugin Interface (com.pi4j.extension.Plugin) and declare the implementation class using the \u0026ldquo;provides\u0026rdquo; directive in the module info class. See for an example in /plugins/pi4j-plugin-mock/src/main/java/module-info.java  Pi4J Libraries Parent POM  /plugins/pi4j-plugin/pom.xml* Base library to be used when creating a new plugin. Contains the parent pom.xml-file for all plugin implementations.  Pi4J LinuxFS Provider  /plugins/pi4j-plugin-linuxfs This plugin is intended to implement I/O Providers for Linux file system operations such as SERIAL, SPI, I2C and perhaps basic GPIO. This plugin is mostly empty at this moment. Goal is to have an I/O Provider which is totally independant of an underlying program.  Pi4J Mock Platform \u0026amp; Provider  /plugins/pi4j-plugin-mock This plugin implements both a Mock Platform and Mock I/O Providers for every I/O type supported by Pi4J. This Mock plugin is used by the unit and integration testing project.  Pi4J PiGPIO Provider  /plugins/pi4j-plugin-pigpio This plugin implements I/O Providers for every I/O type supported by the PiGPIO library. At this moment, this single plugin supports both ** local/native connectivity to PiGPIO ** remote (TCP) connectivity to PiGPIO ** TO BE DISCUSSED: Perhaps this should be separated into two plugins? Or moved to a separate \u0026ldquo;remote connectivity project\u0026rdquo;?  Pi4J RaspberryPi Platform \u0026amp; Provider  /plugins/pi4-plugin-raspberrypi This plugin is intended to implement the Provider for the Raspberry Pi models and declare the default I/O providers for each of the I/O types supported by each RPi model.  Pi4J WiringPi Provider  NOT IN THE PROJECT CODE This plugin was intended to implement I/O Providers for use with the WiringPi library, similar to the PiGPIO provider. However with the WiringPi project no longer being maintained publicly, this plugin was not implemented  Stand-alone projects Pi4J Test Harness  github.com/Pi4J/pi4j-test-harness This project contains the source code (both Java library and Arduino code) for the hardware test harness which has been created to eventually perform hardware testing at the physical layer to help speed up verification for each RPI hardware model Current state is very rough but functional. This project has been moved outside of the core project as this is only used for the validation test cycle before releasing a new version. For more info, see \u0026ldquo;Hardware testing\u0026rdquo;  Pi4J Example projects Pi4J Minimal example  github.com/Pi4J/pi4j-example-minimal Example project only showing the use of a digital input and output with minimal code but a lot of comments  Pi4J Examples  github.com/Pi4J/pi4j-examples This project contains numerous code examples to demonstrate how to use Pi4J Certain functions have examples to reach the same goal with different use types, e.g. initialization of a DigitalInput with code, properties and annotations.  Pi4J Telegraph example  github.com/Pi4J/pi4j-example-telegraph Example project demonstrated during Oracle Code One 2019  "},{"uri":"https://pi4j.com/architecture/about-the-code/download/direct-download/","title":"Direct Download","tags":[],"description":"","content":"You can build the project from sources available on GitHub.\nAll downloads provided by the project can be found on pi4j.com/download.\nThe compiled artifacts (releases and snapshots) are available in the Sonatype Maven repository.\n"},{"uri":"https://pi4j.com/architecture/about-the-code/download/","title":"Download/Install","tags":[],"description":"","content":"Getting started with V.2 in the state of June 3th of 2020.\nPi4J V.2  Checkout the project pi4j-v2 Select JDK11, e.g. sdk use java 11.0.7.fx-librca In the root of pi4j-v2 run `m̀vn clean install``  [INFO] Executed tasks [INFO] ------------------------------------------------------------------------ [INFO] Reactor Summary for Pi4J :: Parent POM 2.0-SNAPSHOT: [INFO] [INFO] Pi4J :: Parent POM ................................. SUCCESS [ 0.972 s] [INFO] Pi4J :: DOCKER :: Docker Parent POM .............. SUCCESS [ 0.290 s] [INFO] Pi4J :: TESTING :: Arduino Test Harness ........... SUCCESS [ 1.832 s] [INFO] Pi4J :: LIBRARY :: Libraries Parent POM ........... SUCCESS [ 0.064 s] [INFO] Pi4J :: LIBRARY :: JNI Wrapper for PIGPIO Library . SUCCESS [ 6.615 s] [INFO] Pi4J :: LIBRARY :: Java Library (CORE) ............ SUCCESS [ 6.260 s] [INFO] Pi4J :: PLUGIN :: Plugins Parent POM ............. SUCCESS [ 0.061 s] [INFO] Pi4J :: PLUGIN :: Mock Platform \u0026amp; Providers ...... SUCCESS [ 0.683 s] [INFO] Pi4J :: PLUGIN :: PIGPIO I/O Providers ........... SUCCESS [ 2.084 s] [INFO] Pi4J :: PLUGIN :: RaspberryPi Platform \u0026amp; Providers SUCCESS [ 0.447 s] [INFO] Pi4J :: TESTING :: Unit/Integration Tests ......... SUCCESS [ 2.350 s] [INFO] Pi4J :: EXAMPLE :: Sample Code .................... SUCCESS [ 0.632 s] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ Example application Building the example application  Checkout the project Pi4J V.2 - Telegraph Demo Project Select JDK11, e.g. sdk use java 11.0.7.fx-librca In the root of pi4j-demo-telegraph run `m̀vn clean install`` Check the directory target\\distribution \u0026ndash;\u0026gt; this contains all the files to be copied to the Raspberry Pi  /target/distribution/pi4j-core-2.0-SNAPSHOT.jar /target/distribution/pi4j-demo-telegraph-1.0-SNAPSHOT.jar /target/distribution/pi4j-library-pigpio-2.0-SNAPSHOT.jar /target/distribution/pi4j-plugin-pigpio-2.0-SNAPSHOT.jar /target/distribution/pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar /target/distribution/run.sh /target/distribution/slf4j-api-2.0.0-alpha0.jar /target/distribution/slf4j-simple-2.0.0-alpha0.jar Running on the Raspberry Pi  After copying all files from target/distribution to a Raspberry Pi, start ./run.sh  "},{"uri":"https://pi4j.com/getting-started/","title":"Getting started with Pi4J","tags":[],"description":"","content":"You have a Raspberry Pi? And you want to use Java as your programming language to build performant, easy-to-maintain and powerful applications? This is the place to be!!!\nThe pages in this chapter explain you how to get started in different steps. The full documentation for the library, with more in-depth and technical info, can be found in the \u0026ldquo;Documentation\u0026rdquo; chapter.\nThis part of the site takes you through the different steps to start \u0026ldquo;from scratch\u0026rdquo;:\n Setting up the Raspberry Pi with all the tools needed Understanding the GPIO pins Java development on the Raspberry Pi with Visual Studio Code Using a Linux/Windows/Mac separate computer as developing workstation Minimal example application with an LED and button Introduction to electronics with CrowPi Adding a user interface with JavaFX Game development with FXGL and an Arcade controller  And if you still want to learn more, we have a list of additional resources.\n"},{"uri":"https://pi4j.com/about/previous-version-v1/","title":"Previous versions (V.1)","tags":[],"description":"","content":"Documentation of the 1.X versions Pi4J Version 1.4  Released 2021-03-03 Support for JDK/JRE 11 and 64-bit ARM platforms This release is the final release for the Pi4J Version 1.x codebase The Pi4J project is now prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform Changed project to Apache License, Version 2.0 Removed pi4j-device and pi4j-gpio-extension library Removed platform support for Odroid, BananaPi, BPi, NanoPi, OrangePi Various improvements and bug fixes listed here: GitHub Issues (v1.4) Not using Java-modules yet, this will be part of the V.2 Documentation website V1.4  Pi4J Version 1.3  Released 2021-01-29 Added support for Raspberry Pi 4B, 400, and Compute Module 4 Various improvements and bug fixes listed here: GitHub Issues (v1.3) Based on JDK8 Documentation website V1.3  Pi4J Version 1.2  Released 2019-02-26 Based on Java 8 Documentation website V1.2  Pi4J Version 1.1  Released 2016-07-26 Documentation webiste V1.1  Pi4J Version 1.0  Released 2015-04-18 Documentation website V1.0  "},{"uri":"https://pi4j.com/architecture/about-the-code/build-instructions/","title":"Build Instructions","tags":[],"description":"","content":"Building the Pi4J Project is simple and requires minimal effort. Pi4J is primarily built using Apache Maven and Java 11. Pi4J can be built directly on your host computer or inside a Docker container where all toolchains and dependencies are already installed, configuired and cached.\nIf you wish to build using a Docker container, please skip ahead to the Building with Docker topic.\n  Prerequsites In order to build Pi4J, the host system must have the following toolchains pre-installed.\n   Name Version URL     Java Development Kit (JDK) 11.0.7 (or newer) https://openjdk.java.net/   Apache Maven 3.6.3 (or newer) https://maven.apache.org/download.cgi     Build Environment The JAVA_HOME system environment variable must be configiured to point to the JDK installed path.\n Building with Maven To build the Pi4J project, use the following Maven comand from the parent Pi4J directory.\nmvn clean install If you prefer to skip all unit/integration testing, use the folllowing Maven command:\nmvn clean install -DskipTests  Building with Docker Alternatively, the Pi4J project can be entirely compiled inside a prebuilt Pi4J Builder Docker container. This eliminates the need/requirement to install the build toolchains and configure your system to build Pi4J. To build the Pi4J project using Docker, run the following shell script from the parent Pi4J directory.\n./build-docker.sh The project which provides these Docker images can be found on GitHub \u0026gt; Pi4J/pi4j-docker and includes an extensive README with the full info on how to build and use these images.\nExtract from the README:\nThis project contains the Dockerfiles and build scripts to create the Pi4J builder\ndocker images used for compiling/building the Pi4J projects. The Pi4J builder images include the following:\n  Pi4J Base Builder pi4j/pi4j-builder-base:latest : This is the base image used by all the other builder images. It's based on Ubuntu 18.04 with JDK 11 and Maven pre-installed. This image's entry point is a Bash shell. (https://hub.docker.com/repository/docker/pi4j/pi4j-builder-base)\n  Pi4J Native Builder pi4j/pi4j-builder-native:latest : This image is derived from pi4j/pi4j-builder-base and adds support for native cross-compilers and build tools for architectures: arm, armhf, aarch64/arm64. This image's entry point is a bash shell attempting to execute the file ./build.sh in the volume mounted under the /build path.\n  Pi4J v1.4 Builder pi4j/pi4j-builder:1.4 : This image is derived from pi4j/pi4j-builder-native and additionally includes pre-cached Maven build plugins and dependencies for Pi4J v1.4 builds. This image's entry point is a Maven shell. If not explicitly provided, the default maven build arguments will be: clean install -DskipTests -Pall-platforms. This will effectively build all Pi4J projects including the pi4j-native project containing native libraries which will be cross-compiled for RaspberryPi/ARM (32-bit \u0026amp; 64-bit) devices.\n  Pi4J v2.0 Builder pi4j/pi4j-builder:2.0 : This image is derived from pi4j/pi4j-builder-native and additionally includes pre-cached Maven build plugins and dependencies for Pi4J v2.0 builds. This image's entry point is a Maven shell. If not explicitly provided, the default maven build arguments will be: clean install -DskipTests -native. This will effectively build all Pi4J projects including the native library projects which will be cross-compiled for RaspberryPi/ARM (32-bit \u0026amp; 64-bit) devices.\n  Note: Pi4J versions prior to v1.4 are not currently tested or supported in these Docker images.\n Building Pi4J Native Libraries Pi4J V.2 also includes native libraries that will need to be compiled if you are modifying any native code. Most users will never need to compile the native libraries as these artifacts are automatically downloaded when building the Pi4J JARs from Maven repositories. One of the following commands can be used to build the Pi4J JARs and Native Libraries:\nmvn clean install -Pnative mvn clean install -Pnative,docker mvn clean install -Pnative,cross-compile  See the custom build profiles in the Custom Build Profiles section for more information about the profiles illustrated in these commands.\n Additional information about Docker Builds vs Cross-Compiler builds can be found here: https://github.com/Pi4J/pi4j-v2/issues/21#issuecomment-651976487\nTODO Create a topic here detailing Docker builds vs Cross-compiler builds.\n Custom Build Profiles The Pi4J Maven build includes a number of custom profiles that can be activated to perform various build steps.\n   Profile Description Notes     sources Package raw sources for each JAR Only needed when performing a snapshot or release build.   javadoc Compile and package JavaDoc for each JAR Only needed when performing a snapshot or release build.   native Compile any native libraries included in the build Only needed when modifying native code or performing a snapshot or release build.   docker Use docker builder containers to compile native library artifacts Only used when incuding the native profile or performing a snapshot or release build.   cross-compile Use cross-compilers on host to compile native library artifacts Only used when incuding the native profile or performing a snapshot or release build.   test-hardware Perform hardware integration testing EXPERIMENTAL   mac Use docker builder containers to compile native library artifacts (Same as docker profile) Automatically activated when running build from a MacOS host system.   windows Use docker builder containers to compile native library artifacts (Same as docker profile) Automatically activated when running build from a Windows host system.   transfer Perform SSH/SCP file transfers for each JAR to a remote Raspberry Pi Used for parallel development and testing.    You can activate a build profile using the -P{profile-name} argument in the Maven command:\nmvn clean install -Pjavadoc Release/Snapshot Builds Pi4J release and snapshot builds are reserved for the Pi4J Development Team. A release build ensures all JARs, resources, source-bundles, native libraries, and javadoc artifacts are compiled and deployed to the public Maven repositories. You can use the following command to perform all the build steps that would be performed during a release or snapshot build.\nmvn clean install -Drelease-build "},{"uri":"https://pi4j.com/documentation/","title":"Documentation","tags":[],"description":"","content":"Pi4J wants to provide the best possible solution for Java development on the Raspberry Pi for two use-cases.\n Do you want to develop an application without the need to touch the internal code of Pi4J?  In that case you\u0026rsquo;re at the right place for all the documentation you need! In this section you can find multiple examples to get you started.\n Do you want to go a few steps further and contribute to Pi4J, extend it with additional plugins or understand how it is build?  In that case you\u0026rsquo;ll find more information in the Architecture/Design section. Table of contents of the \u0026ldquo;Documentation\u0026rdquo; section  Pin numbering     Java for ARMv6/7/8     Logging with SLF4J     Creating a Pi4J Context     Choosing a Platform    Raspberry Pi      Choosing an I/O Provider    LinuxFS     PiGpio      Building an I/O Instance     I/O Examples    Digital Output (GPIO)     Digital Input (GPIO)     Pulse Width Modulation (PWM)     Inter-Integrated Circuit (I²C)    I²C Clock Stretching    Serial Peripheral Interface (SPI)     Serial (UART/RS232)      Devices examples     I/O Registry     Shutting down the Pi4J Context     Building and running    Building with javac     Build as a FAT JAR with Maven     Build Java modules with Maven     Build Java modules with Gradle     Running Pi4J with JBang      "},{"uri":"https://pi4j.com/getting-started/set-up-a-new-raspberry-pi/","title":"Set up a new Raspberry Pi","tags":[],"description":"","content":"Introduction The Raspberry Pi is a powerful machine with many use-cases. A lot of this power is based on the operating system you use. For our \u0026ldquo;Getting Started\u0026rdquo; examples we will be using the \u0026ldquo;official Raspberry Pi OS\u0026rdquo; (formerly known as \u0026ldquo;Raspbian OS\u0026rdquo;) but there is a long list of other possibilities which is listed for example on the\u0026ldquo;Awesome Raspberry Pi\u0026rdquo; list on GitHub.\nIn this article we start with a brand new Raspberry Pi board.\nStep-by-step First step: take your new Raspberry Pi out of the box of course :-)\nTake a good look at it, what you are holding in your hands is a true master piece. A wonder of technical engineering with a perfect mix of powerful yet inexpensive components.\nBut be aware! This is also some piece of sensitive electronics. It\u0026rsquo;s always a good idea to first touch the grounding pin of a power outlet to make sure your body is not electrically charged which could damage one of the components on the board.\nTODO add picture.\nMaterial list  Raspberry Pi Micro SD card, minimally 16Gb b PC (or other Raspberry Pi) with an SD card slot (maybe you will need an SD card adapter) Power supply (5V, 2 or 3A) Monitor, keyboard, mouse  SD card The SD card will hold the operating system. On the Raspberry Pi website, on the download page, you can find the Imager tool. Select the version for your computer, download and install it.\nStart the Imager and follow these steps:\n Click on \u0026ldquo;Operating System\u0026rdquo; \u0026gt; \u0026ldquo;CHOOSE OS\u0026rdquo; Select \u0026ldquo;Raspberry Pi OS (other)\u0026rdquo; Select \u0026ldquo;Raspberry Pi OS Full (32-bit)\u0026rdquo;                                           By selecting the \u0026ldquo;Full\u0026rdquo; edition, we will have an operating system which is preloaded with a load of additional tools, including \u0026ldquo;OpenJDK 11\u0026rdquo;, so will be able to take a quick start with Java development.\nPut your SD card into your computer or in an SD card reader you can connect to USB Click on \u0026ldquo;SD Card\u0026rdquo; \u0026gt; \u0026ldquo;CHOOSE SD CARD\u0026rdquo; Select the SD card  TODO add pictures\nFirst start-up Additional Raspberry Pi OS settings Check the Java version As we have put the Full edition on the SD card, Java is already available. Open a terminal window and type in java -version. Java will be started to show you the installed version.\n$ java -version openjdk version \u0026#34;11.0.9\u0026#34; 2020-10-20 OpenJDK Runtime Environment (build 11.0.9+11-post-Raspbian-1deb10u1) OpenJDK Server VM (build 11.0.9+11-post-Raspbian-1deb10u1, mixed mode) Install Pi4J TODO\nKeep your Raspberry Pi up-to-date Update to the latest version Open a terminal and perform following commands\nsudo apt update sudo apt full-upgrade Raspberry Pi OS is based on Debian - one of the largest Linux distrubutions. When running these commands regularly, you will keep your installation up to date for the particular major Raspberry Pi OS release you are using (e.g. Debian V9, aka Stretch). It will not update from one major release to another, for example, Stretch (V9) to Buster (V10).\n"},{"uri":"https://pi4j.com/about/new-in-v2/","title":"What&#39;s New (V.2)","tags":[],"description":"","content":"What\u0026rsquo;s New in 2.0? Pi4J version 2.0 brings with it many new features, and an entirely new architecture that focuses on extensibility, simplified integration and a modern Java API including the following:\n Fluent APIs/Interfaces Immutable Runtime Context Extensible Provider/Platform/Plug-in Architecture Builder-patterns for creating new I/O instances Well-documented source code Hardware PWM Support Java 11  Future plans:\n Dependency Injection via Pi4J Annotations Remote I/O Support (via TCP/IP)  In addition to the features listed above, Pi4J version 2.0 also abandons the old WiringPi pin numbering scheme in favor of the more traditional and commonly used Broadcom pin numbering scheme. This pin numbering scheme has been a source of confusion for a number of years, especially with beginners and is somewhat cumbersome to maintain as new Raspberry Pi models are introduces with differing or added GPIO pins. Moving forward, Pi4J will only use the Broadcom (BCM) pin numbering scheme.\nThe WiringPi project has now been deprecated (see wiringpi.com/wiringpi-deprecated/). Pi4J version 2.0 will no longer be based on WiringPi and has moved to using the PIGPIO library (http://abyz.me.uk/rpi/pigpio/) internally for low level integation. With this move, we will also support the remote I/O features (via TCP socket) offered by the PIGPIO daemon (http://abyz.me.uk/rpi/pigpio/pigpiod.html).\nWhat are the differences compared to V.1? Starting with the Pi4J 2.0 builds, the Pi4J project is prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform. Earlier versions of Pi4J were perhaps too ambitious in scope and that led to significant project bloat to the point that the project was becoming unsustainable. The goal moving forward is to limit scope to that of the raw I/O capabilities of the Raspberry Pi platform and provide timely updates and releases for bug fixed and new RaspberryPi model introductions. Reducing the scope of the project should better serve the Java community for basic I/O access by reducing complexity.\nThe following features have been removed from the Pi4J library:\n IO Expanders \u0026ndash; IO expansion is still supported but concrete implementations should be provided outside the core Pi4J core project such that they can be maintained and extended independently. Other Platforms \u0026ndash; Other platforms such as Odroid, BananaPi, NanoPi, OrangePi, etc. have been removed and will no longer be supported. The challenge with supporting these additional platforms is that Pi4J depends on the underlying WiringPi project and WiringPi ports for these other platforms is not well supported by the various SoC vendors or community. The various WiringPi ports for these other platforms are also inconsistent causing inconsistent features and functionality of Pi4J. Additionally, regression testing of bug fixes and new features in Pi4J is compounded with each additional supported platform. Components \u0026amp; Devices \u0026ndash; Pi4J originally provided higher level interfaces for components and devices that provided an abstraction layer between real world devices (things) and lower-level I/O interfaces. While a noble goal, unfortunately this part of the project never received the attention and time that it deserved and never gained much adoption by the community. We are removing these to allow Pi4J to focus solely on the raw I/O supported by the Raspberry Pi platform.  Sources The Pi4J V.2 source code is available in this GitHub repository: Pi4J V.2 GitHub Repository\ngit clone https://github.com/Pi4J/pi4j-v2 Pi4J V.2 had the first release in August 2021. Rework from V.1 to V.2 took quit some time and will never be finished, but we are confident this is a great library to develop Java application on the Raspberry Pi. Any remarks and contributions are welcome as either bug reports or discussions in the GitHub repository.\n"},{"uri":"https://pi4j.com/getting-started/understanding-the-pins/","title":"Understanding the GPIO pins","tags":[],"description":"","content":"Connecting electronic components to the Pi is done via one or more of the pins in the so-called header. The number of pins has \u0026ldquo;grown\u0026rdquo; between the different Raspberry Pi board versions, but all recent ones have a 40-pin header. It\u0026rsquo;s of course important to be aware of the correct numbering to not correct components the wrong way.\nType of pins The pins have different uses\nPower and ground Both 5V and 3.3V are available as power pins and, of course, also ground pins. Anytime the board is powered you have a fixed power supply available for your components. You have to take into account not to connect devices that need a lot of current, otherwise the Raspberry Pi itself will not behave as expected and reboot for instance.\nDigital GPIO The other ones are \u0026ldquo;General-Purpose Input/Output\u0026rdquo; (GPIO) pins. These pins can be addressed with software to act as input or output for an application. They use 3.3V, meaning an output pin will be set to 0V (low) or 3.3V (high) and an input pin will read 0V as low and 3.3V as high.\nMost of the GPIOs have an internal pull-up or pull-down resistor which can be enabled in software.\nOverview The following image gives you an overview of the pins and types of a typical 40-pin header. Note the different numbers being used:\n PIN: 1 to 40 logical order of the pin BCM: the number to be used in your Java code to specify the GPIO to be used. BCM refers to the \u0026ldquo;Broadcom SOC channel\u0026rdquo; number, which is the numbering inside the chip which is used on the Raspberry Pi. These numbers changed between board versions as you can see in the previous tables for the 26-pin header type 1 versus 2, and or not sequential. WPI: WiringPi number which was used by V.1 of Pi4J. The WiringPi numbering has a \u0026ldquo;historical reason\u0026rdquo;. When development for the very first Raspberry Pi\u0026rsquo;s was ongoing, only 8 pin-numbers were foreseen. But, when the designs further evolved and more pins were added, the numbering in WiringPi was extended to be able to address the extra pins.  "},{"uri":"https://pi4j.com/architecture/","title":"Architecture/Design","tags":[],"description":"","content":"The code of Pi4J is based on a layered approach, visualized in the picture below.\nSince Pi4J is a low-level library, it tries to avoid inheriting third-party libraries at all costs. More complex dependency chains make it more difficult for users, especially novice users. Therefor, the only dependency Pi4J V.2 has is SLF4J to provide a standardized and extensible logging framework.\nThe dark grey blocks \u0026ldquo;Annotation Engine\u0026rdquo;, \u0026ldquo;@Register\u0026rdquo; and \u0026ldquo;@Inject\u0026rdquo; are here as a future idea but are not included in the current V2.\n"},{"uri":"https://pi4j.com/architecture/about-the-code/download/install/","title":"Installation","tags":[],"description":"","content":"This project is still in development and thus no package installers are available at this time.\n"},{"uri":"https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/","title":"Java development with VSC","tags":["Visual Studio Code"],"description":"","content":"Java on the Raspberry Pi To use Pi4J V2 you\u0026rsquo;ll need Java 11 or newer. Luckily this version is included in the current version of Raspberry Pi OS. In the release notes you can see that the version of 2019-06-20 includes OpenJDK Java 11:\n2019-06-20: Based on Debian Buster Oracle Java 7 and 8 replaced with OpenJDK 11 But you will need to keep in mind this version is only compatible with ARMv7 or higher and doesn\u0026rsquo;t support all Raspberry Pi board versions. If you have a Raspberry Pi A (version 3), B (version 2 or higher), or Compute (version 3 or higher), you are good to go! For all other boards you will need some additional steps that are described on \u0026ldquo;Java for ARMv6/7/8\u0026rdquo;.\nIf you prepared a microSD card with the latest version of Raspberry Pi OS (full version), as described on \u0026ldquo;Set up a new Raspberry Pi\u0026rdquo;, you can check the installed Java version in the terminal. On a board with ARMv7 or ARMv8 you will get this result:\n$ java -version openjdk version \u0026#34;11.0.3\u0026#34; 2019-04-16 OpenJDK Runtime Environment (build 11.0.3+7-post-Raspbian-5) OpenJDK Server VM (build 11.0.3+7-post-Raspbian-5, mixed mode) If you get an error like below, you\u0026rsquo;ll need to follow the steps described on \u0026ldquo;Java for ARMv6/7/8\u0026rdquo;.\n$ java -version Error occurred during initialization of VM Server VM is only supported on ARMv7+ VFP Maven Pi4J is using Maven as build tool, this allows you to compile your code with the required modules into JAR-file thanks to the pom.xml configuration file which you can find in the root of a project. We need to install Maven and can do this with a single command, after which we can immediately check the installation by requesting the version:\n$ sudo apt install maven $ mvn -v Apache Maven 3.6.0 Maven home: /usr/share/maven Visual Studio Code Visual Studio Code (VSC) is the free IDE (Integrated Developer Environment) by Microsoft. It\u0026rsquo;s designed as a universal tool that you can use for multiple programming languages with extensions. On your Raspberry Pi open a web browser, go to the \u0026ldquo;VSC Download page (code.visualstudio.com/Download)\u0026quot; and select the \u0026ldquo;Linux .deb ARM\u0026rdquo; version.\n    Download page for VSC\n      VSC in the list of programming tools\n      VSC running on the Raspberry Pi with Maven and Java Extension Pack\n                               When the download is finished, open a terminal, go to the Download directory and install the downloaded deb-file like this:\n$ cd /home/pi/Downloads $ sudo apt install ./code_1.53.0-1612367698_armhf.deb Since 02/2021 there is even an easier way, as Visual Studio Code is now available as a Raspberry Pi OS apt package. Use the following commands:\n$ sudo apt update $ sudo apt install code -y "},{"uri":"https://pi4j.com/architecture/about-the-code/maven-settings/","title":"Maven settings","tags":[],"description":"","content":"To simplify development but not commit sensitive information, you can add personal or PC-specific settings in the Maven settings.xml file. This file is stored or needs to be created in the \u0026ldquo;.m2\u0026rdquo; directory in your home directory:\n Windows: C:\\Users\\YOUR_NAME.m2 Linux: /home/YOUR_NAME/.m2 Mac: /Users/YOUR_NAME/.m2  For more info see this article on Baeldung.\nThis is an example settings file, including settings for compiling of Pi4J and credentials to upload the generated code to a Raspberry Pi.\n\u0026lt;settings xmlns=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd\u0026quot;\u0026gt; \u0026lt;localRepository/\u0026gt; \u0026lt;interactiveMode/\u0026gt; \u0026lt;offline/\u0026gt; \u0026lt;pluginGroups/\u0026gt; \u0026lt;servers/\u0026gt; \u0026lt;mirrors/\u0026gt; \u0026lt;proxies/\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;pi4j\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- Docker compiler settings --\u0026gt; \u0026lt;pi4j.native.compiler\u0026gt;DOCKER-COMPILER\u0026lt;/pi4j.native.compiler\u0026gt; \u0026lt;!-- SSH credentials of your test Raspberry Pi --\u0026gt; \u0026lt;pi4j.dev.transfer\u0026gt;false\u0026lt;/pi4j.dev.transfer\u0026gt; \u0026lt;pi4j.dev.host\u0026gt;192.168.1.1\u0026lt;/pi4j.dev.host\u0026gt; \u0026lt;pi4j.dev.port\u0026gt;22\u0026lt;/pi4j.dev.port\u0026gt; \u0026lt;pi4j.dev.user\u0026gt;pi\u0026lt;/pi4j.dev.user\u0026gt; \u0026lt;pi4j.dev.password\u0026gt;raspberry\u0026lt;/pi4j.dev.password\u0026gt; \u0026lt;pi4j.dev.directory\u0026gt;/home/pi/pi4j-temp\u0026lt;/pi4j.dev.directory\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;activeProfiles\u0026gt; \u0026lt;activeProfile\u0026gt;pi4j\u0026lt;/activeProfile\u0026gt; \u0026lt;/activeProfiles\u0026gt; \u0026lt;/settings\u0026gt; "},{"uri":"https://pi4j.com/documentation/pin-numbering/","title":"Pin numbering","tags":[],"description":"","content":"Pi4J V.1 took a pretty opinionated approach to pin numbering as the scheme was based on the underlying WiringPi. This scheme was incompatibility with other pin diagrams and pin numbering used by other development platforms and libraries.\nAs Pi4J V.2 is build as a \u0026ldquo;pass thru library\u0026rdquo;, and uses PiGpio as the underlying framework, the more well-known BCM numbering is being used now.\nThis drawing shows the different numbers for WiringPi and BCM in a 40-pins Raspberry Pi header:\n"},{"uri":"https://pi4j.com/about/release-notes/","title":"Release Notes","tags":[],"description":"","content":"Release notes of Pi4J V2 are available on github.com/Pi4J/pi4j-v2/releases.\n"},{"uri":"https://pi4j.com/getting-started/developing-on-a-remote-pc/","title":"Developing on a remote PC","tags":["Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-maven-archetype\n Developing Java programs using a remote PC workstation Writing your Java program, compiling and running it directly on the Raspberry Pi board as shown in the previous chapter is perfectly fine, of course, but there is an alternative way to arrange your developing laboratory, using a normal desktop computer as Remote Developing Workstation (RDW).\nThis Maven Archetype will give you a tool to generate Pi4J-V2 skeleton Java projects. You can use it for your next Pi4j project and you will be able to develop your program on the remote workstation (RDW), compile them, transmit the executable code on the target Pi board and run it. You can also start a remote debugging session.\nThere are some pros. and cons. in such a developing arrangement:\n Pros:  Your RDW has much more resources like memory, disk capacity and CPU power than a Raspberry Pi, and this is true for a P4 model too. You can store all your programs in the desktop computer. You do not have to install on the Raspberry Pi the Visual Studio Code (or your preferred IDE program), the Java JDK (JRE it is enough), Maven and the other development tools. You do not need to connect the screen, the keyboard and the mouse to the Raspberry Pi You can use smaller PI models   Cons:  You can\u0026rsquo;t run Web applications (using a web container like Tomcat or similar)    Setting up Configure the RPi for Headless mode The Headless Mode configuration enables the RPi board to communicate with the RDW over SSH protocol.\nThese are the needed steps:\n Check if the RDW is equipped with a SSH Client. If the RDW OS is Linux you already have it For Windows you can use putty, MobaXterm or you can enable the (new) OpenSsh Client porting on Windows 10 Connect both the RPi and RDW to your local network Follow this guide to configure your RPi Install the Maven tool on the RDW  You should now be able to open a SSH Terminal window on RDW and to remotely login on the RPi board.\nInstall the raspimaven-archetype Goto the Github Pi4J Project and download the project clicking on the green Code button and selecting Download ZIP\n Unzip the archetype file in a FOLDER cd FOLDER/pi4j-maven-archetype-master mvn install  Congratulation ! - Now you are ready to generate your first Project Template\nGenerate a new Project Template Let suppose you want to begin the new wonderful PI4J-V2 project my-project, to do this follow these steps:\n mkdir my-project cd my-project mvn archetype:generate -DarchetypeCatalog=local answer to the questions the archetype asks you (see below for details)  Configuring your new project Before starting the new project generation, the archetype asks some configuration data. The list of question and the replies are shown here below:\n Choose archetype: select the raspimaven-archetype from the list proposed Define value for property \u0026lsquo;groupId\u0026rsquo;: choose the Maven groupId for your project. (If don\u0026rsquo;t know what is a groupId, don\u0026rsquo;t worry, just type \u0026ldquo;com.example\u0026rdquo; for now) Define value for property \u0026lsquo;artifactId\u0026rsquo;: choose a name for the program executable your project will produce Define value for property \u0026lsquo;version\u0026rsquo;: 1.0-SNAPSHOT: type Enter to accept the default value shown, or type the initial program version, something like 1.0.0 Define value for property \u0026lsquo;package\u0026rsquo;: com.example: type Enter to accept the default value shown  The archetype now shows you a summary of the configuration parameters you have just typed in, plus the values proposed for the main-class and package parameters. If the list is ok for you, reply Y to accept, otherwise reply N to change one or more values (you will have to re-type all parameter values \u0026hellip;)\nAfter the list confirmation, the archetype generates a new maven project template for you.\nCongratulations\nYou should be able to open the new project with your preferred java IDE. The IDE should be able to recognize the project as a valid Maven project.\nNote on the Java runtime If you are not using the default Raspberry Pi OS full edition and/or included Java, you may get this kind of error:\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:3.0.0:run (exec) on project ...: An Ant BuildException has occured: The following error occurred while executing this line: [ERROR] ...\\antrun\\build.xml:166: The following error occurred while executing this line: [ERROR] ...\\antrun\\build.xml:123: Remote command failed with exit status 1 [ERROR] around Ant part ...... @ 9:59 in ...\\antrun\\build-main.xml This can be caused by a mis-configured Java runtime. The default value in raspberry.properties is:\ntarget.remote.jre=/usr/lib/jvm/default-java Check if this value exists and links to your Java runtime, or find the location of your installed JDK with sudo find / -iname java and use the result in your configuration.\nFor instance: a Raspberry Pi Zero (type 1) with ARMv6 requires a specific Java version for this type of processor. This is described more in detail on \u0026ldquo;Java for ARMv6/7/8\u0026rdquo;. If you use Azul Zulu JDK, you will need to change the configuration to:\ntarget.remote.jre=/usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf Explore the new project template Feel free to explore the new project familiarizing with the folder structure. These are the most important features:\n The file README.md contains the intruction to configure the connection(s) to your RPi board(s) and the decription of the Maven commands to build your project, transfer the executable code to the target RPi, run it and also open a debugger session. The pom.xml file already includes the dependencies needed to compile your program with the JPi4J-V2 libraries. The platform folder contains an example configuration file for connecting to you RPi board. Read the README.md explanation, open the platform/raspberry.properties file (or copy it to a new file) and edit it to describe how to connect to your RPi   Thanks to Adi and Luca Buraggi for this contribution.\n"},{"uri":"https://pi4j.com/architecture/about-the-code/code-styling/","title":"Code styling","tags":[],"description":"","content":"To prevent unnecessary code (tabs versus spaces, number of characters per line\u0026hellip;) we have defined an editorconfig for IntelliJ IDEA. You can find more info here about its use.\nSome tips to keep the code clean and readable:\n Short methods with a clear name Use SonarLint to get improvement tips while code Use shortcuts  CTRL+ALT+L: Reformat code CTRL+ALT+O: Optimize imports    "},{"uri":"https://pi4j.com/featured-projects/","title":"Featured Projects","tags":[],"description":"","content":" Did you use Pi4J in one of your projects? We would love to hear from you!  Please let us know by sending an e-mail to frank at pi4j.com with a brief description, URL, links and pictures of the product or project you are working on.\n   Soft real time PLC  Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available. Conveyors for containers filled by a dispensing robot\n PiJukeBox  Daniel Mårtensson used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators. Features: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi\u0026rsquo;s, terminal based.\n Cocktail Maker  The CocktailMaker is a cocktail mixing machine by Alexander Liggesmeyer. It can control as many pumps as the RaspberryPi provides GPIO pins. For every pump that gets added to the system, the user has to provide the amount of time that that pump needs to pump one centiliter in milliseconds. The machine uses peristaltic pumps. So that number is perfectly accurate. The flow rate won\u0026rsquo;t vary over time. It uses a relay board for closing the electronic circuit for all pumps.\n Didier the street artist robot  Meet \u0026ldquo;Didier\u0026rdquo; the street artist robot, a project by Duvam. The sources are shared on github.com/duvamduvam/didier-java.  JMonkeyEngine with Joystick  Pavl G. created a Java Gradle library to control a car in a JMonkeyEngine game with an arduino joystick module connected to a Raspberry Pi4 model B, using GPIO digital pins and SPI interfacing through MCP3008 ADC (Analog~Digital Converter). Requirements Raspberry Pi with arm processor (pi3, pi4, piZero) with a working java8 (preferred). Female-to-male jumper wires. Breadboard. Arduino Joystick module. MCP3008 IC (ADC \u0026ndash; other adcs may work too, but we are covering only MCP3008 here).\n  "},{"uri":"https://pi4j.com/architecture/about-the-code/hardware-testing/","title":"Hardware testing","tags":[],"description":"","content":" This is an experimental project which will need a lot of love\u0026hellip; The new Raspberry Pi Pico with a lot of GPIOs for a very low price, seems even to be a better fit for this project compared to the Arduino Due\u0026hellip; To be further investigated!\n To minimize the required time and efforts to test a new release, V.2 aims to include an automated test which performs I/O testing on each I/O interface on each model of RPi. Ideally this would happen as part of the unit testing sequence for each code commit or at least as part of the release cycle.\nTo achieve this, an Arduino Due board with lots of on board I/O capability is being used. The firmware that gets loaded onto the Arduino board listens on the serial port for instructions on which pins to use and what type of test to perform. The \u0026ldquo;Test Harness\u0026rdquo; project also includes a Java library that is used to communicate with the Arduino and instrument tests.\nNext, a given I/O provider plugin includes test classes that instrument the test harness and perform live I/O testing between the SBC (or other hardware) and the Arduino Test Harness.\nTo be able to fully test all board types, a custom PCB needs to be created to perform all the interconnects between the Raspberry Pi 26-pin/40-pin headers, and the Arduino board. This way enough test harnesses could be build for each Raspberry Pi model and have a permanent setup for on-demand testing. This of course is a huge effort just by itself, and perhaps too ambitious \u0026ndash; but seeking a means to reach automated testing is really needed for the long term.\n"},{"uri":"https://pi4j.com/documentation/java-installation/","title":"Java for ARMv6/7/8","tags":[],"description":"","content":" Raspberry Pi OS Full comes with Java 11 pre-installed. But this version only works on board-versions with an ARMv7 or ARMv8. In some cases you will need to do some additional steps to install a Java version which works on your board.\n Board versions With ARMv6 processor  Raspberry Pi 1 A and A+ Raspberry Pi 1 B and B+ Compute Module 1 Zero 1.2, 1.3 and W  With ARMv7 or ARMv8 processor  Model A+, version 3 Model B, version 2, 3 and 4 Compute Module, version 3  How to check and install Java Check the current version If you prepared a microSD card with the latest version of Raspbian OS (full version), Java is already installed! You can check the installed Java version in the terminal. On a board with ARMv7 or ARMv8 you will get this result:\n$ java -version openjdk version \u0026quot;11.0.3\u0026quot; 2019-04-16 OpenJDK Runtime Environment (build 11.0.3+7-post-Raspbian-5) OpenJDK Server VM (build 11.0.3+7-post-Raspbian-5, mixed mode) On an ARMv6 version, you will get an error:\n$ java -version Error occurred during initialization of VM Server VM is only supported on ARMv7+ VFP Check your board version If you are not sure which type of board you have, you can check this in the terminal with cat /proc/cpuinfo, for instance for a Raspberry Pi B+ 1.2:\n$ cat /proc/cpuinfo processor\t: 0 model name\t: ARMv6-compatible processor rev 7 (v6l) BogoMIPS\t: 697.95 Features\t: half thumb fastmult vfp edsp java tls CPU implementer\t: 0x41 CPU architecture: 7 CPU variant\t: 0x0 CPU part\t: 0xb76 CPU revision\t: 7 Hardware\t: BCM2835 Revision\t: 0010 Serial\t: 000000005f9ba615 Model\t: Raspberry Pi Model B Plus Rev 1.2 Install Java 11 on ARMv6 The sources for Java are available as open-source on OpenJDK, which means, if you can\u0026rsquo;t find the correct version for a specific board, it is possible to compile it yourself. Luckily there are different suppliers providing ready-made packages of the JDK for multiple platforms. But only Azul seems to have one which is a perfect fit for Raspberry Pi\u0026rsquo;s with an ARMv6: the Zulu community edition of JDK 11.\nTo get started with Zulu JDK, download and uncompress it to your board:\n$ cd /usr/lib/jvm $ sudo wget https://cdn.azul.com/zulu-embedded/bin/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ sudo tar -xzvf zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ sudo rm zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ ls -l total 12 lrwxrwxrwx 1 root root 21 Jul 23 15:58 java-1.11.0-openjdk-armhf -\u0026gt; java-11-openjdk-armhf drwxr-xr-x 9 root root 4096 Aug 20 11:41 java-11-openjdk-armhf drwxr-xr-x 2 root root 4096 Aug 20 11:41 openjdk-11 drwxrwxr-x 10 111 122 4096 Jul 10 16:50 zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf Now we have the JDK11 ready to be used, but it still needs to be configured so the OS is aware of it.\n$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java 1 $ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac 1 At this moment we can select the new JDK to link it to the “java” and “javac” command.\n$ sudo update-alternatives --config java There are 2 choices for the alternative java (providing /usr/bin/java). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/java-11-openjdk-armhf/bin/java 1111 auto mode 1 /usr/lib/jvm/java-11-openjdk-armhf/bin/java 1111 manual mode 2 /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java 1 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 2 update-alternatives: using /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java to provide /usr/bin/java (java) in manual mode $ sudo update-alternatives --config javac There are 2 choices for the alternative javac (providing /usr/bin/javac). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/java-11-openjdk-armhf/bin/javac 1111 auto mode 1 /usr/lib/jvm/java-11-openjdk-armhf/bin/javac 1111 manual mode 2 /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac 1 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 2 update-alternatives: using /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac to provide /usr/bin/javac (javac) in manual mode Now let\u0026rsquo;s check the Java version:\n$ java -version openjdk version \u0026quot;11.0.8\u0026quot; 2020-07-14 LTS OpenJDK Runtime Environment Zulu11.41+75-CA (build 11.0.8+10-LTS) OpenJDK Client VM Zulu11.41+75-CA (build 11.0.8+10-LTS, mixed mode) OK, ready to run Java 11 applications on the Raspberry Pi with ARMv6!\nMore info If you want more info, or use JavaFX, check these blog posts:\n Installing Java and JavaFX on the Raspberry Pi (for ARMv7+) How to install and use Java 11 and JavaFX 11 on Raspberry Pi boards with ARMv6 processor  "},{"uri":"https://pi4j.com/about/license/","title":"License (Open Source)","tags":[],"description":"","content":"The Pi4J Version 2.0 project is distributed and licensed under the Apache License, Version 2.0 license (A business-friendly OSS license).\n apache.org/licenses/LICENSE-2.0 github.com/Pi4J/pi4j-v2/blob/master/LICENSE.txt   Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n  Definitions.\n\u0026ldquo;License\u0026rdquo; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n\u0026ldquo;Licensor\u0026rdquo; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n\u0026ldquo;Legal Entity\u0026rdquo; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026ldquo;control\u0026rdquo; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\u0026ldquo;You\u0026rdquo; (or \u0026ldquo;Your\u0026rdquo;) shall mean an individual or Legal Entity exercising permissions granted by this License.\n\u0026ldquo;Source\u0026rdquo; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.\n\u0026ldquo;Object\u0026rdquo; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.\n\u0026ldquo;Work\u0026rdquo; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).\n\u0026ldquo;Derivative Works\u0026rdquo; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.\n\u0026ldquo;Contribution\u0026rdquo; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026ldquo;submitted\u0026rdquo; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026ldquo;Not a Contribution.\u0026rdquo;\n\u0026ldquo;Contributor\u0026rdquo; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.\n  Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.\n  Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.\n  Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and\n(b) You must cause any modified files to carry prominent notices stating that You changed the files; and\n(c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and\n(d) If the Work includes a \u0026ldquo;NOTICE\u0026rdquo; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\nYou may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\n  Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.\n  Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.\n  Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.\n  Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.\n  Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.\n  END OF TERMS AND CONDITIONS\nAPPENDIX: How to apply the Apache License to your work.\n To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026quot;[]\u0026quot; replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026quot;printed page\u0026quot; as the copyright notice for easier identification within third-party archives.  Copyright (C) 2012 - 2019 Pi4J\nLicensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\n"},{"uri":"https://pi4j.com/getting-started/minimal-example-application/","title":"Minimal example application","tags":["Digital Input","Digital Output","Maven","Gradle"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\n In the \u0026ldquo;pi4j-example-minimal\u0026rdquo; GitHub project you can find a project which contains the minimal code to control a digital input and output with Pi4J. The project is further described on this page. The application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.\n  Wiring This minimal example application uses this wiring:\nBuilding the application The main build tool used by the Pi4J project is Maven, but for this example we provided both the Maven and Gradle approach, so you can select the tool you prefer.\nMaven This project can be built with Apache Maven 3.6 (or later) and Java 11 OpenJDK (or later). These prerequisites must be installed prior to building this project as described on the previous pages. The following command can be used to download all project dependencies and compile the Java module. You can build this project directly on a Raspberry Pi with Java 11+.\nmvn clean package Gradle You can also use the Gradle Build Tool from these same sources. Use version 6.6 (or later) and Java 11 OpenJDK (or later). The Gradle wrapper is used as described on docs.gradle.org. The Gradle configuration file build.gradle-file is included in the sources.\nOn Linux:\n./gradlew build On Windows:\ngradlew.bat build Dependency in pom.xml For the Maven approach, a pom.xml file defines all the dependencies, and the build process.\nIn this project we will be using slf4 for logging, pi4j-core and the pi4j-plugins for the Raspberry Pi and PiGPIO. To make the versions easy to update, we add those numbers as properties.\n\u0026lt;properties\u0026gt; \u0026lt;!-- DEPENDENCIES VERSIONS --\u0026gt; \u0026lt;slf4j.version\u0026gt;1.7.32\u0026lt;/slf4j.version\u0026gt; \u0026lt;pi4j.version\u0026gt;2.0\u0026lt;/pi4j.version\u0026gt; \u0026lt;/properties\u0026gt; These are the dependencies we need:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- include Pi4J Core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- include Pi4J Plugins (Platforms and I/O Providers) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-pigpio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Pi4J code blocks which are used Initialization Before you can use Pi4J you must initialize a new runtime context.\nThe Pi4J static class includes a few helper context creators for the most common use cases. The newAutoContext() method will automatically load all available Pi4J extensions found in the application\u0026rsquo;s classpath which may include Platforms and I/O Providers.\nvar pi4j = Pi4J.newAutoContext(); Output Pi4J Context information The library contains helper functions to output info about the available and used platforms and providers. To keep the example code clean, these are part of the PrintInfo.java class. For example to print the loaded platforms:\nPlatforms platforms = pi4j.platforms(); console.box(\u0026#34;Pi4J PLATFORMS\u0026#34;); console.println(); platforms.describe().print(System.out); console.println(); Handle the button presses To handle digital input events we first need a configuration for it. With that configuration, Pi4J can create the object for us and the state changes can be handled.\nprivate static int pressCount = 0; private static final int PIN_BUTTON = 24; // PIN 18 = BCM 24  var buttonConfig = DigitalInput.newConfigBuilder(pi4j) .id(\u0026#34;button\u0026#34;) .name(\u0026#34;Press button\u0026#34;) .address(PIN_BUTTON) .pull(PullResistance.PULL_DOWN) .debounce(3000L) .provider(\u0026#34;pigpio-digital-input\u0026#34;); var button = pi4j.create(buttonConfig); button.addListener(e -\u0026gt; { if (e.state() == DigitalState.LOW) { pressCount++; console.println(\u0026#34;Button was pressed for the \u0026#34; + pressCount + \u0026#34;th time\u0026#34;); } }); Toggle a LED For the LED we use a similar approach with a configuration. The created led-object can be used to toggle its state.\nprivate static final int PIN_LED = 22; // PIN 15 = BCM 22  var ledConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;led\u0026#34;) .name(\u0026#34;LED Flasher\u0026#34;) .address(PIN_LED) .shutdown(DigitalState.LOW) .initial(DigitalState.LOW) .provider(\u0026#34;pigpio-digital-output\u0026#34;); var led = pi4j.create(ledConfig); while (pressCount \u0026lt; 5) { if (led.equals(DigitalState.HIGH)) { led.low(); } else { led.high(); } Thread.sleep(500 / (pressCount + 1)); } Closing the application Before the application quits, we need to call the shutdown() function on the Pi4J static helper class. This will ensure that all I/O instances are properly shutdown, released by the system and shutdown in the appropriate manner. Termination will also ensure that any background threads/processes are cleanly shutdown and any used memory is returned to the system.\npi4j.shutdown(); Steps to run this application on your Raspberry Pi  Attach a LED and button as shown in the image above Use a recent Raspbian OS image which has Java 11. To check if you have the correct Java version in the terminal:  $ java -version openjdk version \u0026#34;11.0.6\u0026#34; 2020-01-14 OpenJDK Runtime Environment (build 11.0.6+10-post-Raspbian-1deb10u1) OpenJDK Server VM (build 11.0.6+10-post-Raspbian-1deb10u1, mixed mode)  Download the project from GitHub and build it:  $ git clone https://github.com/Pi4J/pi4j-example-minimal.git $ cd pi4j-example-minimal/ $ mvn clean package  Change to the distribution directory where you can find the generated package and required Java-modules. Start it with the provided run.sh script:  $ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 364456 Jun 19 10:04 pi4j-core-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 7243 Jun 19 10:04 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 142461 Jun 19 10:04 pi4j-library-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 37302 Jun 19 10:04 pi4j-plugin-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 26917 Jun 19 10:04 pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run.sh -rw-r--r-- 1 pi pi 52173 Jun 19 10:04 slf4j-api-2.0.0-alpha0.jar -rw-r--r-- 1 pi pi 15372 Jun 19 10:04 slf4j-simple-2.0.0-alpha0.jar $ sudo ./run.sh  The output will first show you some info about the platforms and providers. Then the LED starts blinking and shows how many times you pushed the button:  LED high LED low LED high Button was pressed for the 1th time LED low LED high Button was pressed for the 2th time LED low LED high LED low LED high Button was pressed for the 3th time LED low LED high LED low LED high Button was pressed for the 4th time LED low LED high LED low LED high Button was pressed for the 5th time  If you get an error like shown below, you probably didn\u0026rsquo;t start the application with sudo, which is (at the moment) required for the PiGpio native library that handles the interfacing with the GPIOs.  WARN com.pi4j.library.pigpio.impl.PiGpioNativeImpl - PIGPIO ERROR: PI_INIT_FAILED; pigpio initialisation failedWARN com.pi4j.library.pigpio.impl.PiGpioNativeImpl - PIGPIO ERROR: PI_INIT_FAILED; pigpio initialisation failed "},{"uri":"https://pi4j.com/getting-started/minimal-example-application-fatjar/","title":"Minimal example as FAT JAR","tags":["Digital Input","Digital Output","FatJAR"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fatjar\n The \u0026ldquo;Minimal example application\u0026rdquo; uses one LED and button to demonstrate the basic use of Pi4J V2. When building that project with Maven, all the required Java modules are copied to the target/distribution directory. But a lot of developers like to produce a single, executable JAR that contains all dependencies, also known as a \u0026ldquo;FAT JAR\u0026rdquo;.\nThe repository \u0026ldquo;pi4j-example-fatjar\u0026rdquo; GitHub project contains a Maven project with identical wiring, dependencies and build command to the \u0026ldquo;Minimal example application\u0026rdquo;, but results in such a FAT JAR instead of separate Java modules.\nMaven plugins By using three build plugins the FAT JAR is created:\n maven-compiler-plugin maven-jar-plugin maven-shade-plugin  For the full description, take a look at the README.md in the sources and the page \u0026ldquo;Build as a FAT JAR with Maven\u0026rdquo;.\nBuilding and running Build with:\nmvn clean package Once the build is complete and was successful, you can find the compiled FAT JAR pi4j-example-fatjar.jar in the target directory. You can build directly on your Raspberry Pi or if you are developing on a different computer, copy the file to your Raspberry Pi with (in this example the Pi has IP 192.168.0.252):\nscp target/pi4j-example-fatjar.jar pi@192.168.0.252://home/pi On the Raspberry Pi open a terminal, or via SSH from your PC, execute this command:\n$ sudo java -jar pi4j-example-fatjar.jar [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - \u0026lt;-- The Pi4J Project --\u0026gt; [main] INFO com.pi4j.util.Console - Minimal Example project [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PLATFORMS | [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - PLATFORMS: [1] \u0026quot;Pi4J Runtime Platforms\u0026quot; \u0026lt;com.pi4j.platform.impl.DefaultPlatforms\u0026gt; └─PLATFORM: \u0026quot;RaspberryPi Platform\u0026quot; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - | Pi4J DEFAULT PLATFORM | [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - PLATFORM: \u0026quot;RaspberryPi Platform\u0026quot; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PROVIDERS | [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - PROVIDERS: [12] \u0026quot;I/O Providers\u0026quot; \u0026lt;com.pi4j.provider.impl.DefaultProviders\u0026gt; ├─SPI: [2] \u0026lt;com.pi4j.io.spi.SpiProvider\u0026gt; │ ├─PROVIDER: \u0026quot;PiGpio SPI Provider\u0026quot; {pigpio-spi} \u0026lt;com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl} │ └─PROVIDER: \u0026quot;RaspberryPi SPI Provider\u0026quot; {raspberrypi-spi} \u0026lt;com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl} ├─ANALOG_INPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogInputProvider\u0026gt; ├─SERIAL: [2] \u0026lt;com.pi4j.io.serial.SerialProvider\u0026gt; │ ├─PROVIDER: \u0026quot;PiGpio Serial Provider\u0026quot; {pigpio-serial} \u0026lt;com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl} │ └─PROVIDER: \u0026quot;RaspberryPi Serial Provider\u0026quot; {raspberrypi-serial} \u0026lt;com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl} ├─DIGITAL_INPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalInputProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi Digital Input (GPIO) Provider\u0026quot; {raspberrypi-digital-input} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio Digital Input (GPIO) Provider\u0026quot; {pigpio-digital-input} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl} ├─I2C: [2] \u0026lt;com.pi4j.io.i2c.I2CProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi I2C Provider\u0026quot; {raspberrypi-i2c} \u0026lt;com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio I2C Provider\u0026quot; {pigpio-i2c} \u0026lt;com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl} ├─ANALOG_OUTPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogOutputProvider\u0026gt; ├─DIGITAL_OUTPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalOutputProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi Digital Output (GPIO) Provider\u0026quot; {raspberrypi-digital-output} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio Digital Output (GPIO) Provider\u0026quot; {pigpio-digital-output} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl} └─PWM: [2] \u0026lt;com.pi4j.io.pwm.PwmProvider\u0026gt; ├─PROVIDER: \u0026quot;RaspberryPi PWM Provider\u0026quot; {raspberrypi-pwm} \u0026lt;com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl} └─PROVIDER: \u0026quot;PiGpio PWM Provider\u0026quot; {pigpio-pwm} \u0026lt;com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ------------------- [main] INFO com.pi4j.util.Console - | Pi4J REGISTRY | [main] INFO com.pi4j.util.Console - ------------------- [main] INFO com.pi4j.util.Console - REGISTRY: [2] \u0026quot;I/O Registered Instances\u0026quot; \u0026lt;com.pi4j.registry.impl.DefaultRegistry\u0026gt; ├─IO: \u0026quot;LED Flasher\u0026quot; {led} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutput\u0026gt; {DOUT-22} └─IO: \u0026quot;Press button\u0026quot; {button} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInput\u0026gt; {DIN-24} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high ... [main] INFO com.pi4j.util.Console - LED high [Thread-1] INFO com.pi4j.util.Console - Button was pressed for the 1th time [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [Thread-3] INFO com.pi4j.util.Console - Button was pressed for the 2th time [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high ... "},{"uri":"https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/","title":"Soft real time PLC","tags":[],"description":"","content":"Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available.\n    Conveyors for containers filled by a dispensing robot\n      eSyBox using pi4j to communicate with the Raspberry Pi\u0026#39;s I2C bus\n      eSyBox slot detection in action\n                               These are projects by the company atexxi.ch.\nA soft real time PLC written in Java running on Strolch This PLC project by Robert von Burg combines Pi4j, Strolch and the Raspberry Pi.\nIt is being used in a material flow controller which coordinates FromStock orders with a medical dispensing robot and dispenses the packets into containers. These containers are then moved by a Strolch based PLC. The containers travel on a 12m long conveyor with multiple segments and entry/exits to position the container at the dispensing robot\u0026rsquo;s exit.\nMedical cabinet with pick-by-light The most recent project are medical cabinets which use I2C to communicate with custom electronics to control the locks, perform a pick-by-light from slots and uses infrared to detect access to a slot with products in it.\n"},{"uri":"https://pi4j.com/architecture/advanced/","title":"Advanced","tags":[],"description":"","content":"Pi4J V2 tries to focus on its core functionality (the GPIO I/O) but at the same time wants to provide the possibility to extend and adapt to other hardware, underlying framework etc.\nYou can find more info on these pages about some of the current functionalities to achieve this:\n Annotated provisioning   Dependency injection   Native Library Path   Plug-ins   Remote support   Third-Party Integration   "},{"uri":"https://pi4j.com/getting-started/crowpi/","title":"Electronics with CrowPi","tags":["CrowPi"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-crowpi\n For this example we are going to use a CrowPi, which is a starter kit in a laptop-housing. Of course, you can get any electronics starter kit for this purpose or buy separate components. That\u0026rsquo;s the fun of electronics: components are inexpensive and easy to find on ebay or one of the many web shops.\n    CrowPi 1\n      CrowPi 2\n      Example electronics starter kit\n                               As the CrowPi contains a lot of components, this example is described on the following subpages:\n CrowPi OS   Develop with Intellij IDEA   The CrowPi sources and documentation are provided by the Swiss FHNW University based on a project in 2021 by Pascal Mathis and Tobias Siegrist under supervision of Barbara Scheuner and Dieter Holz. The original documentation (in German) is available on \u0026ldquo;CrowPi goes Java\u0026rdquo; (with sources on GitHub).\n "},{"uri":"https://pi4j.com/documentation/logging/","title":"Logging with SLF4J","tags":[],"description":"","content":"Pi4J uses SLF4J for logging. To include it in your project, add this Maven dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0-alpha0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; There are different ways to configure the logging output, as described on the SLF4J website, but the shortest is probably with this property in your main-method:\npublic static void main(String[] args) throws Exception { // Configure default lolling level, accept a log level as the first program argument  System.setProperty(\u0026#34;org.slf4j.simpleLogger.defaultLogLevel\u0026#34;, \u0026#34;INFO\u0026#34;); // Your code comes here } "},{"uri":"https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/","title":"PiJukeBox","tags":[],"description":"","content":"Daniel Mårtensson used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators.\nFeatures: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi\u0026rsquo;s, terminal based.\nWith a Raspberry Pi B+, OpenJDK 8 and Pi4J inside this radio, it became a juke box. The sources are available on github.com/DanielMartensson/PiJukeBox\n"},{"uri":"https://pi4j.com/about/team/","title":"The Team","tags":[],"description":"","content":"          Robert Savage, Project Founder, Architect, Lead Developer. Principal Software Architect/Engineer. Consultant, technology enthusiast, entrepreneur, open source contributor, technology blogger. Founder at shadeBlue, LLC and SavageSoftware, LLC. Robert has a more than 20 year career working in the professional audio visual and home/commercial automation industry and an extensive background in developing technology solutions with a special focus on home automation and hardware/firmware/software integration. In 2012, Robert created the Pi4J project which provides Java developers an easy to use Java library enabling access to low-level I/O functionality (GPIO, I2C, SPI, Serial, etc.) of embedded systems like the Raspberry Pi. I created Pi4J to empower Java programmers to get involved with embedded platforms such as the Raspberry Pi and provide an easy to use and accessible Java-centric object-oriented library enabling control of real world (physical) \u0026ldquo;things\u0026rdquo;. Pi4J V.2 brings an entirely new and modern approach to Java I/O programming for embedded systems. I\u0026rsquo;m excited to get V.2 released and see what additional creative projects emerge.    Frank Delporte, Project organization, Developer. Java and Raspberry Pi-enthousiast, blogger on webtechie.be and author of the book \u0026ldquo;Getting Started with Java on Raspberry Pi\u0026rdquo;. Software developer at Toadi (Belgium). Lead coach CoderDojo in Ieper, Belgium. Software developer with more than 25 years of experience in video, multimedia, technical project management, digital signage and (web) programming. I\u0026rsquo;m a strong believer in the power and fun of Java on the Raspberry Pi. My goal is to make it as easy as possible to get started for new and experienced Java developers who want to start there first hardware experiment. That was the reason I wrote a book about this subject and share my experiments on my blog and GitHub. Pi4J V.2 brings a lot of improvements to an already great project, and - just one example - the use of the BCM pin numbers will make it even a lot easier to use the GPIO\u0026rsquo;s. That\u0026rsquo;s why I join this great team to assist in delivering this V.2 and extend it further so we can bring even more Java to the Raspberry Pi.    Robert von Burg aka \u0026ldquo;Eitch\u0026rdquo;, Developer. As lead developer for strolch.li we use Raspberry Pi as our platform to connect with products, and to implement a PLC in Java. The Pi4J project allows us to encapsulate the low level aspects of communicating with the hardware, and stay in our preferred choice. The strolch.li/plc.html project allows us to also stay in the same DSL for writing server applications, as well as communicating with low level devices. Since I love open source projects, it felt natural to me to start investing time in the Pi4J projects to assist in the further development.    "},{"uri":"https://pi4j.com/getting-started/crowpi/crowpi-os/","title":"CrowPi OS","tags":["CrowPi"],"description":"","content":"You can start experimenting with the default Raspberry Pi OS, but to make things easier a prepackaged OS is available with additional tools. Follow these steps to get started quickly with this CrowPi OS.\nInstall the Raspberry Pi Imager The official Imager Tool can be downloaded directly from the Raspberry Pi website. This simple tool works on all common operating systems and can be installed very easily with just a few keystrokes. More detailed instructions for installation are also available on the homepage of the Raspberry Pi website or here on \u0026ldquo;Set up a new Raspberry Pi\u0026rdquo;.\nDownload the CrowPi Image The image for the CrowPi OS which contains the operating system for the Raspberry PI can be obtained directly from the Github repository of the CrowPi example project. The latest release of the operating system can be found under this link: Download CrowPi Image.\n   GitHub Download CrowPi OS Image\n    The image can then be downloaded from GitHub here: GitHub Download CrowPi Image\nAfter the download, unzip the .zip archive. Everything is now ready for the next step!\nWriting the image to an SD card When the image is written to the SD card, all data that is still on it will be overwritten!\n First, the SD card must be available as a drive on the computer. There are different possibilities for this. Card readers are just as suitable as USB adapters. The Raspberry Pi Imager tool is now started. First, the operating system must be selected. Press the button \u0026ldquo;Choose OS\u0026rdquo;.\n   Choose OS in Imager Tool\n    At the bottom of the list, select \u0026ldquo;Use custom\u0026rdquo;. In the selection dialog, select the previously downloaded and unzipped crowpi.img.\n   Use custom in Imager Tool\n    The second step is to select the SD card. To do this, press the button \u0026ldquo;Choose storage\u0026rdquo;. It automatically shows you only the available removable media such as USB sticks or SD cards. It is now very important to select the correct entry in order to avoid unwanted data loss. On Windows, the drive letter that is actually affected is shown under the data carrier, so that this can be easily checked in Explorer. In case of doubt, however, simply unplug the data carrier with important media beforehand so that nothing can happen.\n    TODO picture select SD card\nEverything is ready to write the image to the SD card. The process can be started by pressing the \u0026ldquo;Write\u0026rdquo; button. Another confirmation dialog follows before the SD card is finally overwritten. Writing the image to the SD card can take a few minutes which is completely normal. As soon as the process is completed, a message appears. The SD card can now be removed from the computer.\nInsert the SD card into the Raspberry Pi To insert the prepared SD card into the CrowPi, the 4 retaining screws may have to be loosened. These can be found here:\n    Raspberry Pi in the CrowPi with marked screws\n    After loosening the screws, the Raspberry Pi can be lifted. At most, a few cables must be unplugged. The SD card slot can now be found on the underside. Here the SD card with the contact surfaces can be inserted in the Raspberry Pi. The slot is marked again in the picture below. As soon as the SD card is inserted, the Raspberry Pi can be correctly installed in the CrowPi and any cables that may have been disconnected can be plugged in again. As soon as everything is back in its place, the CrowPi can be connected to the power.\n   Raspberry Pi SD card slot\n    Before the CrowPi is put into operation, it should be checked again whether all 3 cables are connected to the Raspberry Pi. The HDMI adapter on the left, the USB cable on the lower side and the GPIO ribbon cable on the right should be connected. These mandatory cables are framed with red circles in the next graphic. Optionally, a keyboard and mouse can be connected via USB, which is marked with a pink circle below:\n   Raspberry Pi cables\n    Establish the network connection Only the network connection of the freshly started Raspberry Pi still has to be made manually. Otherwise, all settings are already optimally contained in the FHNW CrowPi image. Now there are a few options for the network connection:\n Connection via WLAN Connection via Ethernet cable (DHCP) Connection via Ethernet cable directly to the computer  The easiest way to make the settings is to use the mouse and keyboard connected to the Raspberry Pi. Setting up via WLAN is explicitly recommended, as it can be used in almost any environment and works great with the hotspot function on your own smartphone even when you are out and about.\nIn the following, only the connection via WLAN is described, however, if there is expertise in this area, a connection via cable can also be established.\nEstablishing a WLAN connection To connect via wireless network, the two arrows on the desktop of the CrowPi must be pressed on the top right, after which you can select the desired network. Then enter the corresponding password in the dialog for secure connections. A few seconds after the connection, the CrowPi\u0026rsquo;s background image will automatically update and display the assigned IP address. An Ethernet address is also visible on the images. This means that at the moment of the recording there was also an Ethernet cable connected to the Raspberry Pi. Now that we have a network connection to the CrowPi, we are ready to set up the development environment as the next step.\n    CrowPi OS select WLAN\n      CrowPi OS WLAN password\n      CrowPi OS background with IP addresses\n                               "},{"uri":"https://pi4j.com/getting-started/crowpi/develop-with-intellij/","title":"Develop with Intellij IDEA","tags":["CrowPi"],"description":"","content":"In this tutorial, IntelliJ IDEA is used for the development. The articles, instructions and pictures are created accordingly. IntelliJ IDEA is from available Jetbrains in different versions. The community version has enough functionality for development with the CrowPi and is available for Windows, MacOS and Linux, but NOT for Raspberry Pi. The download can be found here.\nThe subsequent setup of IntelliJ IDEA is identical on all platforms.\nClone the repository As soon as we have installed the development environment, it is time to clone the entry-level project for the CrowPi. The source code can be found on GitHub. In order to clone the repository, the corresponding link must be copied on GitHub and then imported into IntelliJ IDEA. Now step-by-step in pictures a more detailed instruction.\nVisit CrowPi on GitHub and copy the link to clone as described in the picture.\n    CrowPi source link\n                               Import the project In the start window of IntelliJ is the option Get from VCS available. This must be selected so that the code can be cloned directly from GitHub. Then you can simply paste the link that was previously copied from GitHub. By confirming with Clone the process is started and any necessary authentication of the user is carried out. Simply follow the instructions of the tool.\n   Import from VCS\n      Insert import from VCS link\n    As soon as the project has been completely cloned on the local computer, the project opens automatically in the development environment. A small dialog pops up at the bottom right. This must be confirmed so that the repository can be properly initialized. Maven is a software project management tool, more information can be found in the Apache Maven Project. Basically, however, nothing needs to be changed. The CrowPi project already offers a complete setup and is easy to use.\n   Import Maven Project\n    Importing the Maven project triggers a security warning at IntelliJ. Click on \u0026ldquo;Trust project\u0026rdquo; to confirmed when you downloaded the soruces from the official Pi4J CrowPi repository.\n   Trust Project confirmation\n    Now a last import step. To be able to better research errors or understand how the code of the dependencies works, the \u0026ldquo;Maven Sources and Documentation\u0026rdquo; must be downloaded. This can be done with a few clicks. Open the Maven project menu on the far right. Click on \u0026ldquo;Download Sources and/or Documentation\u0026rdquo;. Then in the context menu \u0026ldquo;Download Sources and Documentation\u0026rdquo;. Now all used libraries are locally available and visible.\n   Download Dependencies and Sources\n    Now only the start configuration of the project is missing, which is described in the next section.\nSetting the run configuration The CrowPi project uses 3 run configurations. These define which parts of the code are executed and how. However, there is no need to worry, because most of it is already predefined and all you have to do is enter the IP address of your Raspberry Pi to push and run the code from your PC to the Pi. The following configurations are used:\n crowpi-examples [install] crowpi-examples [debug] Remote Debug  With \u0026ldquo;crowpi-examples [install]\u0026rdquo; the current code is copied to the Raspberry Pi. This works via a combination of SSH/SCP. The copied code is then started on the Raspberry Pi. \u0026ldquo;crowpi-examples [debug]\u0026rdquo; does the same, but other options are selected during the connection, and a debugger is waiting until the application is actually executed. \u0026ldquo;Remote Debug\u0026rdquo; provides exactly this debugger. This connects to the Raspberry Pi and troubleshooting can begin.\nTo make everything work smoothly, the IP address of the Raspberry Pi must first be configured. To do this, click here and select \u0026ldquo;Edit Configurations\u0026rdquo;. As explained before, the IP address of the Raspberry Pi is displayed on the background image of CrowPi.\n   Select configuration menu\n    The dialog for setting the configurations now opens. A little hint: wherever the IP address of the Raspberry Pi is required, there is already a placeholder \u0026ldquo;Add CrowPi IP here\u0026rdquo;.\nDepending on the configuration of your Raspberry Pi, you may need to define one of this available properties:\n crowpi.remote.port, default 22 crowpi.remote.username, default pi crowpi.remote.password, default pi crowpi.remote.target, default ??? crowpi.launcher.class, default ??? crowpi.launcher.args, default ???  crowpi.remote.host specifies the IP/hostname of the CrowPi, defaults to empty crowpi.remote.port defaults to 22 and specifies the SSH server port crowpi.remote.username defaults to pi crowpi.remote.password defaults to crowpi (this deviates from the Raspberry Pi OS default which is raspberry) crowpi.remote.target is the destination folder on the CrowPi where the compiled JAR files are copied to before execution and defaults to /home/pi/deploy (auto-created if missing) crowpi.launcher.class is the class path which should get launched by the JVM, defaults to com.pi4j.crowpi/com.pi4j.crowpi.Launcher and should not be changed (warranty void if you do so :wink:) crowpi.launcher.args are the arguments passed to the application launched by the JVM, specified as a string, passed through as-is without quoting, so e.g. BuzzerApp to launch that directly. Defaults to empty / no args.\nThe first five are only needed for remote deployments. Leaving crowpi.remote.host empty triggers local deployment.\nThere is also crowpi.remote.jvmOptions if you want to add any custom JVM options, defaults to empty or options for remote debug if Maven profile debug is used (edited)\n   The three configurations\n    First we configure \u0026ldquo;crowpi-examples [debug]\u0026rdquo;. For this, as in the picture, go to the tab \u0026ldquo;Runner\u0026rdquo; open and double click on \u0026ldquo;Add CrowPi IP here\u0026rdquo;. The dialog window to provide the IP address opens. Confirm with \u0026ldquo;OK\u0026rdquo; and press \u0026ldquo;Apply\u0026rdquo; to save.\n   Settings debug\n    Now we can configure \u0026ldquo;crowpi-examples [install]\u0026rdquo;. This works exactly the same as \u0026ldquo;crowpi-examples [debug]\u0026rdquo;. The same setting is required. Again use \u0026ldquo;Apply\u0026rdquo; to save.\n   Settings Install\n    Now the last configuration for \u0026ldquo;Remote Debug\u0026rdquo;. The menu is a bit different here. However, it is easier to use than the previous ones. Add the IP Address in the \u0026ldquo;Host\u0026rdquo; field. With \u0026ldquo;OK\u0026rdquo; the setting is finished.\n   Remote Debug Settings\n    First test run Everything is set up to start the CrowPi project for the first time directly from the development environment. Select the run configuration \u0026ldquo;crowpi-examples [install]\u0026rdquo;. Then start the application by pressing the green play button.\n   Start the application\n    It immediately opens the \u0026ldquo;Run\u0026rdquo; window in IntelliJ IDEA. It takes a moment, and some text is displayed on the command line. After a few seconds the output stops, and it looks like this:\n   Run Output in IntelliJ\n    A number can now be typed in here according to the displayed list (+ Enter). The corresponding sample application is then executed. If there are still error messages in the command line, it is worth checking the network connection of the computer and the Raspberry Pi again.\n"},{"uri":"https://pi4j.com/featured-projects/cocktail-maker-by-alex9849/","title":"Cocktail Maker","tags":[],"description":"","content":"The CocktailMaker is a cocktail mixing machine by Alexander Liggesmeyer. It can control as many pumps as the RaspberryPi provides GPIO pins. For every pump that gets added to the system, the user has to provide the amount of time that that pump needs to pump one centiliter in milliseconds. The machine uses peristaltic pumps. So that number is perfectly accurate. The flow rate won\u0026rsquo;t vary over time. It uses a relay board for closing the electronic circuit for all pumps. This allows to power the pumps with more than 5V. The relay board is connected to the Pi which controls the board with Pi4J V1. The backend-application is written in Java (Spring boot). The frontend is written with VueJS.\n                                                                     A video is available on Reddit\nApplication features  Pumping ingredients in sequential order. Pumping ingredients concurrently and mixing them by spreading the active pump timings within the productionstep. Ingredients that cannot be added automatically (maybe because they didn\u0026rsquo;t get assigned to one pump or are simply not liquid) can be handled. If a recipe with a non-pumpable ingredient got ordered the application will prompt the user to add that ingredient at the corresponding point. Recipes can be resized for every order. The user decides the size of the cocktail he wants to order. All ingredients amount will get recalculated automatically. A drag \u0026amp; drop recipe editor. Recipes can be categorized. Collections: Users can create collections and add recipes to them. Bar: Users can add owned ingredients to their bar. The application can search for recipes that he can order with the owned recipes. If the user tries to order a recipe where he doesn\u0026rsquo;t own all ingredients he will get a warning. The cocktail maker can search for recipes that can be produced fully automatic. (Won\u0026rsquo;t require the user to add ingredients manually) Recipes can be searched by ingredients. Multiple users \u0026amp; permission system: The admin can create new users and assign them to predefined groups, that have different permissions. Track the remaining amount of liquid of the connected bottles and prevent an order if the remaining liquid doesn\u0026rsquo;t reach. It is also able to switch between pumps on the fly. If one order empties one bottle, but another bottle with the same ingredient is connected, the application will empty the first container and will switch to the second one mid-production.  Docker deployment The whole application can be deployed as a docker container that has to be started in privileged mode. This allows even beginners that don\u0026rsquo;t have much experience to build their own machine.\nSources The full sources are available on GitHub\n"},{"uri":"https://pi4j.com/documentation/create-context/","title":"Creating a Pi4J Context","tags":[],"description":"","content":"The context is an immutable runtime object that holds the configured state and manages the lifecycle of a Pi4J instance. It includes all loaded plugins, providers, platforms, I/O instance registry, environmental configuration and runtime objects including executor thread pools, I/O event listeners, etc.\nTerminating/destroying the context stops and releases all resources, threads, listeners, and provisioned I/O instances held by the context.\nVersion 1 was implemented using a static singleton, while version 2 uses a \u0026ldquo;Context\u0026rdquo; to avoid static singletons.\nCreating a Context A Pi4J Context can be created automatically (accepting all default context configurations) or manually (builder) allowing users to customize the context configuration.\nAutomatic An auto context includes AUTO-DETECT BINDINGS enabled which will load all detected Pi4J extension libraries (Platforms and Providers) in the class path.\nvar pi4j = Pi4J.newAutoContext(); Builder If you need more flexibility are specific use-cases, the builder can be used to define all the parameters of the context, for example when you want to use your own providers, use mocked instances for testing\u0026hellip;:\nContext pi4j = Pi4J.newContextBuilder() .add(new MockPlatform()) .add(MockAnalogInputProvider.newInstance(), MockAnalogOutputProvider.newInstance(), MockSpiProvider.newInstance(), MockPwmProvider.newInstance(), MockSerialProvider.newInstance(), MockI2CProvider.newInstance(), MockDigitalInputProvider.newInstance(), MockDigitalOutputProvider.newInstance()) .add(new MyCustomADCProvider(/* implements AnalogInputProvider, id=\u0026#34;my-adc-prov\u0026#34; */)) .add(new MyCustomSPIProvider(/* implements SpiProvider, id=\u0026#34;my-spi-prov\u0026#34; */)) .build(); More information Use a single Context instance A single Context instance must be created in your application and shared between the classes. A Context object contains all the runtime and management state of the I/O. If you would use multiple Context objects and attempt to reuse certain I/O hardware or I/O providers it\u0026rsquo;s possible that they could conflict or get out of sync.\nGet GPIO handlers from the Context The Context maintains a reference to each I/O instance created, until pi4j.shutdown() is called.\nSomewhere you will need to create() your I/O instance giving it a unique ID (String). If you try to call create() a second time with the same ID, you will get an IOAlreadyExistsException.\npi4j.digitalOutput().create(1, \u0026#34;my-gpio\u0026#34;); Elsewhere in your application, you can get access to existing I/O instances using the Context\u0026rsquo;s io() or getIO() methods.\nif (pi4j.hasIO(\u0026#34;my-gpio\u0026#34;)) { DigitalOutput myOutput = pi4j.io(\u0026#34;my-gpio\u0026#34;); } Additional methods to access the registered I/O instances can be obtained through the Registry class.\npi4j.registry().* "},{"uri":"https://pi4j.com/featured-projects/street-artist-robot/","title":"Didier the street artist robot","tags":[],"description":"","content":"Meet \u0026ldquo;Didier\u0026rdquo; the street artist robot, a project by Duvam. The sources are shared on github.com/duvamduvam/didier-java.\n                                         "},{"uri":"https://pi4j.com/getting-started/user-interface-with-javafx/","title":"User interface with JavaFX","tags":["Digital Input","Digital Output","JavaFX","Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-javafx\n JavaFX is a framework to create user interfaces for desktop (Windows, Mac, Linux) and mobile phones. JavaFX is an opensource project which is documented on openjfx.io and the sources are available in this GitHub project.\nThe main goal of Java has always been to be able to create applications which are \u0026ldquo;write once, run everywhere\u0026rdquo;. JavaFX promises the same for Graphical User Interface applications.\nGluon is the main maintainer of the OpenJFX project and offers commercial support to companies who want to use JavaFX in critical applications. They also provide tools to build and compile Java code to native applications for all platforms.\nDeveloping a JavaFX application The best part of Java is the \u0026ldquo;Write Once, Run Everywhere\u0026rdquo;. This means you can develop your application on any PC (Windows, Mac, Linux) and run it on any other one of these (yes even on mobile) with the exact same look-and-feel and behavior. The only limitation is the part you develop specifically for the Raspberry Pi: controlling the GPIOs with Pi4J.\nThe most used IDE for Java development is IntelliJ IDEA, which is not available for Raspberry Pi. If you are using it on your PC and want to learn more about the best approach to get started with JavaFX, read this great tutorial \u0026ldquo;Beginning JavaFX Applications with IntelliJ IDEA\u0026rdquo; by Carl Dea.\nJavaFX on Raspberry Pi JavaFX is also an ideal framework to build Java applications with a user interface for the Raspberry Pi!\nYou can find a runtime version dedicated to the Raspberry Pi on the Gluon download page. Let\u0026rsquo;s install it on our board, so we can start Java+JavaFX applications which make best use of the capabilities of the Raspberry Pi.\nInstallation To get the latest version on your Raspberry Pi, first check the Gluon download page for the download link.\nCopy the link and use it with wget to download the file:\n Download the file  $ wget -O openjfx.zip https://gluonhq.com/download/javafx-17-ea-sdk-linux-arm32/ Unzip the file  $ unzip openjfx.zip Move the unzipped directory to the opt-directory (optionally, but it\u0026rsquo;s a logical place)  $ sudo mv javafx-sdk-17/ /opt/javafx-sdk-17/ Start an application Now the OpenJFX-runtime is available on our Raspberry Pi, we can start each Java application which was compiled to a JAR with some additional parameters to run it with the best rendering support.\nThe additional arguments are needed to link to the downloaded JavaFX library and select the correct Monocle platform.\njava \\  -Dglass.platform=gtk \\  -Djava.library.path=/opt/javafx-sdk-17/lib \\  -Dmonocle.platform.traceConfig=false \\  -Dprism.verbose=false \\  -Djavafx.verbose=false \\  --module-path .:/opt/javafx-sdk-17/lib \\  --add-modules javafx.controls \\  --module {YOUR_MAIN_CLASS} $@ TODO: describe each of the startup arguments, here or in a sub page.\nMinimal example application Sources In this repository https://github.com/Pi4J/pi4j-example-javafx, a minimal example project is provided which combines Java, JavaFX, Pi4J and a few buttons. The wiring for this example is identical to the Minimal example application with a single LED and button.\n    JavaFX UI after start-up\n      JavaFX UI after click on physical button\n      LED turned on by clicking on the JavaFX button\n                               Steps to test the application  Download the sources to your Raspberry Pi  $ git clone https://github.com/pi4j/pi4j-example-javafx Move to the downloaded directory  $ cd pi4j-example-javafx Build the project  $ mvn package Move to the target \u0026gt; distribution directory  $ cd target/distribution Run the application with the provided run-script  $ sudo ./run.sh "},{"uri":"https://pi4j.com/featured-projects/joystick-game/","title":"JMonkeyEngine with Joystick","tags":[],"description":"","content":"Pavl G. created a Java Gradle library to control a car in a JMonkeyEngine game with an arduino joystick module connected to a Raspberry Pi4 model B, using GPIO digital pins and SPI interfacing through MCP3008 ADC (Analog~Digital Converter).\nRequirements  Raspberry Pi with arm processor (pi3, pi4, piZero) with a working java8 (preferred). Female-to-male jumper wires. Breadboard. Arduino Joystick module. MCP3008 IC (ADC \u0026ndash; other adcs may work too, but we are covering only MCP3008 here). Some patience and time.  Difference between Analog and Digital signals?  An analog signal is a continuously variable voltage between 0 and Vmax over time, examples : Temparature sensor output, Potentiometers (joysticks)\u0026hellip;. A digital signal is rather a discrete step-by-step output voltage of LOW (fall) to HIGH (rise) according to the switch position among a network of resistors. To convert from analog signals to digial signals, we need to encode the output voltage changing over time to some sequence of bits. We cannot interface analog electronics on digital devices such as (arduinos and raspberry pi w/o converting into digial signals).  What\u0026rsquo;s ADC? Let\u0026rsquo;s have an example of a 3-bit Analogue to Digital Converter :\nThis how ADC works under the hood, steps of converting Analog to Digital  Analog voltage goes through Vin, Then it\u0026rsquo;s passed to a network of voltage comparators that compares its voltage to the selected reference range (Vref, which is selected at the time of wiring). If Vin \u0026gt; Vref the comparator output would be HIGH aka (1), if Vin \u0026lt; Vref the comparator output would be LOW aka (0). The significant of having a network of comparators is to encode the value of the analog signal into a digital sequence of bits. The output of comparators Dn gets passed into a 3-bit priority encoder. The priority encoder by definition, it encodes based on the high priority input and ignores the low priority input. So, if Vin = 3.5 to 4.0 V then the Comparators output = 11111111, At last when inputting the comparator output into the priority encoder the encoder gives a value of 7 which points to D7 of comparator U7 aka the last voltage level, and that\u0026rsquo;s true because our Vin is bigger than the Vref.  What\u0026rsquo;s SPI?  Serial Peripheral Interface (SPI) is an interface bus commonly used to send data between microcontrollers and small peripherals such as shift registers, sensors, and SD cards. It uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Our target is to transfer the output from our priority encoder to the BCM processor of our Pi throughout the SPI protocol (Synchronously over Tx from MCP3008 to Rx of the Pi). To send and receive synchronous data we use MISO (the same as CIPO) for receving data from peripherals and MOSI (the same as COPI) to send data to the peripherals. MISO : Master-in-Slave-Out = CIPO : Controller-in-peripheral-out. MOSI : Master-out-Slave-In = COPI : Controller-out-Peripheral-in. MCP3008 is used to receive analog input, so MISO or CIPO is our common active data line. CS is the chip select, it\u0026rsquo;s used to select which peripheral device to use. SCLK is the serial clock and it\u0026rsquo;s used to synchronize data on a data line, to have a clear separate message per 8 clocks (8-bit message).  Wiring Up  Vcc : is used for powering up the IC and not to compare with VREF. Vref : is used for controlling the maximum resolution of the input voltage (analog signal), if VREF = 5v5 (maximum voltage received by MCP3008), then the resolution of Vin is a 100%.  Testing the wiring Before going deeper and testing with jme vehicle, please test this code and do your conclusions :\n// Define MCP3008 provider on CS0 -- Peripheral device 0 final MCP3008GpioProvider mcp3008GpioProvider = new MCP3008GpioProvider(SpiChannel.CS0); // define analog input pins on the adc final GpioPinAnalogInput[] gpioPinAnalogInput= new GpioPinAnalogInput[2]; gpioPinAnalogInput[0] = MCP3008Pin.CH0; gpioPinAnalogInput[1] = MCP3008Pin.CH1; // define the threshold analog (the minimum voltage at which the Pi can listen to). mcp3008GpioProvider.setEventThreshold(thresholdAnalogValue, gpioPinAnalogInput); // enable monitoring of analog values with an interval of 250 ms mcp3008GpioProvider.setMonitorEnabled(true); mcp3008GpioProvider.setMonitorInterval(250); // start collecting data from the SPi connected to MCP3008 output. final GpioController gpioController = GpioFactory.getInstance(); gpioController.addListener((GpioPinListenerAnalog) event -\u0026gt; { System.out.println(\u0026#34;Value at CH0 : \u0026#34; + mcp3008GpioProvider.getValue(gpioPinAnalogInput[0])); System.out.println(\u0026#34;Value at CH1 : \u0026#34; + mcp3008GpioProvider.getValue(gpioPinAnalogInput[1])); }, gpioPinAnalogInput); Testing with a jmonkeyengine vehicle It\u0026rsquo;s very hard to give you a full overview of how to create a jmonkeyengine vehicle in this tutorial, so you could fairly refer to jme docs and examples for more :\n Use the physics in your game and control your game via keyboard : https://wiki.jmonkeyengine.org/docs/3.4/tutorials/beginner/hello_physics.html A Keyboard controlled car demo : https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestPhysicsCar.java The idea is simple, any game can be controlled using a keyboard interface (bound to jme update), so you can simply replace that with a custom InputHandler using a custom hardware. The trick is to bind your joystick pi4j interface to jme thread (OpenGL\u0026rsquo;s thread).  Video of operation   More at sources  ADC overview : https://www.electronics-tutorials.ws/combination/analogue-to-digital-converter.html MCP3008 ADC : https://www.microchip.com/en-us/product/MCP3008 SPI overview : https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all Gradle lib : https://github.com/Scrappers-glitch/JoyStickModule Testcase : https://github.com/Scrappers-glitch/JmeCarPhysicsTestRPI  "},{"uri":"https://pi4j.com/documentation/platforms/","title":"Choosing a Platform","tags":[],"description":"","content":"Platforms are extensible service modules responsible for defining a set of default I/O providers and specific hardware capabilities for an embedded hardware system where Pi4J is deployed/running.\nTechnically speaking \u0026hellip; multiple platforms could be loaded into the runtime context, but only one will be considered the default platform for most I/O provisioning and operations. An example of this could be both a RaspberryPi Platform and Mock Platform are detected as plugins and loaded into the context, but only one will be determined at runtime to be the default platform used by the context.\nSome priority scheme will need to be implemented and invoked at runtime to resolve which is the best \u0026ldquo;platform\u0026rdquo; to accept as the default platform at runtime (on start up).\n The idea here is that a user could have multiple platform plugins in their directory but only one, theoretically the best suited, will be determined and used at runtime based on the runtime environment which makes it possible to develop, run and test on e.g. Windows with the MockPlatform and when finished run on the Raspberry Pi with the same generated jar\u0026rsquo;s which use the RaspberryPiPlatform.\nCurrent supported platforms:\n Raspberry Pi  "},{"uri":"https://pi4j.com/getting-started/fxgl/","title":"Game development with FXGL","tags":["JavaFX"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl\n As described on the previous page you can use JavaFX to build user interfaces which behave exactly the same on your PC and Raspberry Pi. Let\u0026rsquo;s go a step further and make a game with an \u0026ldquo;Arcade\u0026rdquo; controller.\nFor this project, we will be using FXGL, an opensource library on top of JavaFX to build games.\nThe image of the crowpi project has every prerequisite installed to work with javaFX/FXGL\nThe controller This project uses an Arcade kit in combination with a Picade X HAT USB-C to easily connect the wires of the buttons and joystick.\nConnect the USB power to the hat instead of your Raspberry Pi, and use the power button on the hat to start your Raspberry Pi.\n    Arcade kit components\n      Picade Hat\n      Assembled Picade Hat and Arcade kit\n      Connected wires on Picade Hat\n      Picade Hat pin numbers\n                               Pimoroni provides a GitHub project with software to use this hat with RetroPie, but this project aims to take full control of the hardware with Java.\nThe GPIO numbers are defined by the hat and can be found on pinout.xyz\nSteps to run snake on your Raspberry Pi  Download the project from GitHub and build it:  $ git clone https://github.com/Pi4J/pi4j-example-fxgl.git $ cd pi4j-example-fxgl/ $ mvn clean package  Change to the distribution directory where you can find the generated package and required Java-modules. Start it with the provided run.sh script:  $ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 364456 Jun 19 10:04 pi4j-core-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 7243 Jun 19 10:04 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 142461 Jun 19 10:04 pi4j-library-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 37302 Jun 19 10:04 pi4j-plugin-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 26917 Jun 19 10:04 pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run.sh -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run-kiosk.sh -rw-r--r-- 1 pi pi 52173 Jun 19 10:04 slf4j-api-2.0.0-alpha0.jar -rw-r--r-- 1 pi pi 15372 Jun 19 10:04 slf4j-simple-2.0.0-alpha0.jar $ sudo ./run.sh  There are two run scripts: run.sh: runs the application in standard windowed mode run-kiosk.sh: runs the application in DRM mode, see kiosk mode\n Picade To control our game we use the hardware mentioned above. Tho following mapper uses a similar binding method as in the minimal example\nPimapper To make use of the picade controls for existing FXGL project we provide an interface to simply extend your application.\nIntegrate piMapping The code for the piMapper is found in the example snake game.\nUpdate Game Change your Game from “extend GameApplication” to “extend PicadeGameApplication” PicadeGameApplication overrides the GameApplication class of FXGL and provides additional functions to map the picade controllers\npublic class FxglExample extends PicadeGameApplication Update Key Inputs Now we can use the new piMapper to address keys as well as picade controls. To do this, we need to tell the onKeyDown function, what control we want. Inputs are defined as in previous tutorials in the picadeControl enum\nonKeyDown(PicadeControl.PIN_BUTTON_1, KeyCode.F, () -\u0026gt; player.getComponent(SnakeHeadComponent.class).grow()); onKeyDown(KeyCode.G, () -\u0026gt; player.getComponent(SnakeHeadComponent.class).log()); GPIO  The Enum PicadeControl handles the the gpio numbers for the connected controls. pinout.xyz  PIN_JOYSTICK_UP(12), PIN_JOYSTICK_DOWN(6), PIN_JOYSTICK_LEFT(20), PIN_JOYSTICK_RIGHT(16), PIN_BUTTON_1(5); Run Scripts run.sh Runs the application in windowed mode\n#!/usr/bin/env bash java \\  -Dglass.platform=gtk \\  -Djava.library.path=/opt/javafx-sdk-17/lib \\  -Dmonocle.platform.traceConfig=false \\  -Dprism.verbose=false \\  -Djavafx.verbose=false \\  --module-path .:/opt/javafx-sdk-17/lib \\  --add-modules javafx.controls \\  --module com.pi4j.example/com.pi4j.example.FxglExample $@ run-kiosk.sh Runs the application with monocle in DRM (Direct rendering mode). More to kiosk mode here\n"},{"uri":"https://pi4j.com/getting-started/fxgl/fxgl-to-picade/","title":"FXGl to Picade","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl\n In this section we demonstrate how to convert existing FXGL projects to work on a RaspberryPi\nIf you don\u0026rsquo;t have an existing FXGL project, go grab one from FXGLGames\nSteps to get your app running on a RaspberryPi  Add Maven support to your project In our project we use Maven to manage dependencies and build the application, other build tools such as gradle are also viable but not covered in this tutorial.  In the Project tool window, right-click your project and select Add Framework Support In the dialog that opens, select Maven from the options on the left and click OK Add run scripts Create a folder called assets in the root directory of your project.  Copy the run scripts into the folder\nChange the module names according to your projects module\nEdit pom.xml Extend the properties tag with dynamic maven compiler version based of the projects java version\n\u0026lt;!-- JAVA COMPILER VERSIONS --\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;${java.version}\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;${java.version}\u0026lt;/maven.compiler.target\u0026gt; Also in the properties tag, additionally to the base dependencies from Minimal example application add the dependency version for FXGL and the build plugins.\n\u0026lt;!-- DEPENDENCIES VERSIONS --\u0026gt; \u0026lt;slf4j.version\u0026gt;2.0.0-alpha0\u0026lt;/slf4j.version\u0026gt; \u0026lt;pi4j.version\u0026gt;2.0-SNAPSHOT\u0026lt;/pi4j.version\u0026gt; \u0026lt;fxgl.version\u0026gt;11.16\u0026lt;/fxgl.version\u0026gt; \u0026lt;!-- BUILD PLUGIN VERSIONS --\u0026gt; \u0026lt;exec-maven-plugin.version\u0026gt;1.6.0\u0026lt;/exec-maven-plugin.version\u0026gt; \u0026lt;maven-compiler-plugin.version\u0026gt;3.8.1\u0026lt;/maven-compiler-plugin.version\u0026gt;  In the FXGL version 11.16 sepcial javaFX libraries are included to run on raspberryPi\n Add following dependency for FXGL:\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- FXGL library which includes JavaFX --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.almasb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fxgl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${fxgl.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; The following code is used to build the application in order to run it on the raspberryPi. Insert the module path and the path to the main class at the with [INSERT MODULE PATH] marked location.  For example: com.pi4j.example/com.pi4j.example.FxglExample\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- JAVA COMPILER --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-compiler-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;release\u0026gt;${java.version}\u0026lt;/release\u0026gt; \u0026lt;showDeprecation\u0026gt;true\u0026lt;/showDeprecation\u0026gt; \u0026lt;showWarnings\u0026gt;true\u0026lt;/showWarnings\u0026gt; \u0026lt;verbose\u0026gt;false\u0026lt;/verbose\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- DEFAULT JAR EXECUTABLE CLASS --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;exec-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${exec-maven-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;java\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;executable\u0026gt;java\u0026lt;/executable\u0026gt; \u0026lt;arguments\u0026gt; \u0026lt;argument\u0026gt;--module-path\u0026lt;/argument\u0026gt; \u0026lt;argument\u0026gt;${project.build.directory}/distribution\u0026lt;/argument\u0026gt; \u0026lt;argument\u0026gt;--module\u0026lt;/argument\u0026gt; \u0026lt;argument\u0026gt;[INSERT MODULE PATH]\u0026lt;/argument\u0026gt; \u0026lt;/arguments\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- BUILD THE FINAL JAR FILE IN THE /target/distribution PATH --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/distribution\u0026lt;/outputDirectory\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- COPY ANY RUNTIME SCRIPTS TO THE /target/distribution PATH --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-antrun-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;target\u0026gt; \u0026lt;copy todir=\u0026#34;${project.build.directory}/distribution\u0026#34; overwrite=\u0026#34;true\u0026#34; flatten=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;fileset dir=\u0026#34;assets\u0026#34; includes=\u0026#34;*.sh\u0026#34;\u0026gt;\u0026lt;/fileset\u0026gt; \u0026lt;/copy\u0026gt; \u0026lt;chmod dir=\u0026#34;${project.build.directory}/distribution\u0026#34; perm=\u0026#34;ugo+rx\u0026#34; includes=\u0026#34;**/*.sh\u0026#34;/\u0026gt; \u0026lt;/target\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;run\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- DOWNLOAD RUNTIME DEPENDENCIES --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;process-sources\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-dependencies\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/distribution\u0026lt;/outputDirectory\u0026gt; \u0026lt;includeScope\u0026gt;runtime\u0026lt;/includeScope\u0026gt; \u0026lt;excludeTransitive\u0026gt;false\u0026lt;/excludeTransitive\u0026gt; \u0026lt;overWriteReleases\u0026gt;false\u0026lt;/overWriteReleases\u0026gt; \u0026lt;overWriteSnapshots\u0026gt;true\u0026lt;/overWriteSnapshots\u0026gt; \u0026lt;overWriteIfNewer\u0026gt;true\u0026lt;/overWriteIfNewer\u0026gt; \u0026lt;!-- On the Raspberry Pi we use specific JavaFX dependencies, so we exclude them here and they are added in the run-script. --\u0026gt; \u0026lt;excludeGroupIds\u0026gt;org.openjfx\u0026lt;/excludeGroupIds\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; Add module-info In our build we run modules. This module has to be defined in module-info.java.\nAdd all required dependencies for your project here.\nMore info for modular FXGL here\nopen module com.pi4j.example { // Pi4J MODULES requires com.pi4j; requires com.pi4j.plugin.pigpio; // SLF4J MODULES  requires org.slf4j; requires org.slf4j.simple; requires com.almasb.fxgl.all; uses com.pi4j.extension.Extension; uses com.pi4j.provider.Provider; // allow access to classes in the following namespaces for Pi4J annotation processing  exports com.pi4j.example to com.almasb.fxgl.core; } "},{"uri":"https://pi4j.com/getting-started/fxgl/kiosk-mode/","title":"JavaFX kiosk mode","tags":[],"description":"","content":" Visit webtechie.be for the full blogpost\n Kiosk Mode With Gluon\u0026rsquo;s JavaFX 17-ea, we are able to run applications in different modes: Desktop and Kiosk mode. In this post we focus on the Kiosk mode only.\nWith this approach, the application is the only thing you see on the screen. This prevents the user to open any other applications, or mess up your system. In this case, there is no need for a window manager, and the application directly uses the underlying (hardware) framebuffer. To achieve this, we use Monocle with EGL and DRM, as that is the Linux approach to directly address the hardware acceleration, without a window manager. The JavaFX application is using Direct Rendering Mode (DRM) to be visualized. An extra benefit is the performance boost, as your program is the only thing that needs to be handled towards the screen.\n By using /sbin/init 3 before the application starts, the desktop mode is stopped. As DRM in JavaFX 17-ea is part of the commercial license of Gluon, we need to set the environment value ENABLE_GLUON_COMMERCIAL_EXTENSIONS, for more info see Gluon docs: “JavaFX on Embedded” \u0026gt; “Legal notice”. The display id needs to be defined, if card0 is not working and you get the error [GluonDRM] Device /dev/dri/card0 could be opened, but has no drm capabilities., try card1. More info is provided on Gluon docs: “JavaFX on Embedded” \u0026gt; “Testing JavaFX”. After the application is stopped, we call /sbin/init 5 to restart the regular desktop environment.  #!/usr/bin/env bash /sbin/init 3 export ENABLE_GLUON_COMMERCIAL_EXTENSIONS=true java \\  -Degl.displayid=/dev/dri/card0 \\  -Dmonocle.egl.lib=/opt/javafx-sdk-17/lib/libgluon_drm-1.1.3.so \\  -Djava.library.path=/opt/javafx-sdk-17/lib \\  -Dmonocle.platform.traceConfig=false \\  -Dprism.verbose=false \\  -Djavafx.verbose=false \\  -Dmonocle.platform=EGL \\  --module-path .:/opt/javafx-sdk-17/lib \\  --add-modules javafx.controls \\  --module com.pi4j.example/com.pi4j.example.FxglExample $@ /sbin/init 5 To run the application in kiosk mode it is recommended to have an open ssh session on the side to follow the process or in case of errors, being able to restart the desktop with:\n/sbin/init 5 Performance By disabling the window manager, more ressources are available for the application, therefore running more performant. To test the performance of the windowed mode and kiosk mode, several tests have been executed.\nRaspberryPi model: RaspberryPi 4 8G Model B\nThe tests were run with 50, 100 and 500 balls. The results of the study show that even thought many more resources are available, the game does not run the expected amount smoother. A slight increase of RAM and CPU is noticeable, but the average frames per second do not improve that much. Non the less, the FPS was more stable while running in kiosk mode and might be an advantage when running games.\nOverall the kiosk mode has advantages over the windowed mode but using the kiosk mode exclusively to boost the performance is not recommended.\nExtra tips Gluon documentation Gluon keeps the documentation for Raspberry Pi constantly updated, keep an eye on gluonhq to stay up-to-date.\n64-bit OS and JavaFX If you want to go 64-bit, you can use the same approach. There is no official 64-bit Raspberry Pi OS yet, but you can find more information on “Faster \u0026amp; More Reliable 64-bit OS on Raspberry Pi 4 with USB Boot”.\nUnclutter Another great addition for a kiosk approach is Unclutter, a small tool which hides your mouse cursor when you do not need it. You only have to move the mouse for the cursor to reappear.\nsudo apt install unclutter To run the application in kiosk mode it is recommended to have an open ssh session on the side to follow the process or in case of errors, being able to restart the desktop with:\n/sbin/init 5 "},{"uri":"https://pi4j.com/documentation/providers/","title":"Choosing an I/O Provider","tags":[],"description":"","content":"Providers are extensible service modules responsible for the concrete implementation of a specific I/O type. Multiple providers for the same I/O type can be loaded into a Pi4J context concurrently. For example a \u0026ldquo;RaspberryPi-DigitalInputProvider\u0026rdquo; and \u0026ldquo;GertBoard-DigitalInputProvider\u0026rdquo; could both be loaded and both providing digital inputs at the same time.\nThe providers also allow to seperate the internal logic of the Pi4J core from the concrete implementation of the board on which they are used.\nCurrent supported providers:\n PiGpio LinuxFS  Possible future providers:\n LinuxFileSystemProvider: e.g. to use native Linux serial interfaces RemoteProvider to control the I/O from a remote device e.g. through websockets  "},{"uri":"https://pi4j.com/getting-started/javafx-mvc-template/","title":"JavaFX GUI and MVC template","tags":["Digital Input","Digital Output","JavaFX","Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-template-javafx\n The FHNW University created a template project which is now part of the Pi4J example repositories.\nThe goal of this project is to:\n Provide a clear step-by-step how to prepare your Raspberry Pi Provide multiple test and start applications Explain the use of a MVC-model (Model-View-Controller) to clearly split data, actions and user interface Explain the use of JUnit test  Sources and info Please check the README of the sources of the project for a full description of the setup process of the Raspberry Pi and to fully understand the example applications and the MVC-model. This page is only intended to give you a quick overview.\nExample applications HelloFX A simple application to test if the JavaFX libraries are installed correctly. Should not be used as a template for one\u0026rsquo;s own JavaFX applications.\nWiring The two other example applications use an LED and a button. These must be wired as is shown in the following diagram:\nMinimalPi4J The MinimalPi4j application is a Pi4j only application without a GUI. This application is also only used to test the setup and can be deleted after testing.\nPressing the button should generate a message in the console.\nOnce the Pi4J setup has been tested, MinimalPi4J can be deleted.\nTemplateApp This application shows the interaction between a JavaFX based Graphical User Interface (GUI) and the Raspberry Pi connected sensors and actuators, the Physical User Interface (PUI).\nThis application is to be used as a template for one\u0026rsquo;s own applications. This includes the existing test cases.\nYou should first get to know and understand the example. For your own applications you should then copy the the TemplateApp and modify it for your project, however without violating the rules of the MVC concept.\nTemplatePUIApp The MVC concept should also be used for applications without a GUI.\nWhen developing PUI only applications, or when adding the GUI later, then one should use the TemplatePUIApp as template.\nThe MVC concept The classic Model-View-Controller concept contains in addition to the starter class at least 3 more classes. The interaction is clearly defined:\nThis way the GUI and PUI are completely separated from each other, i.e a GUI button to turn an LED on has no direct access to the LED component of the PUI. Instead the GUI button triggers a corresponding action in the controller which then sets the on state property in the model. The PUI listening on this state then turns the actual LED on or off.\nGUI and PUI work with the same identical controller and thus also the same identical model.\nIn the MVC concept, every user interaction traverses the exact same cycle:\nConclusion You can use the same architecture (MVC) to implement a JavaFX-based GUI, a PUI attached to a Raspberry Pi, and integrate both in a clean, modular way.\n"},{"uri":"https://pi4j.com/documentation/build-io/","title":"Building an I/O Instance","tags":[],"description":"","content":"TODO\n"},{"uri":"https://pi4j.com/getting-started/learn-more/","title":"Learn more...","tags":[],"description":"","content":"Pi4J is used in a lot of projects, and you can find a lot of examples online. On this page we want to keep an up-to-date list. Do you want to add something? Please hit \u0026ldquo;Edit this page\u0026rdquo; on the top and create a pull request!\nTwitter Please share your personal or professional projects where you combine Java and the Raspberry Pi on Twitter with the hashtag #JavaOnRaspberryPi.\nOnline articles  Foojay.io is a place for friends of OpenJDK, providing articles, updated analyses, selected highlights, and categorized lists on all things Java. There is also a category of posts dedicated to Java on the Raspberry Pi..  Books Getting Started with Java on the Raspberry Pi This book by Frank Delporte includes a lot of info and history about Java itself and how to install it on the Raspberry Pi. Also, a lot of tips and tricks to become or be a better developer. And above all many simple examples on these and even more other topics:\n The magic of Bits and Bytes and solving the confusion of Java signed values with the help of a led number display. Beautiful user interfaces made with JavaFX so you can interact with the hardware. Pi4J applications to be able to control different types of hardware like LEDs, buttons, displays, led strips, relay boards, and many more. Spring applications to interact with your Pi via web interfaces. How to set up a queue to send and receive messages to and from Arduino boards or other Pi’s. Interviews with Karen Mouws (STEM and diversity), Trisha Gee (IntelliJ IDEA), Xiaokai He (Visual Studio Code), Alexander Belokrylov (BellSoft Liberica JDK), Jakob Jenkov (Java and tutorials.jenkov.com), Johan Vos (OpenJFX, JavaFX and GluonHQ), Gerrit Grunwald (Java, JavaFX, TilesFX), Mark Heckler (Spring), Vlad Mihalcea (JPA, Hibernate)  The ebook is available on Leanpub and the paper book on Elektor.\n"},{"uri":"https://pi4j.com/documentation/io-examples/","title":"I/O Examples","tags":[],"description":"","content":"Here you can find detailed examples for the different functionalities of Pi4J per I/O type.\n Digital Output (GPIO)   Digital Input (GPIO)   Pulse Width Modulation (PWM)   Inter-Integrated Circuit (I²C)   Serial Peripheral Interface (SPI)   Serial (UART/RS232)   The supported low-level I/O interface types are defined in the core library as an enumerated list.\nANALOG_INPUT(AnalogInputProvider.class, AnalogInput.class, AnalogInputConfig.class, AnalogInputConfigBuilder.class), ANALOG_OUTPUT(AnalogOutputProvider.class, AnalogOutput.class, AnalogOutputConfig.class, AnalogOutputConfigBuilder.class), DIGITAL_INPUT(DigitalInputProvider.class, DigitalInput.class, DigitalInputConfig.class, DigitalInputConfigBuilder.class), DIGITAL_OUTPUT(DigitalOutputProvider.class, DigitalOutput.class, DigitalOutputConfig.class, DigitalOutputConfigBuilder.class), PWM(PwmProvider.class, Pwm.class, PwmConfig.class, PwmConfigBuilder.class), I2C(I2CProvider.class, com.pi4j.io.i2c.I2C.class, I2CConfig.class, I2CConfigBuilder.class), SPI(SpiProvider.class, Spi.class, I2CConfig.class, I2CConfigBuilder.class), SERIAL(SerialProvider.class, Serial.class, SerialConfig.class, SerialConfigBuilder.class); "},{"uri":"https://pi4j.com/documentation/device-examples/","title":"Devices examples","tags":[],"description":"","content":"The core Pi4J V.2 library doesn\u0026rsquo;t contain any specific support for devices like buttons, motors, LCD\u0026hellip; This was part of V.1 but made it much more difficult to maintain and fully test the library.\nOn this page we want to keep a list of projects which contain implementation code for specific devices using the Pi4J V.2 core library. Please let us know through the forum if you want to have your project added to this list.\nCurrent available device support projects    Device(s) Developed by Link     MCP230008, MCP23017, TCA9548 Thomas Aarts github.com/Pi4J/pi4j-device-tca9548    "},{"uri":"https://pi4j.com/documentation/registry/","title":"I/O Registry","tags":[],"description":"","content":"An additional V.2 feature is an I/O registry where all I/O instances that have been created can be maintained, managed, re-accessed, etc. As the library keeps track of all the created I/O instances, they become publicly accessible through a registry where users can interrogate, iterate, identify and access all created I/O instances that Pi4J is managing.\nThis is very useful for add-ons/plugins that want to provide runtime information about the state of all I/O, for example a web app illustrating the current state of I/O.\nThe registry is responsible for managing I/O instance lifecycles and provides a means for your program to easily access any I/O instance using its unique identifier.\n"},{"uri":"https://pi4j.com/documentation/shutdown/","title":"Shutting down the Pi4J Context","tags":[],"description":"","content":"At the end of our application, the context needs to be shutdown to release the I/O and clean up the used resources.\n# Start of program var pi4j = Pi4J.newAutoContext(); # YOUR CODE GOES HERE # End of program pi4j.shutdown(); "},{"uri":"https://pi4j.com/documentation/building/","title":"Building and running","tags":[],"description":"","content":"When you create your application with and IDE on the Raspberry Pi itself (e.g. with Visual Studio Code), you can simply run the application. But ofcourse, you want to build and package your project to easily deploy it on one or more Raspberry Pi\u0026rsquo;s.\nThere are different possibilities:\n Building with javac   Build as a FAT JAR with Maven   Build Java modules with Maven   Build Java modules with Gradle   Running Pi4J with JBang   "},{"uri":"https://pi4j.com/documentation/building/javac/","title":"Building with javac","tags":["Javac"],"description":"","content":"You can build a Pi4J project using only java and javac.\nWiring No wiring is needed for this minimal example as it only demonstrates how to create a minimal application which initializes Pi4J.\nJava release Any Java release over 11 is enough, check it with this command:\n$ java -version java 17.0.1 2021-10-19 LTS Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39) Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing) PI4J jar files You will need to download the Pi4J distribution from the Maven repository:\npi4j-distribution-2.1.1.zip\nExpand the file:\nunzip pi4j-distribution-2.1.1.zip\nAdd the lib directory to CLASSPATH by added this line to your .bashrc file:\nexport CLASSPATH=$CLASSPATH:~/pi4j-2.1.1/lib/*\nMinimal Java example file Use your preferred editor to create this GettingStartedExample.java file:\nimport com.pi4j.Pi4J; import com.pi4j.io.gpio.digital.DigitalOutput; import com.pi4j.platform.Platform; import com.pi4j.platform.Platforms; import com.pi4j.provider.Providers; import com.pi4j.registry.Registry; import com.pi4j.util.Console; public class GettingStartedExample { public static void main(String[] args) throws Exception { final var console = new Console(); console.title(\u0026#34;\u0026lt;-- The Pi4J Project --\u0026gt;\u0026#34;, \u0026#34;Getting Started Example\u0026#34;); var pi4j = Pi4J.newAutoContext(); Platforms platforms = pi4j.platforms(); console.box(\u0026#34;Pi4J PLATFORMS\u0026#34;); platforms.describe().print(System.out); console.println(); Platform platform = pi4j.platform(); console.box(\u0026#34;Pi4J DEFAULT PLATFORM\u0026#34;); platform.describe().print(System.out); console.println(); Providers providers = pi4j.providers(); console.box(\u0026#34;Pi4J PROVIDERS\u0026#34;); providers.describe().print(System.out); console.println(); Registry registry = pi4j.registry(); DigitalOutput output = pi4j.dout().create(1, \u0026#34;my-digital-output-1\u0026#34;); console.box(\u0026#34;Pi4J REGISTRY\u0026#34;); registry.describe().print(System.out); console.println(); pi4j.shutdown(); } } Compile the example javac GettingStartedExample.java\nExecute the example java GettingStartedExample\nIf everything is OK the output must be something similar to this, depending on your configuration:\n[main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - \u0026lt;-- The Pi4J Project --\u0026gt; [main] INFO com.pi4j.util.Console - Getting Started Example [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PLATFORMS | [main] INFO com.pi4j.util.Console - -------------------- PLATFORMS: [1] \u0026#34;Pi4J Runtime Platforms\u0026#34; \u0026lt;com.pi4j.platform.impl.DefaultPlatforms\u0026gt; ??PLATFORM: \u0026#34;RaspberryPi Platform\u0026#34; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - | Pi4J DEFAULT PLATFORM | [main] INFO com.pi4j.util.Console - --------------------------- PLATFORM: \u0026#34;RaspberryPi Platform\u0026#34; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PROVIDERS | [main] INFO com.pi4j.util.Console - -------------------- PROVIDERS: [12] \u0026#34;I/O Providers\u0026#34; \u0026lt;com.pi4j.provider.impl.DefaultProviders\u0026gt; ??DIGITAL_INPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalInputProvider\u0026gt; ? ??PROVIDER: \u0026#34;RaspberryPi Digital Input (GPIO) Provider\u0026#34; {raspberrypi-digital-input} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl} ? ??PROVIDER: \u0026#34;PiGpio Digital Input (GPIO) Provider\u0026#34; {pigpio-digital-input} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl} ??SERIAL: [2] \u0026lt;com.pi4j.io.serial.SerialProvider\u0026gt; ? ??PROVIDER: \u0026#34;RaspberryPi Serial Provider\u0026#34; {raspberrypi-serial} \u0026lt;com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl} ? ??PROVIDER: \u0026#34;PiGpio Serial Provider\u0026#34; {pigpio-serial} \u0026lt;com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl} ??PWM: [2] \u0026lt;com.pi4j.io.pwm.PwmProvider\u0026gt; ? ??PROVIDER: \u0026#34;PiGpio PWM Provider\u0026#34; {pigpio-pwm} \u0026lt;com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl} ? ??PROVIDER: \u0026#34;RaspberryPi PWM Provider\u0026#34; {raspberrypi-pwm} \u0026lt;com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl} ??I2C: [2] \u0026lt;com.pi4j.io.i2c.I2CProvider\u0026gt; ? ??PROVIDER: \u0026#34;PiGpio I2C Provider\u0026#34; {pigpio-i2c} \u0026lt;com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl} ? ??PROVIDER: \u0026#34;RaspberryPi I2C Provider\u0026#34; {raspberrypi-i2c} \u0026lt;com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl} ??ANALOG_OUTPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogOutputProvider\u0026gt; ??SPI: [2] \u0026lt;com.pi4j.io.spi.SpiProvider\u0026gt; ? ??PROVIDER: \u0026#34;PiGpio SPI Provider\u0026#34; {pigpio-spi} \u0026lt;com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl} ? ??PROVIDER: \u0026#34;RaspberryPi SPI Provider\u0026#34; {raspberrypi-spi} \u0026lt;com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl} ??DIGITAL_OUTPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalOutputProvider\u0026gt; ? ??PROVIDER: \u0026#34;RaspberryPi Digital Output (GPIO) Provider\u0026#34; {raspberrypi-digital-output} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl} ? ??PROVIDER: \u0026#34;PiGpio Digital Output (GPIO) Provider\u0026#34; {pigpio-digital-output} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl} ??ANALOG_INPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogInputProvider\u0026gt; [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ------------------- [main] INFO com.pi4j.util.Console - | Pi4J REGISTRY | [main] INFO com.pi4j.util.Console - ------------------- REGISTRY: [1] \u0026#34;I/O Registered Instances\u0026#34; \u0026lt;com.pi4j.registry.impl.DefaultRegistry\u0026gt; ??IO: \u0026#34;DOUT-1\u0026#34; {my-digital-output-1} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutput\u0026gt; {DOUT-1} [main] INFO com.pi4j.util.Console -  Thanks to Manuel de Vega Barreiro for this contribution.\n"},{"uri":"https://pi4j.com/documentation/building/fat-jar/","title":"Build as a FAT JAR with Maven","tags":["FatJAR"],"description":"","content":" EXAMPLE PROJECT: https://github.com/Pi4J/pi4j-example-fatjar\n About FAT JARs With Pi4J V1 you can create a so-called FAT JAR, which packages all the dependencies into one jar-file. That way it is very easy to build your project on one computer and distribute your application as a single file to one or more clients.\nBecause of the modular approach and how Pi4J V2 loads it dependencies at runtime, this approach can be achieved by using the maven-shade-plugin.\nExample FAT JAR project Check the example project (link on top of this page) for the full README, pom.xml and sources.\nMaven plugins Three plugins are used in pom.xml to create the FAT JAR:\n\u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;pi4j-example-fatjar\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- https://maven.apache.org/plugins/maven-compiler-plugin/ The Compiler Plugin is used to compile the sources of your project. --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-compiler-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;release\u0026gt;${java.version}\u0026lt;/release\u0026gt; \u0026lt;showDeprecation\u0026gt;true\u0026lt;/showDeprecation\u0026gt; \u0026lt;showWarnings\u0026gt;true\u0026lt;/showWarnings\u0026gt; \u0026lt;verbose\u0026gt;false\u0026lt;/verbose\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- https://maven.apache.org/plugins/maven-jar-plugin/ This plugin provides the capability to build (executable) jars and is used here to set the mainClass which will start the application. --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-jar-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;${main.class}\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- https://maven.apache.org/plugins/maven-shade-plugin/ This plugin provides the capability to package the artifact in an uber-jar, including its dependencies and to shade - i.e. rename - the packages of some of the dependencies. The transformer will combine the files in the META-INF.services directories of multiple Pi4J plugins with the same package name into one file. --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-shade-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;transformers\u0026gt; \u0026lt;transformer implementation=\u0026#34;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\u0026#34;/\u0026gt; \u0026lt;/transformers\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;shade\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; By using maven-shade-plugin the correct META-INF.services files are generated.\nAs a jar-file is actually a zip-file, we can easily check the contents of the FAT JAR after it has been created with mvn package:\n directories  com lib META-INF org   files  LICENSE.txt NOTICE.txt README.md    Loading of the Pi4J modules Pi4J V2 uses ServiceLoader to detect which modules are available to communicate with the GPIOs. This allows to very dynamically extend the possibilities of the framework.\nCode extract from pi4j-core/src/\u0026hellip;/runtime/impl/DefaultRuntime.java:\n// detect available Pi4J Plugins by scanning the classpath looking for plugin instances var plugins = ServiceLoader.load(Plugin.class); Thanks to the maven-shade-plugin, each Pi4J plugin that is part of the project, is included in META-INF/services/com.pi4j.extension.Plugin:\ncom.pi4j.plugin.raspberrypi.RaspberryPiPlugin com.pi4j.plugin.pigpio.PiGpioPlugin When running this application we can indeed see the loaded platform and provider plugins in the logs:\n[main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - | Pi4J DEFAULT PLATFORM | [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - PLATFORM: \u0026quot;RaspberryPi Platform\u0026quot; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PROVIDERS | [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - PROVIDERS: [12] \u0026quot;I/O Providers\u0026quot; \u0026lt;com.pi4j.provider.impl.DefaultProviders\u0026gt; ├─SPI: [2] \u0026lt;com.pi4j.io.spi.SpiProvider\u0026gt; │ ├─PROVIDER: \u0026quot;PiGpio SPI Provider\u0026quot; {pigpio-spi} \u0026lt;com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl} │ └─PROVIDER: \u0026quot;RaspberryPi SPI Provider\u0026quot; {raspberrypi-spi} \u0026lt;com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl} ├─ANALOG_INPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogInputProvider\u0026gt; ├─SERIAL: [2] \u0026lt;com.pi4j.io.serial.SerialProvider\u0026gt; │ ├─PROVIDER: \u0026quot;PiGpio Serial Provider\u0026quot; {pigpio-serial} \u0026lt;com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl} │ └─PROVIDER: \u0026quot;RaspberryPi Serial Provider\u0026quot; {raspberrypi-serial} \u0026lt;com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl} ├─DIGITAL_INPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalInputProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi Digital Input (GPIO) Provider\u0026quot; {raspberrypi-digital-input} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio Digital Input (GPIO) Provider\u0026quot; {pigpio-digital-input} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl} ├─I2C: [2] \u0026lt;com.pi4j.io.i2c.I2CProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi I2C Provider\u0026quot; {raspberrypi-i2c} \u0026lt;com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio I2C Provider\u0026quot; {pigpio-i2c} \u0026lt;com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl} ├─ANALOG_OUTPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogOutputProvider\u0026gt; ├─DIGITAL_OUTPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalOutputProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi Digital Output (GPIO) Provider\u0026quot; {raspberrypi-digital-output} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio Digital Output (GPIO) Provider\u0026quot; {pigpio-digital-output} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl} └─PWM: [2] \u0026lt;com.pi4j.io.pwm.PwmProvider\u0026gt; ├─PROVIDER: \u0026quot;RaspberryPi PWM Provider\u0026quot; {raspberrypi-pwm} \u0026lt;com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl} └─PROVIDER: \u0026quot;PiGpio PWM Provider\u0026quot; {pigpio-pwm} \u0026lt;com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl} [main] INFO com.pi4j.util.Console - "},{"uri":"https://pi4j.com/documentation/building/modules-maven/","title":"Build Java modules with Maven","tags":["Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\n Because the Pi4J V2 project follows the modular approach of Java, the functionality of the framework has been split into different modules, each with their own responsibility.\nThe easiest way to start a new project, is to copy one of the example projects which include a full Maven pom.xml-file with all the required steps and configurations to build the project with all its modules into the target/distribution directory.\nTake for instance a look at the \u0026ldquo;Minimal example application\u0026rdquo;.\nBuild your project with:\n$ mvn clean package When finished, you will find the generated package and required Java-modules and can start your application with the provided run.sh script:\n$ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 364456 Jun 19 10:04 pi4j-core-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 7243 Jun 19 10:04 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 142461 Jun 19 10:04 pi4j-library-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 37302 Jun 19 10:04 pi4j-plugin-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 26917 Jun 19 10:04 pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run.sh -rw-r--r-- 1 pi pi 52173 Jun 19 10:04 slf4j-api-2.0.0-alpha0.jar -rw-r--r-- 1 pi pi 15372 Jun 19 10:04 slf4j-simple-2.0.0-alpha0.jar $ sudo ./run.sh "},{"uri":"https://pi4j.com/documentation/building/modules-gradle/","title":"Build Java modules with Gradle","tags":["Gradle"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\n The Pi4J V2 project itself uses Maven and most example projects also use this build tool. But if you prefer to use Gradle, you can start with a copy of the \u0026ldquo;Minimal example application\u0026rdquo; which includes all the required files to build with Gradle.\nUse Gradle version 6.6 (or later) and Java 11 OpenJDK (or later). The Gradle wrapper is used as described on docs.gradle.org. The Gradle configuration file build.gradle-file is included in the sources.\nBuild with Gradle On Linux:\n./gradlew build\nOn Windows:\ngradlew.bat build\nBuild result Once the build is complete and was successful, you can find the compiled build (Gradle) folder. Specifically all dependency modules (JARs) and a simple run.sh bash script will be located in the build/distribution (Gradle) folder.\nThese are all the required files needed to distribute (copy) to your Raspberry Pi to run this project. If you are using the native bindings running locally on the Raspberry Pi, then you make have to run the program using sudo to gain the necessary access permissions to the hardware I/O.\nThis is the list of files created by the build process of this example application:\n pi4j-core pi4j-example-minimal pi4j-library-pigpio pi4j-plugin-pigpio pi4j-plugin-raspberrypi slf4j-api slf4j-simple run.sh \u0026ndash;\u0026gt; this is the actual start file which will run pi4j-example-minimal  Run on Raspberry Pi Make the run script executable and start it like this:\n$ chmod +x run.sh $ sudo ./run.sh "},{"uri":"https://pi4j.com/documentation/building/jbang/","title":"Running Pi4J with JBang","tags":["JBang"],"description":"","content":" JBang project website: https://www.jbang.dev/\n What is JBang? As described on their website:\nJBang lets Students, Educators and Professional Developers create, edit and run self-contained source-only Java programs with unprecedented ease.\nWant to learn, explore or use Java instantly without setup ? Do you like Java but use python, groovy, kotlin or similar languages for scripts, experimentation and exploration ? Ever wanted to just be able to run Java from anywhere without any or very minimal setup ? Ever tried out Java 11+ support for running .java files directly in your shell but felt it was a bit too cumbersome ?\nJBang lets you do all this!\nVideo This video shows you all the steps described further on this page.\n  Prepare a Raspberry Pi For this manual you can use the following approach:\n Grab an SD card (minimum 8Gb) Use the Raspberry Pi Imager tool to write the \u0026ldquo;Raspberry Pi OS (32-bit)\u0026rdquo; to this SD card Push the SD card into your Raspberry Pi board Power up and wait until the OS has booted (it will probably restart once to resize the partition on the SD card to the maximum available size) Open a terminal and confirm Java is not available yet (except if you selected the \u0026ldquo;Raspberry Pi OS Full (32-bit)\u0026rdquo; version)  $ java -version bash: java: command not found Installing JBang As described on jbang.dev/download installing JBang is enough to get started, even if you don\u0026rsquo;t have Java installed already, as JBang will also take care of this.\n$ curl -Ls https://sh.jbang.dev | bash -s - app setup $ java -version openjdk version \u0026#34;11.0.14\u0026#34; 2022-01-18 OpenJDK Runtime Environment Temurin-11.0.14+9 (build 11.0.14+9) OpenJDK Server VM Temurin-11.0.14+9 (build 11.0.14+9, mixed mode) Minimal JBang example A minimal JBang Java-file looks like the following code block, take note of the special first line that tricks the system to run this as a script while still being valid Java-code.\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $?  class HelloWorld { public static void main(String[] args) { if(args.length==0) { System.out.println(\u0026#34;Hello World!\u0026#34;); } else { System.out.println(\u0026#34;Hello \u0026#34; + args[0]); } } } By saving this file as HelloWorld.java it can be started with:\n$ jbang HelloWorld.java Hello World! JBang Pi4J example If your project needs dependencies - which is the case for a Pi4J project - you can define them in the java-file with the following gradle-style locators format, for example: //DEPS com.pi4j:pi4j-core:2.1.1.\nThe following example is based on the \u0026ldquo;Minimal example application\u0026rdquo;, and uses the same wiring with a button and LED. By using JBang we can run this project with a single file without the need of a full Maven or Gradle project, or compiling the Java code.\nCreate a new file JBangPi4JExample.java with the following content:\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? //DEPS org.slf4j:slf4j-api:1.7.35 //DEPS org.slf4j:slf4j-simple:1.7.35 //DEPS com.pi4j:pi4j-core:2.1.1 //DEPS com.pi4j:pi4j-plugin-raspberrypi:2.1.1 //DEPS com.pi4j:pi4j-plugin-pigpio:2.1.1  import com.pi4j.Pi4J; import com.pi4j.io.gpio.digital.DigitalInput; import com.pi4j.io.gpio.digital.DigitalOutput; import com.pi4j.io.gpio.digital.DigitalState; import com.pi4j.io.gpio.digital.PullResistance; import com.pi4j.util.Console; class JBangPi4JExample { private static final int PIN_BUTTON = 24; // PIN 18 = BCM 24  private static final int PIN_LED = 22; // PIN 15 = BCM 22  private static int pressCount = 0; public static void main(String[] args) throws Exception { final var console = new Console(); var pi4j = Pi4J.newAutoContext(); var ledConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;led\u0026#34;) .name(\u0026#34;LED Flasher\u0026#34;) .address(PIN_LED) .shutdown(DigitalState.LOW) .initial(DigitalState.LOW) .provider(\u0026#34;pigpio-digital-output\u0026#34;); var led = pi4j.create(ledConfig); var buttonConfig = DigitalInput.newConfigBuilder(pi4j) .id(\u0026#34;button\u0026#34;) .name(\u0026#34;Press button\u0026#34;) .address(PIN_BUTTON) .pull(PullResistance.PULL_DOWN) .debounce(3000L) .provider(\u0026#34;pigpio-digital-input\u0026#34;); var button = pi4j.create(buttonConfig); button.addListener(e -\u0026gt; { if (e.state() == DigitalState.LOW) { pressCount++; console.println(\u0026#34;Button was pressed for the \u0026#34; + pressCount + \u0026#34;th time\u0026#34;); } }); while (pressCount \u0026lt; 5) { if (led.equals(DigitalState.HIGH)) { console.println(\u0026#34;LED low\u0026#34;); led.low(); } else { console.println(\u0026#34;LED high\u0026#34;); led.high(); } Thread.sleep(500 / (pressCount + 1)); } pi4j.shutdown(); } } Without the need of any further configuration, installation, dependency download, or compiling, we should now be able to run this code with:\n$ jbang JBangPi4JExample.java [jbang] Building jar... [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] WARN com.pi4j.library.pigpio.impl.PiGpioNativeImpl - PIGPIO ERROR: PI_INIT_FAILED; pigpio initialisation failed Auch, an error\u0026hellip;?! But this is a known one! At this moment, PiGpio - the underlying native library which interacts with the GPIOs - needs to be called as sudo. This is not ideal, and we are investigating how we can rework this. But with some additional steps this can be fixed easily!\nFirst we need to find out where JBang is installed for our current user with which jbang. This full path can be used to start JBang from that location, instead of the shortcut jbang that was automatically created by JBang for the pi user (in this case). As Java was installed by JBang for the pi user, it needs to do this again for the sudo user, but also this is handled automatically again by JBang.\n$ which jbang /home/pi/.jbang/bin/jbang $ sudo /home/pi/.jbang/bin/jbang JBangPi4JExample.java Downloading JDK 11. Be patient, this can take several minutes... [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED low [Thread-0] INFO com.pi4j.util.Console - Button was pressed for the 1th time [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [Thread-2] INFO com.pi4j.util.Console - Button was pressed for the 2th time [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high ... [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [Thread-8] INFO com.pi4j.util.Console - Button was pressed for the 5th time Yep, we have a working example, with dependencies, without the need to compile anything!\nAnd both commands can even be combined to make things even more easy, allowing you to start the application simply with:\n$ sudo `which jbang` JBangPi4JExample.java Conclusion JBang is a great way to run single-file Java-files, and helps you to quickly get started with Pi4J on the Raspberry Pi, and can be the ideal getting-started method to experiment with electronics and Java.\nThanks to Max Rydahl Andersen and the many contributors for creating JBang and to propose the solution how sudo can be combined with JBang.\n"},{"uri":"https://pi4j.com/documentation/io-examples/digital-output/","title":"Digital Output (GPIO)","tags":["Digital Output"],"description":"","content":"A digital output translates a false/true (or 0/1) to an output value of 0V or 3.3V. This means you can control any type of device which works with max 3.3V to off or on. The most basic example is a LED. Always check which is the correct input voltage for your device! For a LED you will need to put a resistor with the correct value between the GPIO and the LED, you can find a lot of examples and calculators online, for example on circuitdigest.com/calculators/led-resistor-calculator.\nThe following example shows the minimal code to configure the DIGITAL_OUTPUT_PIN pin number as an output pin and change the state with different methods which are provided by the Pi4J library.\n// Initialize Pi4J with an auto context // An auto context includes AUTO-DETECT BINDINGS enabled // which will load all detected Pi4J extension libraries // (Platforms and Providers) in the class path var pi4j = Pi4J.newAutoContext(); // create a digital output instance using the default digital output provider var output = pi4j.dout().create(DIGITAL_OUTPUT_PIN); output.config().shutdownState(DigitalState.HIGH); // setup a digital output listener to listen for any state changes on the digital output output.addListener(System.out::println); // lets invoke some changes on the digital output output.state(DigitalState.HIGH) .state(DigitalState.LOW) .state(DigitalState.HIGH) .state(DigitalState.LOW); // lets toggle the digital output state a few times output.toggle() .toggle() .toggle(); // another friendly method of setting output state output.high() .low(); // lets read the digital output state System.out.print(\u0026#34;CURRENT DIGITAL OUTPUT [\u0026#34; + output + \u0026#34;] STATE IS [\u0026#34;); System.out.println(output.state() + \u0026#34;]\u0026#34;); // pulse to HIGH state for 3 seconds System.out.println(\u0026#34;PULSING OUTPUT STATE TO HIGH FOR 3 SECONDS\u0026#34;); output.pulse(3, TimeUnit.SECONDS, DigitalState.HIGH); System.out.println(\u0026#34;PULSING OUTPUT STATE COMPLETE\u0026#34;); // shutdown Pi4J pi4j.shutdown(); "},{"uri":"https://pi4j.com/documentation/io-examples/digital-input/","title":"Digital Input (GPIO)","tags":["Digital Input"],"description":"","content":"Similar to a digital output pin, a digital input translates an input value of 0V or 3.3V to the value false/true. This means any type of device which can toggle between 3.3V and 0V, can generate an input value to the Raspberry Pi. Here the most basic example is a toggle button. If you use other components, always check which is the voltage provided by the device. Or if you use a power pin from the Raspberry Pi itself, to use a 3.3V pin and not a 5V pin.\nV.2 provides a declarative style of configuration for I/O provisioning instead of the hard-coded approach offered in V.1.\nExamples of the various methods and approaches which can be used to provision the I/O needs are available in the examples project.\nProperties properties = new Properties(); properties.put(\u0026#34;id\u0026#34;, \u0026#34;my_digital_input\u0026#34;); properties.put(\u0026#34;address\u0026#34;, DIGITAL_INPUT_PIN); properties.put(\u0026#34;pull\u0026#34;, \u0026#34;UP\u0026#34;); properties.put(\u0026#34;name\u0026#34;, \u0026#34;MY-DIGITAL-INPUT\u0026#34;); var config = DigitalInput.newConfigBuilder(pi4j) .load(properties) .build(); var input = pi4j.din().create(config); s Once an input has been initialized, a listener can be attached to execute code on state changes of the input.\ninput.addListener(e -\u0026gt; { if (e.state() == DigitalState.HIGH) { console.println(\u0026#34;Button is pressed\u0026#34;); } }); "},{"uri":"https://pi4j.com/documentation/io-examples/pwm/","title":"Pulse Width Modulation (PWM)","tags":["PWM"],"description":"","content":"What is it? The abbreviation PWM stands for \u0026ldquo;Pulse Width Modulation\u0026rdquo; and is also often referred to in German as pulse width modulation or pulse width modulation. This technology is used, among other things, to control servomotors and is also used, for example, for the fans of a regular computer.\nWith PWM, it is possible to control a component such as a motor no longer purely binary, i.e. off (0% power) or on (100% power), but to control them almost at will. The functionality of PWM works in such a way that the component is switched off and on again and again within a certain period of time.\nSoftware vs. Hardware Two different types of PWM are available on the Raspberry Pi, specifically a software and a hardware implementation. Both basically offer the same options, but the software version cannot achieve precise or particularly fast frequencies.\nThe reason for this is that in the software implementation for each individual cycle (on / off) a new control command must be transmitted from the JVM (Java Virtual Machine) to the corresponding component, while in the hardware implementation of the Raspberry Pi notices the desired frequency and regulates it independently directly on the board.\nThe Raspberry Pi supports 2 hardware based PWM channels. You can access these two channels via 2 separate sets of 4 GPIO header pins, but still limited to only 2 channels (2 unique PWM timing configurations).\nThe same PWM channel is available on multiple GPIO. The latest frequency and dutycycle setting will be used by all GPIO which share a PWM channel. The GPIO must be one of the following: 12 PWM channel 0 All models but A and B 13 PWM channel 1 All models but A and B 18 PWM channel 0 All models 19 PWM channel 1 All models but A and B 40 PWM channel 0 Compute module only 41 PWM channel 1 Compute module only 45 PWM channel 1 Compute module only 52 PWM channel 0 Compute module only 53 PWM channel 1 Compute module only As Pi4J is using PiGPIO \u0026ldquo;under the hood\u0026rdquo;, you can take advantage of the additional PWM functionalities of it. PiGPIO is providing additional (soft) PWM support to any of the GPIO pins (0-31) and its using some hardware timing technique to optimize performance \u0026mdash; but its not the same as the actual hardware PWM pins natively on the RaspberryPi. In the Pi4J API, we call this \u0026ldquo;Software\u0026rdquo; PWM and you would need to set .pwmType(PwmType.SOFTWARE). We consider this software-based PWM because its being provided at a software layer, in this case by the PIGPIO library.\nIf you need more than 2 PWM pins, use the software PWM functionality, it may be perfectly fine for your application. If they are not good enough, then you will probably need a PWM expander board/chip (controlled by I2C/SPI) to provide additional PWM support.\nTechnical implementation For the technical control of a component with PWM, two values must be defined:\n Pulse-pause ratio (English: Duty Cycle): This value defines the ratio between the switched-on and switched-off status and is represented by a number between 0% and 100%. A value of 50% means that within one cycle the component is switched on exactly half the time and then switched off. A value of 25%, on the other hand, would mean that the component is switched on only a quarter of the time and the component remains switched off for the remaining three quarters of the cycle. Frequency: This value defines how often per second a cycle (on / off) takes place for this component and is usually specified in the unit Hertz (Hz). With a value of 10Hz, the component would alternate 10 times between being switched on and switched off in one second.  These two values can be controlled via the Pi4J library and are also used internally by this project.\nAdditional Information  Wikipedia on PWM Wikipedia with audio frequencies  Code example The following example is an extract of the CrowPi example project which includes a component to control a buzzer with PWM.\npublic class BuzzerComponent extends Component { protected final Pwm pwm; /** * Creates a new buzzer component with a custom BCM pin. * * @param pi4j Pi4J context * @param address Custom BCM pin address */ public BuzzerComponent(Context pi4j, int address) { this.pwm = pi4j.create(buildPwmConfig(pi4j, address)); } /** * Plays a tone with the given frequency in Hz indefinitely. * This method is non-blocking and returns immediately. * A frequency of zero causes the buzzer to play silence. * * @param frequency Frequency in Hz */ public void playTone(int frequency) { playTone(frequency, 0); } /** * Plays a tone with the given frequency in Hz for a specific duration. * This method is blocking and will sleep until the specified duration has passed. * A frequency of zero causes the buzzer to play silence. * A duration of zero to play the tone indefinitely and return immediately. * * @param frequency Frequency in Hz * @param duration Duration in milliseconds */ public void playTone(int frequency, int duration) { if (frequency \u0026gt; 0) { // Activate the PWM with a duty cycle of 50% and the given frequency in Hz.  // This causes the buzzer to be on for half of the time during each cycle, resulting in the desired frequency.  pwm.on(50, frequency); // If the duration is larger than zero, the tone should be automatically stopped after the given duration.  if (duration \u0026gt; 0) { sleep(duration); this.playSilence(); } } else { this.playSilence(duration); } } /** * Silences the buzzer and returns immediately. */ public void playSilence() { pwm.off(); } /** * Silences the buzzer and waits for the given duration. * This method is blocking and will sleep until the specified duration has passed. * * @param duration Duration in milliseconds */ public void playSilence(int duration) { this.playSilence(); sleep(duration); } /** * Returns the created PWM instance for the buzzer * * @return PWM instance */ protected Pwm getPwm() { return this.pwm; } /** * Builds a new PWM configuration for the buzzer * * @param pi4j Pi4J context * @param address BCM pin address * @return PWM configuration */ protected static PwmConfig buildPwmConfig(Context pi4j, int address) { return Pwm.newConfigBuilder(pi4j) .id(\u0026#34;BCM\u0026#34; + address) .name(\u0026#34;Buzzer\u0026#34;) .address(address) .pwmType(PwmType.HARDWARE) .provider(\u0026#34;pigpio-pwm\u0026#34;) .initial(0) .shutdown(0) .build(); } } "},{"uri":"https://pi4j.com/documentation/io-examples/i2c/","title":"Inter-Integrated Circuit (I²C)","tags":["I2C"],"description":"","content":"What is it? I²C (spoken as I-Squared-C) is a bus originally invented by Philips. It is designed as a classic master-slave bus. A data transfer is always i nitiated by a master. It can also be set up in a multi-master system. I²C is connected via two signal lines (data line and clock line). The transmission rate of the bus can be between 0.1 Mbit/s up to 3.4 Mbit/s depending on the clock rate. If only a unidirectional connection is required, even 5.0 Mbit/s would be possible. It should be noted: the higher the clock rate, the more susceptible to failure the overall system becomes. The low operating voltage of only 3.3V does not contribute to interference resistance either.\nUses I²C is mainly used for communication between microcontrollers. The advantage that a whole series of microcontrollers can be controlled via just 2 lines is of course very interesting for the circuit board layout. The main advantages of I²C are its simplicity. There are certainly newer bus systems with better transmission rates. Hardly any bus system is as easy to use as I²C. Even “hot plugging”, ie plugging in and unplugging the devices during operation, is possible with I²C.\nAddressing I²C uses an address space of 7 bits. This allows up to 112 nodes on one bus. The remaining 16 addresses are reserved for special applications. Usually the address of a device is defined directly by the manufacturer. It can therefore be found in the relevant data sheets. Due to the shortage of addresses, there is also a variant with a 10-bit address space. Up to 1136 nodes are possible, and the protocol is compatible with the smaller 7-bit address space.\nTransfer rates    Mode Max. transfer rate Direction     Standard Mode 0.1 Mbit/s bidirektional   Fast Mode 0.4 Mbit/s bidirektional   Fast Mode Plus 1.0 Mbit/s bidirektional   High Speed Mode 3.4 Mbit/s bidirektional   Ultra Fast-mode 5.0 Mbit/s unidirektional    Additional information  Wikipedia I²C I²C Bus  Code example The following code shows setting the pins on a TCA 9534 which can be found on \u0026ldquo;Sequent Microsystems\u0026rdquo;\nTo use the LinuxFS provider, which provides I2C, add the proper dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-linuxfs\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Now we can use the following example:\nimport com.pi4j.Pi4J; import com.pi4j.context.Context; import com.pi4j.io.i2c.I2C; import com.pi4j.io.i2c.I2CConfig; import com.pi4j.io.i2c.I2CProvider; public class SimpleTca9534I2cTest { private static final byte TCA9534_REG_ADDR_OUT_PORT = 0x01; private static final byte TCA9534_REG_ADDR_CFG = 0x03; public static void main(String[] args) throws Exception { Context pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j).id(\u0026#34;TCA9534\u0026#34;).bus(1).device(0x3f).build(); try (I2C tca9534Dev = i2CProvider.create(i2cConfig)) { int config = tca9534Dev.readRegister(TCA9534_REG_ADDR_CFG); if (config \u0026lt; 0) throw new IllegalStateException( \u0026#34;Failed to read configuration from address 0x\u0026#34; + String.format(\u0026#34;%02x\u0026#34;, TCA9534_REG_ADDR_CFG)); byte currentState = (byte) tca9534Dev.readRegister(TCA9534_REG_ADDR_OUT_PORT); if (config != 0x00) { System.out.println(\u0026#34;TCA9534 is not configured as OUTPUT, setting register 0x\u0026#34; + String .format(\u0026#34;%02x\u0026#34;, TCA9534_REG_ADDR_CFG) + \u0026#34; to 0x00\u0026#34;); currentState = 0x00; tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, currentState); tca9534Dev.writeRegister(TCA9534_REG_ADDR_CFG, (byte) 0x00); } // bit 8, is pin 1 on the board itself, so set pins in reverse: \tcurrentState = setPin(currentState, 8, tca9534Dev, true); Thread.sleep(500L); currentState = setPin(currentState, 8, tca9534Dev, false); Thread.sleep(500L); currentState = setPin(currentState, 7, tca9534Dev, true); Thread.sleep(500L); currentState = setPin(currentState, 7, tca9534Dev, false); Thread.sleep(500L); } } public static byte setPin(byte currentState, int pin, I2C tca9534Dev, boolean high) { byte newState; if (high) newState = (byte) (currentState | (1 \u0026lt;\u0026lt; pin)); else newState = (byte) (currentState \u0026amp; ~(1 \u0026lt;\u0026lt; pin)); System.out.println(\u0026#34;Setting TCA9534 to new state \u0026#34; + asBinary(newState)); tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, newState); return newState; } public static String asBinary(byte b) { StringBuilder sb = new StringBuilder(); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 7) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 6) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 5) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 3) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 0) \u0026amp; 1)); return sb.toString(); } } "},{"uri":"https://pi4j.com/documentation/io-examples/i2c/clock-stretching/","title":"I²C Clock Stretching","tags":["I2C"],"description":"","content":"Clock Stretching Please be aware there are some hardware issues when using the Raspberry Pi with devices that expect to be able to use clock stretching, for more info see \u0026ldquo;Adventures in I2C: clock stretching on the Raspberry Pi\u0026rdquo; and \u0026ldquo;I2C stretch bug. Been fixed or not?\u0026quot;.\n Clock stretching in I2C allows a slave device to halt the master before a more data is sent. This is often the case when the slave device writes to an EEPROM etc. which takes longer than a usual read or write to a register.\nOn the Raspberry Pi clock stretching can be configured by using a higher timeout while waiting for a slave to respond. This is something that can not be done by the pi4j, as it requires root privileges.\nThere are two ways to change the clkt_tout value. This repository path has two files, a i2c1_get_clkt_tout.c and i2c1_set_clkt_tout.c. Build them as follows:\nPrepare:\n# install gcc to compile the c files apt install build-essential mkdir clkt_tout cd clkt_tout/ wget wget https://raw.githubusercontent.com/raspihats/raspihats/master/clk_stretch/i2c1_get_clkt_tout.c wget wget https://raw.githubusercontent.com/raspihats/raspihats/master/clk_stretch/i2c1_set_clkt_tout.c Makefile\nSave as Makefile\nCC=gcc CFLAGS=-Wall .PHONY: all install uninstall clean all: i2c1_set_clkt_tout i2c1_get_clkt_tout i2c_get_clkt_tout: i2c1_get_clkt_tout.c $(CC) -o i2c1_get_clkt_tout i2c1_get_clkt_tout.c i2c_set_clkt_tout: i2c1_set_clkt_tout.c $(CC) -o i2c1_set_clkt_tout i2c1_set_clkt_tout.c install: cp i2c1_get_clkt_tout /usr/local/bin/i2c1_get_clkt_tout cp i2c1_set_clkt_tout /usr/local/bin/i2c1_set_clkt_tout uninstall: rm -f /usr/local/bin/i2c1_get_clkt_tout rm -f /usr/local/bin/i2c1_set_clkt_tout clean: rm -f i2c1_set_clkt_tout i2c1_get_clkt_tout Build and install\nmake sudo make install Usage\n# read current clkt_tout: $ sudo i2c1_get_clkt_tout i2c1_get_clkt_tout: CLKT.TOUT = 1000 # set timeout to 1 second: i2c_set_clkt_tout 1000 "},{"uri":"https://pi4j.com/documentation/io-examples/spi/","title":"Serial Peripheral Interface (SPI)","tags":["SPI"],"description":"","content":"What is it? The Serial Peripheral Interface, abbreviated to SPI, is a bus system which enables communication between a main device (called “master”) and one or more secondary devices (called “slave”). A direct communication between all participants is not possible here, much more the master can choose at any time with which slave he would like to exchange data.\nIn order to address only one slave, a total of 3 signal lines are required, two of which are used for bidirectional data transmission and one as a clock generator for serial transmission. If further slaves are to be addressed, additional signal lines are required depending on the desired topology.\nUses In addition to communication between microcontrollers, SPI is also used to address numerous sensors and actuators. Similar to I²C, a large number of control commands and data can be transmitted in both directions with a relatively high clock rate over 3 lines. A particular advantage here is the support for “full duplex”, ie the simultaneous transmission of data in both directions.\nThe technical implementation is very simple and is also used, for example, to communicate with SD cards. The Nintendo Game Boy already used this protocol to connect several game consoles via the Game Boy Link Cable.\nAddressing As already mentioned in the first section, multiple slaves can also be connected to SPI. The number available depends on the hardware used. On the Raspberry Pi, the standard SPI0 with two different slaves use what is called Chip Select Pins is controlled.\nAdditional Information  Wikipedia SPI SPI pinout for Raspberry Pi  Code example Initialize the Pi4J Context with a provider which supports SPI fully, e.g. the PiGpioSpiProvider. The minimal example would be:\nvar piGpio = PiGpio.newNativeInstance(); var pi4j = Pi4J.newContextBuilder() .noAutoDetect() .add( PiGpioSpiProvider.newInstance(piGpio) ) .build(); Depending on the type of GPIOs you need in your project this could be further extended to e.g.:\nvar piGpio = PiGpio.newNativeInstance(); var pi4j = Pi4J.newContextBuilder() .noAutoDetect() .add( PiGpioDigitalInputProvider.newInstance(piGpio), PiGpioDigitalOutputProvider.newInstance(piGpio), PiGpioPwmProvider.newInstance(piGpio), PiGpioI2CProvider.newInstance(piGpio), PiGpioSerialProvider.newInstance(piGpio), PiGpioSpiProvider.newInstance(piGpio) ) .build(); The following example is an extract of the CrowPi example project which includes a component to control an 8x8 LED matrix display with an MAX7219 driver chip which is controlled via SPI.\npublic class MAX7219 extends Component { // MAX7219: Internal Commands  private static final byte CMD_SET_FIRST_ROW = 0x01; private static final byte CMD_DECODE_MODE = 0x09; private static final byte CMD_INTENSITY = 0x0A; private static final byte CMD_SCAN_LIMIT = 0x0B; private static final byte CMD_SHUTDOWN = 0x0C; private static final byte CMD_DISPLAY_TEST = 0x0F; /** * Width of MAX7219 LED matrix */ public static final int WIDTH = 8; /** * Height of MAX7219 LED matrix */ public static final int HEIGHT = 8; /** * Internal buffer to store the 8x8 matrix * A byte[] array is used as each of the 8 bits is used to represent a column */ protected final byte[] buffer = new byte[HEIGHT]; /** * Pi4J SPI instance */ protected final Spi spi; /** * Creates a new MAX7219 instance using the given SPI instance from Pi4J. * * @param spi SPI instance */ public MAX7219(Spi spi) { this.spi = spi; } /** * Clears the internal buffer without refreshing the display. * This means that the current contents of the displays are still being shown until {@link #refresh()} is called. */ public void clear() { Arrays.fill(buffer, (byte) 0); } /** * Flushes the internal buffer for all rows to the chip, causing it to be displayed. * The contents of the buffer will be preserved by this command. */ public void refresh() { for (int row = 0; row \u0026lt; HEIGHT; row++) { refreshRow(row); } } /** * Flushes the internal buffer for a single row to the chip, causing it to be displayed. * The contents of the buffer will be preserved by this command. * * @param row Row to be flushed */ protected void refreshRow(int row) { if (row \u0026lt; 0 || row \u0026gt;= HEIGHT) { throw new IllegalArgumentException(\u0026#34;Row must be an integer in the range 0-\u0026#34; + HEIGHT); } execute((byte) (CMD_SET_FIRST_ROW + row), buffer[row]); } /** * Specifies if the LED matrix should be enabled or disabled. * This will also setup the proper decoding mode and scan limit when enabling the chip. * * @param enabled LED matrix state (true = ON, false = OFF) */ public void setEnabled(boolean enabled) { if (enabled) { execute(CMD_SHUTDOWN, (byte) 0x01); execute(CMD_DECODE_MODE, (byte) 0x00); execute(CMD_SCAN_LIMIT, (byte) 0x07); } else { execute(CMD_SHUTDOWN, (byte) 0x00); } } /** * Enables or disables the testing mode of the LED matrix. * When enabled, all other options (including {@link #setEnabled(boolean)} are ignored and all LEDs are turned on. * To actually control the chip, the test mode MUST be disabled. * * @param enabled Test mode state (true = ON, false = OFF) */ public void setTestMode(boolean enabled) { execute(CMD_DISPLAY_TEST, (byte) (enabled ? 0x01 : 0x00)); } /** * Changes the desired brightness for the LED matrix. * This method expects an integer value within the range 0-15, with 0 being the dimmest and 15 the brightest possible value. * The whole display is affected by this command which gets immediately applied. * * @param brightness Desired brightness from 0-15 */ public void setBrightness(int brightness) { if (brightness \u0026lt; 0 || brightness \u0026gt; 15) { throw new IllegalArgumentException(\u0026#34;Brightness must be an integer in the range 0-15\u0026#34;); } execute(CMD_INTENSITY, (byte) brightness); } /** * Enables or disables the pixel at the given X/Y position within the internal buffer. * This change will not be visible until {@link #refresh()} or {@link #refreshRow(int)} gets called. * * @param x X position to change * @param y Y position to change * @param enabled Desired pixel state (true = ON, false = OFF) */ public void setPixel(int x, int y, boolean enabled) { // Ensure coordinates are within boundaries  checkPixelBounds(x, y); // Generate bitmask and set/unset specific bit  final byte mask = (byte) (1 \u0026lt;\u0026lt; (WIDTH - 1 - x)); if (enabled) { buffer[y] |= mask; } else { buffer[y] \u0026amp;= ~mask; } } /** * Retrieves the pixel at the given X/Y position within the internal buffer. * * @param x X position to change * @param y Y position to change * @return Current state of specified pixel (true = ON, false = OFF) */ public boolean getPixel(int x, int y) { // Ensure coordinates are within boundaries  checkPixelBounds(x, y); // Generate bitmask and retrieve specific bit  final byte mask = (byte) (1 \u0026lt;\u0026lt; (WIDTH - 1 - x)); return (buffer[y] \u0026amp; mask) != 0; } /** * Ensures the given X and Y coordinates are within the boundaries of this LED matrix. * An {@link IllegalArgumentException} will be thrown if outside. * * @param x X coordinate to check * @param y Y coordinate to check */ private void checkPixelBounds(int x, int y) { if (x \u0026lt; 0 || x \u0026gt;= WIDTH) { throw new IllegalArgumentException(\u0026#34;X must be an integer in the range 0-\u0026#34; + WIDTH); } if (y \u0026lt; 0 || y \u0026gt;= WIDTH) { throw new IllegalArgumentException(\u0026#34;Y must be an integer in the range 0-\u0026#34; + HEIGHT); } } /** * Helper method for sending a command to the MAX7219 chip with data. Communication happens over SPI by simply sending two pieces of * data, more specifically the desired command as a byte value, followed by the data as another byte value. * * @param command Command to be executed * @param data Data for the given command */ private void execute(byte command, byte data) { spi.write(command, data); } } "},{"uri":"https://pi4j.com/documentation/io-examples/serial/","title":"Serial (UART/RS232)","tags":["Serial"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-components/tree/main/src/main/java/com/pi4j/example/serial/gps\n What is it? Serial communication can be used to transfer data between different boards, devices, etc. Data is transfered bit-by-bit in a sequence, through a single wire from a transmitter (= TX) to a receiver (= RX). On the receiver side the bits are combined to bytes.\nWhen you need two-way communication, two wires are needed between RX and TX from both sides:\nThe communication between these two devices can happen in different ways:\n simplex: one direction only without a message back to confirm the receiving half-duplex: devices can only send or receive at once full-duplex: both devices can send and receive at the same time  Serial communication is done at a predefined speed which needs to be known on both sides, as both the sender and receiver need to handle the data at the same speed. This speed is called the \u0026ldquo;baud rate\u0026rdquo; with a value indicating the number of bits per second (bps). The most used speed is 9600 bps, but you can use lower (1200, 2400, 4800) or higher (19200, 38400, 57600, 115200) speeds, depending on the speed which can be handled reliably by the device.\nThe Pi has two built-in connections to GPIOs BCM number 14 (TX) and 15 (RX). Identical to the other GPIOs, they use 3.3V so make sure, when you connect other devices, the same voltage is used.\nCode example The following example demonstrates how you can connect to a GPS module to read the data. This example is based on an example from the book \u0026ldquo;The Definitive Guide to Modern Java Clients with JavaFX\u0026rdquo; by Stephen Chin, Johan Vos and James Weaver. That example uses V1 of Pi4J with a listener provided by the library. In V2 this listener is no longer provided but can easily be achieved with a Thread to handle the incoming data.\nWiring The GPS module used in this example: NEO-7M.\n   NEO-7M Raspberry Pi     VCC Power 5V (e.g. pin 2)   GND Ground (e.g. pin 6)   RX UART TX, GPIO 15   TX UART RX, GPIO 16    In the readme of the coding example, you can find the description how you can test the GPS module in the terminal with gpsd.socket.\nInitialize the serial port First Pi4J needs to be initialized. Within this context we can then configure and open the serial port. As long as the serial port is open, we run a thread to handle the incoming data.\nvar console = new Console(); var pi4j = Pi4J.newAutoContext(); var serial = pi4j.create(Serial.newConfigBuilder(pi4j) .use_9600_N81() .dataBits_8() .parity(Parity.NONE) .stopBits(StopBits._1) .flowControl(FlowControl.NONE) .id(\u0026#34;my-serial\u0026#34;) .device(SERIAL_ADDRESS) .provider(\u0026#34;pigpio-serial\u0026#34;) .build()); serial.open(); // Wait till the serial port is open console.print(\u0026#34;Waiting till serial port is open\u0026#34;); while (!serial.isOpen()) { Thread.sleep(250); } // Start a thread to handle the incoming data from the serial port SerialReader serialReader = new SerialReader(console, serial); Thread serialReaderThread = new Thread(serialReader, \u0026#34;SerialReader\u0026#34;); serialReaderThread.setDaemon(true); serialReaderThread.start(); while (serial.isOpen()) { Thread.sleep(500); } serialReader.stopReading(); Serial reader The reader itself implements a Runnable and waits till data is available from the serial port. As the GPS module sends its data as readable String lines seperated by a line separator, we only need to handle the bytes which are higher than 32 (see the ASCII code table). All lower values are handled as line separators.\npublic class SerialReader implements Runnable { private final Console console; private final Serial serial; private boolean continueReading = true; public SerialReader(Console console, Serial serial) { this.console = console; this.serial = serial; } public void stopReading() { continueReading = false; } @Override public void run() { // We use a buffered reader to handle the data received from the serial port  BufferedReader br = new BufferedReader(new InputStreamReader(serial.getInputStream())); try { // Data from the GPS is recieved in lines  String line = \u0026#34;\u0026#34;; // Read data until the flag is false  while (continueReading) { // First we need to check if there is data available to read.  // The read() command for pigio-serial is a NON-BLOCKING call,  // in contrast to typical java input streams.  var available = serial.available(); if (available \u0026gt; 0) { for (int i = 0; i \u0026lt; available; i++) { byte b = (byte) br.read(); if (b \u0026lt; 32) { // All non-string bytes are handled as line breaks  if (!line.isEmpty()) { // Here we should add code to parse the data to a GPS data object  console.println(\u0026#34;Data: \u0026#39;\u0026#34; + line + \u0026#34;\u0026#39;\u0026#34;); line = \u0026#34;\u0026#34;; } } else { line += (char) b; } } } else { Thread.sleep(10); } } } catch (Exception e) { console.println(\u0026#34;Error reading data from serial: \u0026#34; + e.getMessage()); System.out.println(e.getStackTrace()); } } } Running the application on Raspberry Pi You can get the full working example from GitHub and run on a Raspberry Pi after you correctly connected a GPS module. As you can see in the output, each data line (starting with $GP...) is logged.\n[main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - \u0026lt;-- The Pi4J Project --\u0026gt; [main] INFO com.pi4j.util.Console - Serial Example project [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] ... [main] INFO com.pi4j.util.Console - Waiting till serial port is open [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - Serial port is open ... [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPVTG,,T,,M,2.349,N,4.351,K,A*2C\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGGA,143723.00,5054.02265,N,00301.10531,E,1,04,10.46,86.2,M,45.9,M,,*5C\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGSA,A,3,09,16,05,07,,,,,,,,,17.19,10.46,13.64*33\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGSV,2,1,06,05,33,304,20,07,67,101,21,09,39,079,29,11,38,228,20*7E\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGSV,2,2,06,16,11,030,24,20,63,283,*73\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGLL,5054.02265,N,00301.10531,E,143723.00,A,A*6A\u0026#39; "},{"uri":"https://pi4j.com/architecture/pi4j-logo/","title":"The Pi4J Logo","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-logo\n The Pi4J logo has been designed by Gerrit Grunwald and is nicely combines a raspberry pie with Duke, the Java Masqot.\n"},{"uri":"https://pi4j.com/architecture/advanced/annotated-provisioning/","title":"Annotated provisioning","tags":[],"description":"","content":" To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations\n Next to the declarative approach, Java annotations are available for the configuration of I/O provisioning instead of the hard-coded approach offered in V.1.\nThis implementation still needs to be further fine-tuned and unified somehow to make things cleaner and more straightforward, but would provide a way to initialize a I/O for instance like this:\n@Register(0) @Address(\u0026#34;my.digital.input.pin.zero\u0026#34;) @Name(\u0026#34;My Digital Input Pin\u0026#34;) @Debounce(300000) // microseconds @WithProvider(type=PiGpioDigitalInputProvider.class) private DigitalInput input; "},{"uri":"https://pi4j.com/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/crowpi/","title":"CrowPi","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/dependency-injection/","title":"Dependency injection","tags":[],"description":"","content":" To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations\n Along with the annotated I/O configuration the ability to support I/O provisioning via dependency injection also makes a lot of sense. There is some basic brute-force stuff working but this needs more work to make this a compatible implementation for Spring or CDI.\n@Inject private Context pi4j; // register a digital input listener to listen for any value changes on the digital input pin @Register(DIGITAL_INPUT_PIN_ID) private DigitalStateChangeListener changeListener = event -\u0026gt; System.out.println(\u0026#34; (LISTENER #1) :: \u0026#34; + event); // setup a digital input event listener to listen for any value changes on the digital input // using a custom method with a single event parameter @OnEvent(DIGITAL_INPUT_PIN_ID) private void onDigitalInputChange(DigitalStateChangeEvent event){ System.out.println(\u0026#34; (LISTENER #2) :: \u0026#34; + event); } "},{"uri":"https://pi4j.com/tags/digital-input/","title":"Digital Input","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/digital-output/","title":"Digital Output","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/fatjar/","title":"FatJAR","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/gradle/","title":"Gradle","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/i2c/","title":"I2C","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/javac/","title":"Javac","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/javafx/","title":"JavaFX","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/jbang/","title":"JBang","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/documentation/providers/linuxfs/","title":"LinuxFS","tags":[],"description":"","content":"The current implementation of the LinuxFS plugin implements a file based I2C provider. The file based provider opens /dev/i2c-1 using a RandomAccessFile to perform I2C reads and writes.\nProviders in the LinuxFS plugin:\n linuxfs-i2c  To use the LinuxFS provider first add the proper dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-linuxfs\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; And then one can get access to the provider as follows:\nContext pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j).id(\u0026#34;TCA9534\u0026#34;).bus(1).device(0x3f).build(); try (I2C tca9534Dev = i2CProvider.create(i2cConfig)) { int config = tca9534Dev.readRegister(TCA9534_REG_ADDR_CFG); tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, currentState); tca9534Dev.writeRegister(TCA9534_REG_ADDR_CFG, (byte) 0x00); tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, newState); } pi4j.shutdown(); "},{"uri":"https://pi4j.com/tags/maven/","title":"Maven","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/library-path/","title":"Native Library Path","tags":[],"description":"","content":"Overview Some Pi4J plugins, such as the Pi4J PiGpio Provider plugin, depend on native JNI libraries to communicate with the underlying system. By default Pi4J embeds these native libraries as resources inside the plugin\u0026rsquo;s JAR file. At runtime Pi4J extracts the native library into a temporary directory so the JVM can load the library from the filesystem. Upon termination the temporary file is automatically removed.\nThis automatic extration behavior works well for most users; however, there are certain edge cases where this may fail. On failure, its common to see a UnsatisfiedLinkError on startup of your application or when you create a Pi4J context. Edge cases such as the following may require customization of the runtime to deal with native library loading.\n Systems that do not support a writable temporary directory (/tmp) may encounter the UnsatisfiedLinkError and fail to load the native library. Systems with very strict security policies may encounter the UnsatisfiedLinkError and fail to load the native library if unable to extract the resource from the JAR at runtime. Users attempting to use Pi4J under Android may also experience the UnsatisfiedLinkError and fail to load the native library.   Explicitly Define the Library Path In the event of a failure to extract and load the embedded native library from the JAR file at runtime, a user can override this default behavior by defining the system property: pi4j.library.path.\nUsage: pi4j.library.path=(system|/some/directory) Values:    Property Value Description     system The default system defined library path for the JVM (java.library.path) will be used to resolve the native libraries.   local Native libraries will be resolved in the same local directory as the plugin JAR file on the file system.   absolute file path(/some/directory) This user defined library path (absolute filesystem path) will be used to resolve the native libraries.    Examples: The pi4j.library.path system property can be assigned in the command line used to launch your Java application using the -D flag.\njava --Dpi4j.library.path=\u0026quot;system\u0026quot; ... -or- java --Dpi4j.library.path=\u0026quot;local\u0026quot; ... -or- java --Dpi4j.library.path=\u0026quot;/some/directory\u0026quot; ... The pi4j.library.path system property can be assigned in your code at startup and prior to creating a Pi4J Context.\nSystem.setProperty(\u0026quot;pi4j.library.path\u0026quot;, \u0026quot;/some/directory\u0026quot;); -or- System.setProperty(\u0026quot;pi4j.library.path\u0026quot;, \u0026quot;system\u0026quot;); -or- System.setProperty(\u0026quot;pi4j.library.path\u0026quot;, \u0026quot;local\u0026quot;);  For more details about the native library loading behavior, please see the NativeLibraryLoader.java class: https://github.com/Pi4J/pi4j-v2/blob/master/libraries/pi4j-library-pigpio/src/main/java/com/pi4j/library/pigpio/util/NativeLibraryLoader.java\n  Where To Get The Native Libraries The Pi4J native libraries can be obtained by extracting the architecture specific libpi4j-xxx.so file from the plugin JAR file\u0026rsquo;s resources.\nAdditionally, the Pi4J native libraries are published as independant artifacts in the Maven Repository: https://oss.sonatype.org/#nexus-search;quick~pi4j-library-pigpio\n"},{"uri":"https://pi4j.com/documentation/providers/pigpio/","title":"PiGpio","tags":[],"description":"","content":"The current implementation of the PiGpio exposes the GPIO functions available on the Raspberry Pi.\nProviders in the PiGpio plugin:\n pigpio-digital-input pigpio-digital-output pigpio-pwm pigpio-i2c pigpio-spi pigpio-serial  To use the PiGpio provider first add the proper dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "},{"uri":"https://pi4j.com/architecture/advanced/plugins/","title":"Plug-ins","tags":[],"description":"","content":"The goal of Pi4J V.2 is to provide a solid base with all required \u0026ldquo;minimal functionality\u0026rdquo; while at the same time, promote third-party development and extensibility, thus enabling developers to build and maintain their extensions outside of the Pi4J core projects codebase.\nThis will enable us to deliver a stable, fully tested framework as the number of features inside of Pi4J can be limited and support for specific I/O hardware can be provided with an extension for Pi4J.\nMore info about how this extensibility is achieved:\n Extensible I/O hardware PROVIDERS: things like GPIO expanders, I2C bus expanders, GertBoard, add-on hardware shields, etc. Extensible SBC platforms PLATFORMS: the core project may only support Raspberry Pi, but the platform and libraries should be written to allow a third party to create plugins for alternate hardware platforms/boards. Extensible plugins.  Plugins are extensible service modules that interact with or augment the Pi4J infrastructure. The most common plugins are I/O Providers and Platforms. Other plugin examples could be a web app to view/control the Pi4J runtime state/status, some third-party observer to the Pi4J runtime state/status,\u0026hellip;\nPlugins are implemented as Java modules using Service Provider Interfaces (SPI).\nPlugins must declare their pluggable interface in their \u0026ldquo;module-info.java\u0026rdquo; config file. Example from the Raspberry plugin:\nmodule com.pi4j.plugin.raspberrypi { requires com.pi4j; exports com.pi4j.plugin.raspberrypi; exports com.pi4j.plugin.raspberrypi.platform; exports com.pi4j.plugin.raspberrypi.provider.gpio.digital; exports com.pi4j.plugin.raspberrypi.provider.pwm; exports com.pi4j.plugin.raspberrypi.provider.serial; exports com.pi4j.plugin.raspberrypi.provider.spi; exports com.pi4j.plugin.raspberrypi.provider.i2c; provides com.pi4j.extension.Plugin with RaspberryPiPlugin; } ServiceLoader overview by Piotr Mińkowski.\n"},{"uri":"https://pi4j.com/tags/pwm/","title":"PWM","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/documentation/platforms/raspberry-pi/","title":"Raspberry Pi","tags":[],"description":"","content":"TODO\n"},{"uri":"https://pi4j.com/architecture/advanced/remote-support/","title":"Remote support","tags":[],"description":"","content":"One of the big features on the wish-list for V.2: native support for remote I/O capability. Predominantly to support the ability for a user to perform development work on their desktop/laptop and be able to run their project with remote support slaving the I/O to a daemon running on the Raspberry Pi (or other supported SBC).\nTO BE DECIDED: the V.2 codebase does support this currently by using the PiGpio daemon.\nThis may be an OK place to start for the first release, but a separate Pi4J daemon may be ideal for a long term solution to capture some of the edge cases and provide remote I/O capability no matter which underlying I/O library is being used.\n "},{"uri":"https://pi4j.com/tags/serial/","title":"Serial","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/spi/","title":"SPI","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/3rd-party/","title":"Third-Party Integration","tags":[],"description":"","content":"TODO\n"},{"uri":"https://pi4j.com/tags/visual-studio-code/","title":"Visual Studio Code","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/","title":"Welcome to Pi4J","tags":[],"description":"","content":"Welcome to Pi4J This project is intended to provide a friendly object-oriented I/O API and implementation libraries for Java Programmers to access the full I/O capabilities of the Raspberry Pi platform. This project abstracts the low-level native integration and interrupt monitoring to enable Java programmers to focus on implementing their application business logic.\nBrief History The Pi4J Project was started in 2012, the same year the Raspberry Pi was introduced as a tool to provide Java developers a simple and familiar object-oriented interface library to access the low-level I/O capabilities of the Raspberry Pi including GPIO, I2C, SPI, PWM and Serial communications.\nProject Mission/Goals The Pi4J Project\u0026rsquo;s mission is to provide a rich and powerful, yet simple to use, Java-friendly API library enabling programmatic access to the low-level hardware I/O capabilities of embedded platforms such as the Raspberry Pi.\nProject Status Summary The Pi4j project has evolved in all these years as the whole Java eco-system and Raspberry Pi systems have been evolving.\nThis resulted in two main versions.\nVersion 1 The original library which started in 2012 and got a last release in 2021. Up till version 1.3 the library targets Java 8, while version 1.4 relies on Java 11. More info is provided on \u0026ldquo;Previous versions (V.1)\u0026quot;.\nVersion 2 As of Version 2.0, Pi4J will no longer include support for peripheral devices and add-on chipsets/boards as part of the core project. A new plugin model has been introduced in version 2.0 that should help enable third-party development and support third-party add-ons which may be developed and maintained independently of the core Pi4J project.\nRead more on \u0026ldquo;What\u0026rsquo;s New (V.2)\u0026quot;.\n"}]