[{"uri":"https://pi4j.com/about/","title":"About","tags":[],"description":"","content":"Project Status/Summary Version 2.0 of Pi4J is finally starting to come together and is almost ready for some real-world BETA testing. Significant progress has been made on the general architecture and primary user-facing interfaces. Pi4J V.2 is a complete re-write and does not maintain API compatibility with previous versions. It is not intended to be a drop-in replacement for previous versions of Pi4J. Pi4J V.2 is a completely new design bringing modern conventions, development practices, extensibility support and simplified integration experience for Pi4J users.\nPi4J Version 2.0 is still considered EXPERIMENTAL at this point. While many parts of the project are working, there are still a number of areas that require further development and certain APIs are subject to change without notice. A significant portion of the code is presently undocumented and hardware integration testing is incomplete.\nIt is not recommended to use Pi4J V.2 in any production workload at this time.\n Feature/Component Status The following tables outlines some of the current (high-level) features planned for V.2 release. Please note that some of these features may get deferred and not incuded in the first release.\n   ARCHTECTURAL COMPONENTS STATUS PRIORITY     Runtime Context  In Testing  HIGH   I/O Registry  In Testing  HIGH   Platforms  Incomplete  HIGH   Providers  In Testing  HIGH   Dependency Injection  In Research  HIGH        CORE FEATURES STATUS PRIORITY     Remote I/O (via TCP)  InTesting  HIGH   Executor Service  Incomplete  HIGH   GPIO Pulse  Incomplete  HIGH   GPIO Blink  Incomplete  HIGH        I/O PLUGINS STATUS PRIORITY     PiGpio GPIO Provider Plugin  In Testing  HIGH   PiGpio SPI Provider Plugin  In Testing  HIGH   PiGpio SERIAL Provider Plugin  In Testing  HIGH   PiGpio I2C Provider Plugin  In Testing  HIGH   PiGpio PWM Provider Plugin  In Testing  HIGH        LinuxFX GPIO Provider Plugin  Incomplete  LOW   LinuxFX SPI Provider Plugin  Incomplete  LOW   LinuxFX SERIAL Provider Plugin  Incomplete  LOW   LinuxFX I2C Provider Plugin  Incomplete  LOW        WiringPi GPIO Provider Plugin  Not Started  LOW   WiringPi SPI Provider Plugin  Not Started  LOW   WiringPi I2C Provider Plugin  Not Started  LOW   WiringPi PWM Provider Plugin  Not Started  LOW        PiGpio Bitbang Serial  Not Started  LOW   PiGpio Bitbang I2C  Not Started  LOW   PiGpio Bitbang SPI  Not Started  LOW     Hardware Testing Status The table below illustrates the testing progress on the various supported platforms/models.\nAs standard OpenJDK versions are not available for the ARMv6 these are considered to be low priority.\n   PLATFORM/MODEL ARM STATUS PRIORITY     RaspberryPi - 4B ARMv8  In Testing; Preliminary Tests PASSED  HIGH         RaspberryPi - 3A+ ARMv8  Not Started  HIGH   RaspberryPi - 3B+ ARMv8  In Testing; Preliminary Tests PASSED  HIGH   RaspberryPi - 3B ARMv8  In Testing; Preliminary Tests PASSED  HIGH         RaspberryPi - ZeroW ARMv6  Not Supported  LOW   RaspberryPi - Zero ARMv6  Not Supported  LOW         RaspberryPi - 2B (v1.2) ARMv8  Not Started  MEDIUM   RaspberryPi - 2B ARMv7  Not Started  MEDIUM   RaspberryPi - 1B+ ARMv6  Not Supported  LOW   RaspberryPi - 1A+ ARMv6  Not Supported  LOW   RaspberryPi - 1B (Rev 2) ARMv8  Not Started  MEDIUM   RaspberryPi - 1B (Rev 1) ARMv7  Not Started  MEDIUM   RaspberryPi - 1A ARMv6  Not Supported  LOW         RaspberryPi - CM3+ (Compute Module) ARMv8  Not Started  HIGH   RaspberryPi - CM3 (Compute Module) ARMv8  Not Started  HIGH   RaspberryPi - CM1 (Compute Module) ARMv6  Not Supported \u0026lt;i class=\u0026ldquo;fa fa-arrow-circle-down /] LOW     "},{"uri":"https://pi4j.com/architecture/about-the-code/","title":"Project source structure","tags":[],"description":"","content":"To ensure the Pi4J V.2 project is easy to maintain, there is a clear separation between the core functions and isolated test, example and plugin projects.\nOn this page we want to give you an overview of the projects which are part of the GitHub Pi4J Project.\nPi4J V.2 Main project  github.com/Pi4J/pi4j-v2 This is the main Pi4J V.2 project providing all (basic) I/O functionalities.  Pi4J Parent POM  /pom.xml This is \u0026ldquo;the grandparent POM\u0026rdquo; and the place to build the entire project.  Pi4J Libraries  /libraries/* This folder contains (JNI native) libraries that Pi4J or Pi4J plugins may require for runtime. Libraries are not Pi4J extension, plugins, providers, platforms, etc. At this moment only a PiGpio library is included, but could be extended in the future. By isolation the native functions in libraries, the underlying I/O interface can easily be replaced later without breaking the core library.  Pi4J Libraries Parent POM  /libraries/pi4j-library/pom.xml Base library to be used when creating a new library. Contains the parent pom.xml-file for all library implementations.  Pi4J PiGPIO JNI Wrapper Library  /libraries/pi4j-library-pigpio This library is a Java library to wrap the PiGPIO API and implement the JNI layer to facilitate use of PiGPIO in Java. There is no Pi4J specific API or code in this library. This PiGPIO wrapper can be used directly without using the Pi4J-core but in that case your application highly depends on the methods of PiGPIO and will be very hard to refactor if you need to use another wrapper.  Pi4J Core Library  /pi4j-core This is the Pi4J V.2 API and core implementation of the framework and runtime. Doesn\u0026rsquo;t contain any actual I/O providers, platforms or IO/platform implementation \u0026ndash;\u0026gt; those are all provided via extensions/plugins.  Pi4J Unit/Integration Test  /pi4j-test This is intended to be a place for unit and integration tests to test the APIs and features. It only performs tests using MOCK I/O via the Mock IO Provider (plugin). It should not attempt to perform any real I/O testing.  Pi4J Plugins: the actual I/O providers, platforms and implementations  /plugins/* This folder contains any plugins for use with Pi4J such as IO providers, platforms, or extensions. Plugins must implement the Pi4J Plugin Interface (com.pi4j.extension.Plugin) and declare the implementation class using the \u0026ldquo;provides\u0026rdquo; directive in the module info class. See for an example in /plugins/pi4j-plugin-mock/src/main/java/module-info.java  Pi4J Libraries Parent POM  /plugins/pi4j-plugin/pom.xml* Base library to be used when creating a new plugin. Contains the parent pom.xml-file for all plugin implementations.  Pi4J LinuxFS Provider  /plugins/pi4j-plugin-linuxfs This plugin is intended to implement I/O Providers for Linux file system operations such as SERIAL, SPI, I2C and perhaps basic GPIO. This plugin is mostly empty at this moment. Goal is to have an I/O Provider which is totally independant of an underlying program.  Pi4J Mock Platform \u0026amp; Provider  /plugins/pi4j-plugin-mock This plugin implements both a Mock Platform and Mock I/O Providers for every I/O type supported by Pi4J. This Mock plugin is used by the unit and integration testing project.  Pi4J PiGPIO Provider  /plugins/pi4j-plugin-pigpio This plugin implements I/O Providers for every I/O type supported by the PiGPIO library. At this moment, this single plugin supports both ** local/native connectivity to PiGPIO ** remote (TCP) connectivity to PiGPIO ** TO BE DISCUSSED: Perhaps this should be separated into two plugins? Or moved to a separate \u0026ldquo;remote connectivity project\u0026rdquo;?  Pi4J RaspberryPi Platform \u0026amp; Provider  /plugins/pi4-plugin-raspberrypi This plugin is intended to implement the Provider for the Raspberry Pi models and declare the default I/O providers for each of the I/O types supported by each RPi model.  Pi4J WiringPi Provider  NOT IN THE PROJECT CODE This plugin was intended to implement I/O Providers for use with the WiringPi library, similar to the PiGPIO provider. However with the WiringPi project no longer being maintained publicly, this plugin was not implemented  Stand-alone projects Pi4J Test Harness  github.com/Pi4J/pi4j-test-harness This project contains the source code (both Java library and Arduino code) for the hardware test harness which has been created to eventually perform hardware testing at the physical layer to help speed up verification for each RPI hardware model Current state is very rough but functional. This project has been moved outside of the core project as this is only used for the validation test cycle before releasing a new version. For more info, see \u0026ldquo;Hardware testing\u0026rdquo;  Pi4J Example projects Pi4J Minimal example  github.com/Pi4J/pi4j-example-minimal Example project only showing the use of a digital input and output with minimal code but a lot of comments  Pi4J Examples  github.com/Pi4J/pi4j-examples This project contains numerous code examples to demonstrate how to use Pi4J Certain functions have examples to reach the same goal with different use types, e.g. initialization of a DigitalInput with code, properties and annotations.  Pi4J Telegraph example  github.com/Pi4J/pi4j-example-telegraph Example project demonstrated during Oracle Code One 2019  "},{"uri":"https://pi4j.com/architecture/about-the-code/download/direct-download/","title":"Direct Download","tags":[],"description":"","content":"Direct downloads are not yet available.\nPlease build the project from sources available on GitHub Or acquire the compiled artifacts from the Maven SNAPSHOT repository.\n"},{"uri":"https://pi4j.com/architecture/about-the-code/download/","title":"Download/Install","tags":[],"description":"","content":"Getting started with V.2 in the state of June 3th of 2020.\nPi4J V.2  Checkout the project pi4j-v2 Select JDK11, e.g. sdk use java 11.0.7.fx-librca In the root of pi4j-v2 run `m̀vn clean install``  [INFO] Executed tasks [INFO] ------------------------------------------------------------------------ [INFO] Reactor Summary for Pi4J :: Parent POM 2.0-SNAPSHOT: [INFO] [INFO] Pi4J :: Parent POM ................................. SUCCESS [ 0.972 s] [INFO] Pi4J :: DOCKER :: Docker Parent POM .............. SUCCESS [ 0.290 s] [INFO] Pi4J :: TESTING :: Arduino Test Harness ........... SUCCESS [ 1.832 s] [INFO] Pi4J :: LIBRARY :: Libraries Parent POM ........... SUCCESS [ 0.064 s] [INFO] Pi4J :: LIBRARY :: JNI Wrapper for PIGPIO Library . SUCCESS [ 6.615 s] [INFO] Pi4J :: LIBRARY :: Java Library (CORE) ............ SUCCESS [ 6.260 s] [INFO] Pi4J :: PLUGIN :: Plugins Parent POM ............. SUCCESS [ 0.061 s] [INFO] Pi4J :: PLUGIN :: Mock Platform \u0026amp; Providers ...... SUCCESS [ 0.683 s] [INFO] Pi4J :: PLUGIN :: PIGPIO I/O Providers ........... SUCCESS [ 2.084 s] [INFO] Pi4J :: PLUGIN :: RaspberryPi Platform \u0026amp; Providers SUCCESS [ 0.447 s] [INFO] Pi4J :: TESTING :: Unit/Integration Tests ......... SUCCESS [ 2.350 s] [INFO] Pi4J :: EXAMPLE :: Sample Code .................... SUCCESS [ 0.632 s] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ Example application Building the example application  Checkout the project Pi4J V.2 - Telegraph Demo Project Select JDK11, e.g. sdk use java 11.0.7.fx-librca In the root of pi4j-demo-telegraph run `m̀vn clean install`` Check the directory target\\distribution \u0026ndash;\u0026gt; this contains all the files to be copied to the Raspberry Pi  /target/distribution/pi4j-core-2.0-SNAPSHOT.jar /target/distribution/pi4j-demo-telegraph-1.0-SNAPSHOT.jar /target/distribution/pi4j-library-pigpio-2.0-SNAPSHOT.jar /target/distribution/pi4j-plugin-pigpio-2.0-SNAPSHOT.jar /target/distribution/pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar /target/distribution/run.sh /target/distribution/slf4j-api-2.0.0-alpha0.jar /target/distribution/slf4j-simple-2.0.0-alpha0.jar Running on the Raspberry Pi  After copying all files from target/distribution to a Raspberry Pi, start ./run.sh  "},{"uri":"https://pi4j.com/getting-started/","title":"Getting started with Pi4J","tags":[],"description":"","content":"You have a Raspberry Pi? And you want to use Java as your programming language to build performant, easy-to-maintain and powerful applications? This is the place to be!!!\nThe pages in this chapter explain you how to get started in different steps. The full documentation for the library, with more in-depth and technical info, can be found in the \u0026ldquo;Documentation\u0026rdquo; chapter.\nThis part of the site takes you through the different steps to start \u0026ldquo;from scratch\u0026rdquo;:\n Setting up the Raspberry Pi with all the tools needed Understanding the GPIO pins Java development on the Raspberry Pi with Visual Studio Code Using a Linux/Windows/Mac separate computer as developing workstation Minimal example application with an LED and button Introduction to electronics with CrowPi Adding a user interface with JavaFX Game development with FXGL and an Arcade controller  And if you still want to learn more, we have a list of additional resources.\n"},{"uri":"https://pi4j.com/about/previous-version-v1/","title":"Previous versions (V.1)","tags":[],"description":"","content":"Documentation of the 1.X versions Pi4J Version 1.4  Released 2021-03-03 Support for JDK/JRE 11 and 64-bit ARM platforms This release is the final release for the Pi4J Version 1.x codebase The Pi4J project is now prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform Changed project to Apache License, Version 2.0 Removed pi4j-device and pi4j-gpio-extension library Removed platform support for Odroid, BananaPi, BPi, NanoPi, OrangePi Various improvements and bug fixes listed here: GitHub Issues (v1.4) Not using Java-modules yet, this will be part of the V.2 Documentation website V1.4  Pi4J Version 1.3  Released 2021-01-29 Added support for Raspberry Pi 4B, 400, and Compute Module 4 Various improvements and bug fixes listed here: GitHub Issues (v1.3) Based on JDK8 Documentation website V1.3  Pi4J Version 1.2  Released 2019-02-26 Based on Java 8 Documentation website V1.2  Pi4J Version 1.1  Released 2016-07-26 Documentation webiste V1.1  Pi4J Version 1.0  Released 2015-04-18 Documentation website V1.0  "},{"uri":"https://pi4j.com/architecture/about-the-code/build-instructions/","title":"Build Instructions","tags":[],"description":"","content":"Building the Pi4J Project is simple and requires minimal effort. Pi4J is primarily built using Apache Maven and Java 11. Pi4J can be built directly on your host computer or inside a Docker container where all toolchains and dependencies are already installed, configuired and cached.\nIf you wish to build using a Docker container, please skip ahead to the Building with Docker topic.\n  Prerequsites In order to build Pi4J, the host system must have the following toolchains pre-installed.\n   Name Version URL     Java Development Kit (JDK) 11.0.7 (or newer) https://openjdk.java.net/   Apache Maven 3.6.3 (or newer) https://maven.apache.org/download.cgi     Build Environment The JAVA_HOME system environment variable must be configiured to point to the JDK installed path.\n Building with Maven To build the Pi4J project, use the following Maven comand from the parent Pi4J directory.\nmvn clean install If you prefer to skip all unit/integration testing, use the folllowing Maven command:\nmvn clean install -DskipTests  Building with Docker Alternatively, the Pi4J project can be entirely compiled inside a prebuilt Pi4J Builder Docker container. This eliminates the need/requirement to install the build toolchains and configure your system to build Pi4J. To build the Pi4J project using Docker, run the following shell script from the parent Pi4J directory.\n./build-docker.sh The project which provides these Docker images can be found on GitHub \u0026gt; Pi4J/pi4j-docker and includes an extensive README with the full info on how to build and use these images.\nExtract from the README:\nThis project contains the Dockerfiles and build scripts to create the Pi4J builder\ndocker images used for compiling/building the Pi4J projects. The Pi4J builder images include the following:\n  Pi4J Base Builder pi4j/pi4j-builder-base:latest : This is the base image used by all the other builder images. It's based on Ubuntu 18.04 with JDK 11 and Maven pre-installed. This image's entry point is a Bash shell. (https://hub.docker.com/repository/docker/pi4j/pi4j-builder-base)\n  Pi4J Native Builder pi4j/pi4j-builder-native:latest : This image is derived from pi4j/pi4j-builder-base and adds support for native cross-compilers and build tools for architectures: arm, armhf, aarch64/arm64. This image's entry point is a bash shell attempting to execute the file ./build.sh in the volume mounted under the /build path.\n  Pi4J v1.4 Builder pi4j/pi4j-builder:1.4 : This image is derived from pi4j/pi4j-builder-native and additionally includes pre-cached Maven build plugins and dependencies for Pi4J v1.4 builds. This image's entry point is a Maven shell. If not explicitly provided, the default maven build arguments will be: clean install -DskipTests -Pall-platforms. This will effectively build all Pi4J projects including the pi4j-native project containing native libraries which will be cross-compiled for RaspberryPi/ARM (32-bit \u0026amp; 64-bit) devices.\n  Pi4J v2.0 Builder pi4j/pi4j-builder:2.0 : This image is derived from pi4j/pi4j-builder-native and additionally includes pre-cached Maven build plugins and dependencies for Pi4J v2.0 builds. This image's entry point is a Maven shell. If not explicitly provided, the default maven build arguments will be: clean install -DskipTests -native. This will effectively build all Pi4J projects including the native library projects which will be cross-compiled for RaspberryPi/ARM (32-bit \u0026amp; 64-bit) devices.\n  Note: Pi4J versions prior to v1.4 are not currently tested or supported in these Docker images.\n Building Pi4J Native Libraries Pi4J V.2 also includes native libraries that will need to be compiled if you are modifying any native code. Most users will never need to compile the native libraries as these artifacts are automatically downloaded when building the Pi4J JARs from Maven repositories. One of the following commands can be used to build the Pi4J JARs and Native Libraries:\nmvn clean install -Pnative mvn clean install -Pnative,docker mvn clean install -Pnative,cross-compile  See the custom build profiles in the Custom Build Profiles section for more information about the profiles illustrated in these commands.\n Additional information about Docker Builds vs Cross-Compiler builds can be found here: https://github.com/Pi4J/pi4j-v2/issues/21#issuecomment-651976487\nTODO Create a topic here detailing Docker builds vs Cross-compiler builds.\n Custom Build Profiles The Pi4J Maven build includes a number of custom profiles that can be activated to perform various build steps.\n   Profile Description Notes     sources Package raw sources for each JAR Only needed when performing a snapshot or release build.   javadoc Compile and package JavaDoc for each JAR Only needed when performing a snapshot or release build.   native Compile any native libraries included in the build Only needed when modifying native code or performing a snapshot or release build.   docker Use docker builder containers to compile native library artifacts Only used when incuding the native profile or performing a snapshot or release build.   cross-compile Use cross-compilers on host to compile native library artifacts Only used when incuding the native profile or performing a snapshot or release build.   test-hardware Perform hardware integration testing EXPERIMENTAL   mac Use docker builder containers to compile native library artifacts (Same as docker profile) Automatically activated when running build from a MacOS host system.   windows Use docker builder containers to compile native library artifacts (Same as docker profile) Automatically activated when running build from a Windows host system.   transfer Perform SSH/SCP file transfers for each JAR to a remote Raspberry Pi Used for parallel development and testing.    You can activate a build profile using the -P{profile-name} argument in the Maven command:\nmvn clean install -Pjavadoc Release/Snapshot Builds Pi4J release and snapshot builds are reserved for the Pi4J Development Team. A release build ensures all JARs, resources, source-bundles, native libraries, and javadoc artifacts are compiled and deployed to the public Maven repositories. You can use the following command to perform all the build steps that would be performed during a release or snapshot build.\nmvn clean install -Drelease-build "},{"uri":"https://pi4j.com/documentation/","title":"Documentation","tags":[],"description":"","content":"Pi4J wants to provide the best possible solution for Java development on the Raspberry Pi for two use-cases.\n Do you want to develop an application without the need to touch the internal code of Pi4J?  In that case you\u0026rsquo;re at the right place for all the documentation you need! In this section you can find multiple examples to get you started.\n Do you want to go a few steps further and contribute to Pi4J, extend it with additional plugins or understand how it is build?  In that case you\u0026rsquo;ll find more information in the Architecture/Design section. "},{"uri":"https://pi4j.com/architecture/about-the-code/download/repository/","title":"Maven Repository","tags":[],"description":"","content":"Pi4J V.2 is not yet released or published to Maven Central.\nPlease build the project from sources available on GitHub Or acquire the compiled artifacts from this Maven SNAPSHOT repository.\n"},{"uri":"https://pi4j.com/getting-started/set-up-a-new-raspberry-pi/","title":"Set up a new Raspberry Pi","tags":[],"description":"","content":"Introduction The Raspberry Pi is a powerful machine with many use-cases. A lot of this power is based on the operating system you use. For our \u0026ldquo;Getting Started\u0026rdquo; examples we will be using the \u0026ldquo;official Raspberry Pi OS\u0026rdquo; (formerly known as \u0026ldquo;Raspbian OS\u0026rdquo;) but there is a long list of other possibilities which is listed for example on the\u0026ldquo;Awesome Raspberry Pi\u0026rdquo; list on GitHub.\nIn this article we start with a brand new Raspberry Pi board.\nStep-by-step First step: take your new Raspberry Pi out of the box of course :-)\nTake a good look at it, what you are holding in your hands is a true master piece. A wonder of technical engineering with a perfect mix of powerful yet inexpensive components.\nBut be aware! This is also some piece of sensitive electronics. It\u0026rsquo;s always a good idea to first touch the grounding pin of a power outlet to make sure your body is not electrically charged which could damage one of the components on the board.\nTODO add picture.\nMaterial list  Raspberry Pi Micro SD card, minimally 16Gb b PC (or other Raspberry Pi) with an SD card slot (maybe you will need an SD card adapter) Power supply (5V, 2 or 3A) Monitor, keyboard, mouse  SD card The SD card will hold the operating system. On the Raspberry Pi website, on the download page, you can find the Imager tool. Select the version for your computer, download and install it.\nStart the Imager and follow these steps:\n Click on \u0026ldquo;Operating System\u0026rdquo; \u0026gt; \u0026ldquo;CHOOSE OS\u0026rdquo; Select \u0026ldquo;Raspberry Pi OS (other)\u0026rdquo; Select \u0026ldquo;Raspberry Pi OS Full (32-bit)\u0026rdquo;                                           By selecting the \u0026ldquo;Full\u0026rdquo; edition, we will have an operating system which is preloaded with a load of additional tools, including \u0026ldquo;OpenJDK 11\u0026rdquo;, so will be able to take a quick start with Java development.\nPut your SD card into your computer or in an SD card reader you can connect to USB Click on \u0026ldquo;SD Card\u0026rdquo; \u0026gt; \u0026ldquo;CHOOSE SD CARD\u0026rdquo; Select the SD card  TODO add pictures\nFirst start-up Additional Raspberry Pi OS settings Check the Java version As we have put the Full edition on the SD card, Java is already available. Open a terminal window and type in java -version. Java will be started to show you the installed version.\n$ java -version openjdk version \u0026quot;11.0.9\u0026quot; 2020-10-20 OpenJDK Runtime Environment (build 11.0.9+11-post-Raspbian-1deb10u1) OpenJDK Server VM (build 11.0.9+11-post-Raspbian-1deb10u1, mixed mode) Install Pi4J TODO\nKeep your Raspberry Pi up-to-date Update to the latest version Open a terminal and perform following commands\nsudo apt update sudo apt full-upgrade Raspberry Pi OS is based on Debian - one of the largest Linux distrubutions. When running these commands regularly, you will keep your installation up to date for the particular major Raspberry Pi OS release you are using (e.g. Debian V9, aka Stretch). It will not update from one major release to another, for example, Stretch (V9) to Buster (V10).\n"},{"uri":"https://pi4j.com/about/new-in-v2/","title":"What&#39;s New (V.2)","tags":[],"description":"","content":"What\u0026rsquo;s New in 2.0? Pi4J version 2.0 brings with it many new features, and an entirely new architecture that focuses on extensibility, simplified integration and a modern Java API including the following:\n Fluent APIs/Interfaces Immutable Runtime Context Extensible Provider/Platform/Plug-in Architecture Builder-patterns for creating new I/O instances Dependency Injection via Pi4J Annotations Well-documented source code Hardware PWM Support Remote I/O Support (via TCP/IP) Java 11  In addition to the features listed above, Pi4J version 2.0 also abandons the old WiringPi pin numbering scheme in favor of the more traditional and commonly used Broadcom pin numbering scheme. This pin numbering scheme has been a source of confusion for a number of years, especially with beginners and is somewhat cumbersome to maintain as new Raspberry Pi models are introduces with differing or added GPIO pins. Moving forward, Pi4J will only use the Broadcom (BCM) pin numbering scheme.\nThe WiringPi project has now been deprecated (see wiringpi.com/wiringpi-deprecated/). Pi4J version 2.0 will no longer be based on WiringPi and has moved to using the PIGPIO library (http://abyz.me.uk/rpi/pigpio/) internally for low level integation. With this move, we will also support the remote I/O features (via TCP socket) offered by the PIGPIO daemon (http://abyz.me.uk/rpi/pigpio/pigpiod.html).\nWhat are the differences compared to V.1? Starting with the Pi4J 2.0 builds, the Pi4J project is prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform. Earlier versions of Pi4J were perhaps too ambitious in scope and that led to significant project bloat to the point that the project was becoming unsustainable. The goal moving forward is to limit scope to that of the raw I/O capabilities of the Raspberry Pi platform and provide timely updates and releases for bug fixed and new RaspberryPi model introductions. Reducing the scope of the project should better serve the Java community for basic I/O access by reducing complexity.\nThe following features have been removed from the Pi4J library:\n IO Expanders \u0026ndash; IO expansion is still supported but concrete implementations should be provided outside the core Pi4J core project such that they can be maintained and extended independently. Other Platforms \u0026ndash; Other platforms such as Odroid, BananaPi, NanoPi, OrangePi, etc. have been removed and will no longer be supported. The challenge with supporting these additional platforms is that Pi4J depends on the underlying WiringPi project and WiringPi ports for these other platforms is not well supported by the various SoC vendors or community. The various WiringPi ports for these other platforms are also inconsistent causing inconsistent features and functionality of Pi4J. Additionally, regression testing of bug fixes and new features in Pi4J is compounded with each additional supported platform. Components \u0026amp; Devices \u0026ndash; Pi4J originally provided higher level interfaces for components and devices that provided an abstraction layer between real world devices (things) and lower-level I/O interfaces. While a noble goal, unfortunately this part of the project never received the attention and time that it deserved and never gained much adoption by the community. We are removing these to allow Pi4J to focus solely on the raw I/O supported by the Raspberry Pi platform.  Sources The Pi4J V.2 source code is available in this GitHub repository: Pi4J V.2 GitHub Repository\ngit clone https://github.com/Pi4J/pi4j-v2 (Please note, this repository is only temporary, and the sources can later be moved to the main Pi4J repo. Thus, any forks from this temporary repository will be broken after the move.)\nPi4J V.2 is still considered EXPERIMENTAL at this point. While many parts of the project are working, there are still a number of areas that require further development and certain APIs are subject to change without notice. A significant portion of the code is presently undocumented and hardware integration testing is incomplete. It is not recommended to use Pi4J V.2 in any production workload at this time.\nFor a more detailed account of the project status, please see this page: About \u0026gt; Project Status.\n"},{"uri":"https://pi4j.com/getting-started/understanding-the-pins/","title":"Understanding the GPIO pins","tags":[],"description":"","content":"Connecting electronic components to the Pi is done via one or more of the pins in the so-called header. The number of pins has \u0026ldquo;grown\u0026rdquo; between the different Raspberry Pi board versions, but all recent ones have a 40-pin header. It\u0026rsquo;s of course important to be aware of the correct numbering to not correct components the wrong way.\nType of pins The pins have different uses\nPower and ground Both 5V and 3.3V are available as power pins and, of course, also ground pins. Anytime the board is powered you have a fixed power supply available for your components. You have to take into account not to connect devices that need a lot of current, otherwise the Raspberry Pi itself will not behave as expected and reboot for instance.\nDigital GPIO The other ones are \u0026ldquo;General-Purpose Input/Output\u0026rdquo; (GPIO) pins. These pins can be addressed with software to act as input or output for an application. They use 3.3V, meaning an output pin will be set to 0V (low) or 3.3V (high) and an input pin will read 0V as low and 3.3V as high.\nMost of the GPIOs have an internal pull-up or pull-down resistor which can be enabled in software.\nOverview The following image gives you an overview of the pins and types of a typical 40-pin header. Note the different numbers being used:\n PIN: 1 to 40 logical order of the pin BCM: the number to be used in your Java code to specify the GPIO to be used. BCM refers to the \u0026ldquo;Broadcom SOC channel\u0026rdquo; number, which is the numbering inside the chip which is used on the Raspberry Pi. These numbers changed between board versions as you can see in the previous tables for the 26-pin header type 1 versus 2, and or not sequential. WPI: WiringPi number which was used by V.1 of Pi4J. The WiringPi numbering has a \u0026ldquo;historical reason\u0026rdquo;. When development for the very first Raspberry Pi\u0026rsquo;s was ongoing, only 8 pin-numbers were foreseen. But, when the designs further evolved and more pins were added, the numbering in WiringPi was extended to be able to address the extra pins.  "},{"uri":"https://pi4j.com/architecture/","title":"Architecture/Design","tags":[],"description":"","content":"The code of Pi4J is based on a layered approach, visualized in the picture below.\nSince Pi4J is a low-level library, it tries to avoid inheriting third-party libraries at all costs. More complex dependency chains make it more difficult for users, especially novice users. Therefor, the only dependency Pi4J V.2 has is SLF4J to provide a standardized and extensible logging framework.\nThe dark grey blocks \u0026ldquo;Annotation Engine\u0026rdquo;, \u0026ldquo;@Register\u0026rdquo; and \u0026ldquo;@Inject\u0026rdquo; are here as a future idea but are not included in the current V2.\n"},{"uri":"https://pi4j.com/architecture/about-the-code/download/install/","title":"Installation","tags":[],"description":"","content":"This project is still in development and thus no package installers are available at this time.\n"},{"uri":"https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/","title":"Java development with VSC","tags":[],"description":"","content":"Java on the Raspberry Pi To use Pi4J V2 you\u0026rsquo;ll need Java 11 or newer. Luckily this version is included in the current version of Raspberry Pi OS. In the release notes you can see that the version of 2019-06-20 includes OpenJDK Java 11:\n2019-06-20: Based on Debian Buster Oracle Java 7 and 8 replaced with OpenJDK 11 But you will need to keep in mind this version is only compatible with ARMv7 or higher and doesn\u0026rsquo;t support all Raspberry Pi board versions. If you have a Raspberry Pi A (version 3), B (version 2 or higher), or Compute (version 3 or higher), you are good to go! For all other boards you will need some additional steps that are described on \u0026ldquo;Java for ARMv6/7/8\u0026rdquo;.\nIf you prepared a microSD card with the latest version of Raspberry Pi OS (full version), as described on \u0026ldquo;Set up a new Raspberry Pi\u0026rdquo;, you can check the installed Java version in the terminal. On a board with ARMv7 or ARMv8 you will get this result:\n$ java -version openjdk version \u0026quot;11.0.3\u0026quot; 2019-04-16 OpenJDK Runtime Environment (build 11.0.3+7-post-Raspbian-5) OpenJDK Server VM (build 11.0.3+7-post-Raspbian-5, mixed mode) If you get an error like below, you\u0026rsquo;ll need to follow the steps described on \u0026ldquo;Java for ARMv6/7/8\u0026rdquo;.\n$ java -version Error occurred during initialization of VM Server VM is only supported on ARMv7+ VFP Maven Pi4J is using Maven as build tool, this allows you to compile your code with the required modules into JAR-file thanks to the pom.xml configuration file which you can find in the root of a project. We need to install Maven and can do this with a single command, after which we can immediately check the installation by requesting the version:\n$ sudo apt install maven $ mvn -v Apache Maven 3.6.0 Maven home: /usr/share/maven Visual Studio Code Visual Studio Code (VSC) is the free IDE (Integrated Developer Environment) by Microsoft. It\u0026rsquo;s designed as a universal tool that you can use for multiple programming languages with extensions. On your Raspberry Pi open a web browser, go to the \u0026ldquo;VSC Download page (code.visualstudio.com/Download)\u0026quot; and select the \u0026ldquo;Linux .deb ARM\u0026rdquo; version.\n    Download page for VSC\n      VSC in the list of programming tools\n      VSC running on the Raspberry Pi with Maven and Java Extension Pack\n                               When the download is finished, open a terminal, go to the Download directory and install the downloaded deb-file like this:\n$ cd /home/pi/Downloads $ sudo apt install ./code_1.53.0-1612367698_armhf.deb Since 02/2021 there is even an easier way, as Visual Studio Code is now available as a Raspberry Pi OS apt package. Use the following commands:\n$ sudo apt update $ sudo apt install code -y "},{"uri":"https://pi4j.com/architecture/about-the-code/maven-settings/","title":"Maven settings","tags":[],"description":"","content":"To simplify development but not commit sensitive information, you can add personal or PC-specific settings in the Maven settings.xml file. This file is stored or needs to be created in the \u0026ldquo;.m2\u0026rdquo; directory in your home directory:\n Windows: C:\\Users\\YOUR_NAME.m2 Linux: /home/YOUR_NAME/.m2 Mac: /Users/YOUR_NAME/.m2  For more info see this article on Baeldung.\nThis is an example settings file, including settings for compiling of Pi4J and credentials to upload the generated code to a Raspberry Pi.\n\u0026lt;settings xmlns=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd\u0026quot;\u0026gt; \u0026lt;localRepository/\u0026gt; \u0026lt;interactiveMode/\u0026gt; \u0026lt;offline/\u0026gt; \u0026lt;pluginGroups/\u0026gt; \u0026lt;servers/\u0026gt; \u0026lt;mirrors/\u0026gt; \u0026lt;proxies/\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;pi4j\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- Docker compiler settings --\u0026gt; \u0026lt;pi4j.native.compiler\u0026gt;DOCKER-COMPILER\u0026lt;/pi4j.native.compiler\u0026gt; \u0026lt;!-- SSH credentials of your test Raspberry Pi --\u0026gt; \u0026lt;pi4j.dev.transfer\u0026gt;false\u0026lt;/pi4j.dev.transfer\u0026gt; \u0026lt;pi4j.dev.host\u0026gt;192.168.1.1\u0026lt;/pi4j.dev.host\u0026gt; \u0026lt;pi4j.dev.port\u0026gt;22\u0026lt;/pi4j.dev.port\u0026gt; \u0026lt;pi4j.dev.user\u0026gt;pi\u0026lt;/pi4j.dev.user\u0026gt; \u0026lt;pi4j.dev.password\u0026gt;raspberry\u0026lt;/pi4j.dev.password\u0026gt; \u0026lt;pi4j.dev.directory\u0026gt;/home/pi/pi4j-temp\u0026lt;/pi4j.dev.directory\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;activeProfiles\u0026gt; \u0026lt;activeProfile\u0026gt;pi4j\u0026lt;/activeProfile\u0026gt; \u0026lt;/activeProfiles\u0026gt; \u0026lt;/settings\u0026gt; "},{"uri":"https://pi4j.com/documentation/pin-numbering/","title":"Pin numbering","tags":[],"description":"","content":"Pi4J V.1 took a pretty opinionated approach to pin numbering as the scheme was based on the underlying WiringPi. This scheme was incompatibility with other pin diagrams and pin numbering used by other development platforms and libraries.\nAs Pi4J V.2 is build as a \u0026ldquo;pass thru library\u0026rdquo;, and uses PiGpio as the underlying framework, the more well-known BCM numbering is being used now.\nThis drawing shows the different numbers for WiringPi and BCM in a 40-pins Raspberry Pi header:\n"},{"uri":"https://pi4j.com/about/release-notes/","title":"Release Notes","tags":[],"description":"","content":"Release note are not available as this project does not yet have any releases.\n"},{"uri":"https://pi4j.com/getting-started/developing-on-a-remote-pc/","title":"Developing on a remote PC","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-maven-archetype\n Developing Java programs using a remote PC workstation Writing your Java program, compiling and running it directly on the Raspberry Pi board as shown in the previous chapter is perfectly fine, of course, but there is an alternative way to arrange your developing laboratory, using a normal desktop computer as Remote Developing Workstation (RDW).\nThis Maven Archetype will give you a tool to generate Pi4J-V2 skeleton Java projects. You can use it for your next Pi4j project and you will be able to develop your program on the remote workstation (RDW), compile them, transmit the executable code on the target Pi board and run it. You can also start a remote debugging session.\nThere are some pros. and cons. in such a developing arrangement:\n Pros:  Your RDW has much more resources like memory, disk capacity and CPU power than a Raspberry Pi, and this is true for a P4 model too. You can store all your programs in the desktop computer. You do not have to install on the Raspberry Pi the Visual Studio Code (or your preferred IDE program), the Java JDK (JRE it is enough), Maven and the other development tools. You do not need to connect the screen, the keyboard and the mouse to the Raspberry Pi You can use smaller PI models   Cons:  You can\u0026rsquo;t run Web applications (using a web container like Tomcat or similar)    Setting up Configure the RPi for Headless mode The Headless Mode configuration enables the RPi board to communicate with the RDW over SSH protocol. These are the needed steps:\n Check if the RDW is equipped with a SSH Client. If the RDW OS is Linux you already have it For Windows you can use putty, MobaXterm or you can enable the (new) OpenSsh Client porting on Windows 10 Connect both the RPi and RDW to your local network Follow this guide to configure your RPi Install the Maven tool on the RDW  You should now be able to open a SSH Terminal window on RDW and to remotely login on the RPi board.\nInstall the raspimaven-archetype  Goto the Github Pi4J Project and download the project clicking on the green Code button and selecting Download ZIP Unzip the archetype file in an empty folder, let say my-folder cd my-folder/raspimaven-archetype mvn install  Congratulation ! - Now you are ready to generate your first Project Template\nGenerate a new Project Template Let suppose you want to begin the new wonderful PI4J-V2 project my-project, to do this follow these steps:\n mkdir my-project cd my-project mvn archetype:generate -DarchetypeCatalog=local answer to the questions the archetype asks you (see below for details)  Configuring your new project Before starting the new project generation, the archetype asks some configuration data. The list of question and the replies are shown here below:\n Choose archetype: select the raspimaven-archetype from the list proposed Define value for property \u0026lsquo;groupId\u0026rsquo;: choose the Maven groupId for your project. (If don\u0026rsquo;t know what is a groupId, don\u0026rsquo;t worry, just type \u0026ldquo;com.example\u0026rdquo; for now) Define value for property \u0026lsquo;artifactId\u0026rsquo;: choose a name for the program executable your project will produce Define value for property \u0026lsquo;version\u0026rsquo;: 1.0-SNAPSHOT: type Enter to accept the default value shown, or type the initial program version, something like 1.0.0 Define value for property \u0026lsquo;package\u0026rsquo;: com.example: type Enter to accept the default value shown  The archetype now shows you a summary of the configuration parameters you have just typed in, plus the values proposed for the main-class and package parameters. If the list is ok for you, reply Y to accept, otherwise reply N to change one or more values (you will have to re-type all parameter values \u0026hellip;)\nAfter the list confirmation, the archetype generates a new maven project template for you.\nCongratulations\nYou should be able to open the new project with your preferred java IDE. The IDE should be able to recognize the project as a valid Maven project.\nExplore the new project template Feel free to explore the new project familiarizing with the folder structure. These are the most important features:\n The file README.md contains the intruction to configure the connection(s) to your RPi board(s) and the decription of the Maven commands to build your project, transfer the executable code to the target RPi, run it and also open a debugger session. The pom.xml file already includes the dependencies needed to compile your program with the JPi4J-V2 libraries. The platform folder contains an example configuration file for connecting to you RPi board. Read the README.md explanation, open the platform/raspberry.properties file (or copy it to a new file) and edit it to describe how to connect to your RPi  "},{"uri":"https://pi4j.com/architecture/about-the-code/code-styling/","title":"Code styling","tags":[],"description":"","content":"To prevent unnecessary code (tabs versus spaces, number of characters per line\u0026hellip;) we have defined an editorconfig for IntelliJ IDEA. You can find more info here about its use.\nSome tips to keep the code clean and readable:\n Short methods with a clear name Use SonarLint to get improvement tips while code Use shortcuts  CTRL+ALT+L: Reformat code CTRL+ALT+O: Optimize imports    "},{"uri":"https://pi4j.com/featured-projects/","title":"Featured Projects","tags":[],"description":"","content":" Did you use Pi4J in one of your projects? We would love to hear from you!  Please let us know by sending an e-mail to frank at pi4j.com with a brief description, URL, links and pictures of the product or project you are working on.\n   Soft real time PLC with Strolch  Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available. Conveyors for containers filled by a dispensing robot\n PiJukeBox by Daniel Mårtensson  Daniel used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators. Features: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi\u0026rsquo;s, terminal based.\n  "},{"uri":"https://pi4j.com/architecture/about-the-code/hardware-testing/","title":"Hardware testing","tags":[],"description":"","content":" This is an experimental project which will need a lot of love\u0026hellip; The new Raspberry Pi Pico with a lot of GPIOs for a very low price, seems even to be a better fit for this project compared to the Arduino Due\u0026hellip; To be further investigated!\n To minimize the required time and efforts to test a new release, V.2 aims to include an automated test which performs I/O testing on each I/O interface on each model of RPi. Ideally this would happen as part of the unit testing sequence for each code commit or at least as part of the release cycle.\nTo achieve this, an Arduino Due board with lots of on board I/O capability is being used. The firmware that gets loaded onto the Arduino board listens on the serial port for instructions on which pins to use and what type of test to perform. The \u0026ldquo;Test Harness\u0026rdquo; project also includes a Java library that is used to communicate with the Arduino and instrument tests.\nNext, a given I/O provider plugin includes test classes that instrument the test harness and perform live I/O testing between the SBC (or other hardware) and the Arduino Test Harness.\nTo be able to fully test all board types, a custom PCB needs to be created to perform all the interconnects between the Raspberry Pi 26-pin/40-pin headers, and the Arduino board. This way enough test harnesses could be build for each Raspberry Pi model and have a permanent setup for on-demand testing. This of course is a huge effort just by itself, and perhaps too ambitious \u0026ndash; but seeking a means to reach automated testing is really needed for the long term.\n"},{"uri":"https://pi4j.com/documentation/java-installation/","title":"Java for ARMv6/7/8","tags":[],"description":"","content":" Raspberry Pi OS Full comes with Java 11 pre-installed. But this version only works on board-versions with an ARMv7 or ARMv8. In some cases you will need to do some additional steps to install a Java version which works on your board.\n Board versions With ARMv6 processor  Raspberry Pi 1 A and A+ Raspberry Pi 1 B and B+ Compute Module 1 Zero 1.2, 1.3 and W  With ARMv7 or ARMv8 processor  Model A+, version 3 Model B, version 2, 3 and 4 Compute Module, version 3  How to check and install Java Check the current version If you prepared a microSD card with the latest version of Raspbian OS (full version), Java is already installed! You can check the installed Java version in the terminal. On a board with ARMv7 or ARMv8 you will get this result:\n$ java -version openjdk version \u0026quot;11.0.3\u0026quot; 2019-04-16 OpenJDK Runtime Environment (build 11.0.3+7-post-Raspbian-5) OpenJDK Server VM (build 11.0.3+7-post-Raspbian-5, mixed mode) On an ARMv6 version, you will get an error:\n$ java -version Error occurred during initialization of VM Server VM is only supported on ARMv7+ VFP Check your board version If you are not sure which type of board you have, you can check this in the terminal with cat /proc/cpuinfo, for instance for a Raspberry Pi B+ 1.2:\n$ cat /proc/cpuinfo processor\t: 0 model name\t: ARMv6-compatible processor rev 7 (v6l) BogoMIPS\t: 697.95 Features\t: half thumb fastmult vfp edsp java tls CPU implementer\t: 0x41 CPU architecture: 7 CPU variant\t: 0x0 CPU part\t: 0xb76 CPU revision\t: 7 Hardware\t: BCM2835 Revision\t: 0010 Serial\t: 000000005f9ba615 Model\t: Raspberry Pi Model B Plus Rev 1.2 Install Java 11 on ARMv6 The sources for Java are available as open-source on OpenJDK, which means, if you can\u0026rsquo;t find the correct version for a specific board, it is possible to compile it yourself. Luckily there are different suppliers providing ready-made packages of the JDK for multiple platforms. But only Azul seems to have one which is a perfect fit for Raspberry Pi\u0026rsquo;s with an ARMv6: the Zulu community edition of JDK 11.\nTo get started with Zulu JDK, download and uncompress it to your board:\n$ cd /usr/lib/jvm $ sudo wget https://cdn.azul.com/zulu-embedded/bin/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ sudo tar -xzvf zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ sudo rm zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ ls -l total 12 lrwxrwxrwx 1 root root 21 Jul 23 15:58 java-1.11.0-openjdk-armhf -\u0026gt; java-11-openjdk-armhf drwxr-xr-x 9 root root 4096 Aug 20 11:41 java-11-openjdk-armhf drwxr-xr-x 2 root root 4096 Aug 20 11:41 openjdk-11 drwxrwxr-x 10 111 122 4096 Jul 10 16:50 zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf Now we have the JDK11 ready to be used, but it still needs to be configured so the OS is aware of it.\n$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java 1 $ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac 1 At this moment we can select the new JDK to link it to the “java” and “javac” command.\n$ sudo update-alternatives --config java There are 2 choices for the alternative java (providing /usr/bin/java). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/java-11-openjdk-armhf/bin/java 1111 auto mode 1 /usr/lib/jvm/java-11-openjdk-armhf/bin/java 1111 manual mode 2 /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java 1 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 2 update-alternatives: using /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java to provide /usr/bin/java (java) in manual mode $ sudo update-alternatives --config javac There are 2 choices for the alternative javac (providing /usr/bin/javac). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/java-11-openjdk-armhf/bin/javac 1111 auto mode 1 /usr/lib/jvm/java-11-openjdk-armhf/bin/javac 1111 manual mode 2 /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac 1 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 2 update-alternatives: using /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac to provide /usr/bin/javac (javac) in manual mode Now let\u0026rsquo;s check the Java version:\n$ java -version openjdk version \u0026quot;11.0.8\u0026quot; 2020-07-14 LTS OpenJDK Runtime Environment Zulu11.41+75-CA (build 11.0.8+10-LTS) OpenJDK Client VM Zulu11.41+75-CA (build 11.0.8+10-LTS, mixed mode) OK, ready to run Java 11 applications on the Raspberry Pi with ARMv6!\nMore info If you want more info, or use JavaFX, check these blog posts:\n Installing Java and JavaFX on the Raspberry Pi (for ARMv7+) How to install and use Java 11 and JavaFX 11 on Raspberry Pi boards with ARMv6 processor  "},{"uri":"https://pi4j.com/about/license/","title":"License (Open Source)","tags":[],"description":"","content":"The Pi4J Version 2.0 project is distributed and licensed under the Apache License, Version 2.0 license (A business-friendly OSS license).\n apache.org/licenses/LICENSE-2.0 github.com/Pi4J/pi4j-v2/blob/master/LICENSE.txt   Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n  Definitions.\n\u0026ldquo;License\u0026rdquo; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n\u0026ldquo;Licensor\u0026rdquo; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n\u0026ldquo;Legal Entity\u0026rdquo; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026ldquo;control\u0026rdquo; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\u0026ldquo;You\u0026rdquo; (or \u0026ldquo;Your\u0026rdquo;) shall mean an individual or Legal Entity exercising permissions granted by this License.\n\u0026ldquo;Source\u0026rdquo; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.\n\u0026ldquo;Object\u0026rdquo; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.\n\u0026ldquo;Work\u0026rdquo; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).\n\u0026ldquo;Derivative Works\u0026rdquo; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.\n\u0026ldquo;Contribution\u0026rdquo; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026ldquo;submitted\u0026rdquo; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026ldquo;Not a Contribution.\u0026rdquo;\n\u0026ldquo;Contributor\u0026rdquo; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.\n  Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.\n  Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.\n  Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and\n(b) You must cause any modified files to carry prominent notices stating that You changed the files; and\n(c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and\n(d) If the Work includes a \u0026ldquo;NOTICE\u0026rdquo; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\nYou may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\n  Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.\n  Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.\n  Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.\n  Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.\n  Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.\n  END OF TERMS AND CONDITIONS\nAPPENDIX: How to apply the Apache License to your work.\n To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026quot;[]\u0026quot; replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026quot;printed page\u0026quot; as the copyright notice for easier identification within third-party archives.  Copyright (C) 2012 - 2019 Pi4J\nLicensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\n"},{"uri":"https://pi4j.com/getting-started/minimal-example-application/","title":"Minimal example application","tags":["Digital Input","Digital Output"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\n In the \u0026ldquo;pi4j-example-minimal\u0026rdquo; GitHub project you can find a project which contains the minimal code to control a digital input and output with Pi4J. The project is further described on this page. The application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.\n  Wiring This minimal example application uses this wiring:\nBuilding the application The main build tool used by the Pi4J project is Maven, but for this example we provided both the Maven and Gradle approach, so you can select the tool you prefer.\nMaven This project can be built with Apache Maven 3.6 (or later) and Java 11 OpenJDK (or later). These prerequisites must be installed prior to building this project as described on the previous pages. The following command can be used to download all project dependencies and compile the Java module. You can build this project directly on a Raspberry Pi with Java 11+.\nmvn clean package Gradle You can also use the Gradle Build Tool from these same sources. Use version 6.6 (or later) and Java 11 OpenJDK (or later). The Gradle wrapper is used as described on docs.gradle.org. The Gradle configuraion file build.gradle-file is included in the sources.\nOn Linux:\n./gradlew build On Windows:\ngradlew.bat build Dependency in pom.xml For the Maven approach, a pom.xml file defines all the dependencies, and the build process.\nAt this moment Pi4J V.2 is not yet released, so you\u0026rsquo;ll need to add the snapshot repository. \u0026lt;repositories\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;id\u0026gt;oss-snapshots-repo\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Sonatype OSS Maven Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;https://oss.sonatype.org/content/groups/public\u0026lt;/url\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled\u0026gt;false\u0026lt;/enabled\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; In this project we will be using slf4 for logging, pi4j-core and the pi4j-plugins for the Raspberry Pi and PiGPIO. To make the versions easy to update, we add those numbers as properties.\n\u0026lt;properties\u0026gt; \u0026lt;!-- DEPENDENCIES VERSIONS --\u0026gt; \u0026lt;slf4j.version\u0026gt;2.0.0-alpha0\u0026lt;/slf4j.version\u0026gt; \u0026lt;pi4j.version\u0026gt;2.0-SNAPSHOT\u0026lt;/pi4j.version\u0026gt; \u0026lt;/properties\u0026gt; These are the dependencies we need:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- include Pi4J Core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- include Pi4J Plugins (Platforms and I/O Providers) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-pigpio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Pi4J code blocks which are used Initialization Before you can use Pi4J you must initialize a new runtime context.\nThe \u0026lsquo;Pi4J\u0026rsquo; static class includes a few helper context creators for the most common use cases. The \u0026lsquo;newAutoContext()\u0026rsquo; method will automatically load all available Pi4J extensions found in the application\u0026rsquo;s classpath which may include \u0026lsquo;Platforms\u0026rsquo; and \u0026lsquo;I/O Providers\u0026rsquo;.\nvar pi4j = Pi4J.newAutoContext(); Output Pi4J Context information The library contains helper functions to output info about the available and used platforms and providers. To keep the example code clean, these are part of the \u0026ldquo;PrintInfo.java\u0026rdquo; class. For example to print the loaded platforms:\nPlatforms platforms = pi4j.platforms(); console.box(\u0026#34;Pi4J PLATFORMS\u0026#34;); console.println(); platforms.describe().print(System.out); console.println(); Handle the button presses To handle digital input events we first need a configuration for it. With that configuration, Pi4J can create the object for us and the state changes can be handled.\nprivate static int pressCount = 0; private static final int PIN_BUTTON = 24; // PIN 18 = BCM 24  var buttonConfig = DigitalInput.newConfigBuilder(pi4j) .id(\u0026#34;button\u0026#34;) .name(\u0026#34;Press button\u0026#34;) .address(PIN_BUTTON) .pull(PullResistance.PULL_DOWN) .debounce(3000L) .provider(\u0026#34;pigpio-digital-input\u0026#34;); var button = pi4j.create(buttonConfig); button.addListener(e -\u0026gt; { if (e.state() == DigitalState.LOW) { pressCount++; console.println(\u0026#34;Button was pressed for the \u0026#34; + pressCount + \u0026#34;th time\u0026#34;); } }); Toggle a LED For the LED we use a similar approach with a configuration. The created led-object can be used to toggle its state.\nprivate static final int PIN_LED = 22; // PIN 15 = BCM 22  var ledConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;led\u0026#34;) .name(\u0026#34;LED Flasher\u0026#34;) .address(PIN_LED) .shutdown(DigitalState.LOW) .initial(DigitalState.LOW) .provider(\u0026#34;pigpio-digital-output\u0026#34;); var led = pi4j.create(ledConfig); while (pressCount \u0026lt; 5) { if (led.equals(DigitalState.HIGH)) { led.low(); } else { led.high(); } Thread.sleep(500 / (pressCount + 1)); } Closing the application Before the application quits, we need to call the \u0026lsquo;shutdown()\u0026rsquo; function on the Pi4J static helper class. This will ensure that all I/O instances are properly shutdown, released by the the system and shutdown in the appropriate manner. Terminate will also ensure that any background threads/processes are cleanly shutdown and any used memory is returned to the system.\npi4j.shutdown(); Steps to run this application on your Raspberry Pi  Attach a LED and button as shown in the image above Use a recent Raspbian OS image which has Java 11. To check if you have the correct Java version in the terminal:  $ java -version openjdk version \u0026quot;11.0.6\u0026quot; 2020-01-14 OpenJDK Runtime Environment (build 11.0.6+10-post-Raspbian-1deb10u1) OpenJDK Server VM (build 11.0.6+10-post-Raspbian-1deb10u1, mixed mode)  Download the project from GitHub and build it:  $ git clone https://github.com/Pi4J/pi4j-example-minimal.git $ cd pi4j-example-minimal/ $ mvn clean package  Change to the distribution directory where you can find the generated package and required Java-modules. Start it with the provided run.sh script:  $ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 364456 Jun 19 10:04 pi4j-core-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 7243 Jun 19 10:04 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 142461 Jun 19 10:04 pi4j-library-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 37302 Jun 19 10:04 pi4j-plugin-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 26917 Jun 19 10:04 pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run.sh -rw-r--r-- 1 pi pi 52173 Jun 19 10:04 slf4j-api-2.0.0-alpha0.jar -rw-r--r-- 1 pi pi 15372 Jun 19 10:04 slf4j-simple-2.0.0-alpha0.jar $ sudo ./run.sh  The output will first show you some info about the platforms and providers. Then the LED starts blinking and shows how much times you pushed the button:  LED high LED low LED high Button was pressed for the 1th time LED low LED high Button was pressed for the 2th time LED low LED high LED low LED high Button was pressed for the 3th time LED low LED high LED low LED high Button was pressed for the 4th time LED low LED high LED low LED high Button was pressed for the 5th time "},{"uri":"https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/","title":"Soft real time PLC with Strolch","tags":[],"description":"","content":"Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available.\n    Conveyors for containers filled by a dispensing robot\n      eSyBox using pi4j to communicate with the Raspberry Pi\u0026#39;s I2C bus\n      eSyBox slot detection in action\n                               These are projects by the company atexxi.ch.\nA soft real time PLC written in Java running on Strolch This PLC project by Robert von Burg combines Pi4j, Strolch and the Raspberry Pi.\nIt is being used in a material flow controller which coordinates FromStock orders with a medical dispensing robot and dispenses the packets into containers. These containers are then moved by a Strolch based PLC. The containers travel on a 12m long conveyor with multiple segments and entry/exits to position the container at the dispensing robot\u0026rsquo;s exit.\nMedical cabinet with pick-by-light The most recent project are medical cabinets which use I2C to communicate with custom electronics to control the locks, perform a pick-by-light from slots and uses infrared to detect access to a slot with products in it.\n"},{"uri":"https://pi4j.com/architecture/advanced/","title":"Advanced","tags":[],"description":"","content":"Pi4J V2 tries to focus on its core functionality (the GPIO I/O) but at the same time wants to provide the possibility to extend and adapt to other hardware, underlying framework etc.\nYou can find more info on these pages about some of the current functionalities to achieve this:\n Annotated provisioning   Dependency injection   Native Library Path   Plug-ins   Remote support   Third-Party Integration   "},{"uri":"https://pi4j.com/getting-started/crowpi/","title":"Electronics with CrowPi","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-crowpi\n For this example we are going to use a CrowPi, which is a starter kit in a laptop-housing. Of course, you can get any electronics starter kit for this purpose or buy separate components. That\u0026rsquo;s the fun of electronics: components are inexpensive and easy to find on ebay or one of the many web shops.\n    CrowPi 1\n      CrowPi 2\n      Example electronics starter kit\n                               As the CrowPi contains a lot of components, this example is described on the following subpages:\n CrowPi OS   Develop with Intellij IDEA   The CrowPi sources and documentation are provided by the Swiss FHNW University based on a project in 2021 by Pascal Mathis and Tobias Siegrist under supervision of Barbara Scheuner and Dieter Holz. The original documentation (in German) is available on \u0026ldquo;CrowPi goes Java\u0026rdquo; (with sources on GitHub).\n "},{"uri":"https://pi4j.com/documentation/logging/","title":"Logging with SLF4J","tags":[],"description":"","content":"Pi4J uses SLF4J for logging. To include it in your project, add this Maven dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0-alpha0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; There are different ways to configure the logging output, as described on the SLF4J website, but the shortest is probably with this property in your main-method:\npublic static void main(String[] args) throws Exception { // Configure default lolling level, accept a log level as the first program argument  System.setProperty(\u0026#34;org.slf4j.simpleLogger.defaultLogLevel\u0026#34;, \u0026#34;INFO\u0026#34;); // Your code comes here } "},{"uri":"https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/","title":"PiJukeBox by Daniel Mårtensson","tags":[],"description":"","content":"Daniel used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators.\nFeatures: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi\u0026rsquo;s, terminal based.\nWith a Raspberry Pi B+, OpenJDK 8 and Pi4J inside this radio, it became a juke box. The sources are available on github.com/DanielMartensson/PiJukeBox\n"},{"uri":"https://pi4j.com/about/team/","title":"The Team","tags":[],"description":"","content":"          Robert Savage, Project Founder, Architect, Lead Developer. Principal Software Architect/Engineer. Consultant, technology enthusiast, entrepreneur, open source contributor, technology blogger. Founder at shadeBlue, LLC and SavageSoftware, LLC. Robert has a more than 20 year career working in the professional audio visual and home/commercial automation industry and an extensive background in developing technology solutions with a special focus on home automation and hardware/firmware/software integration. In 2012, Robert created the Pi4J project which provides Java developers an easy to use Java library enabling access to low-level I/O functionality (GPIO, I2C, SPI, Serial, etc.) of embedded systems like the Raspberry Pi. I created Pi4J to empower Java programmers to get involved with embedded platforms such as the Raspberry Pi and provide an easy to use and accessible Java-centric object-oriented library enabling control of real world (physical) \u0026ldquo;things\u0026rdquo;. Pi4J V.2 brings an entirely new and modern approach to Java I/O programming for embedded systems. I\u0026rsquo;m excited to get V.2 released and see what additional creative projects emerge.    Frank Delporte, Project organization, Developer. Java and Raspberry Pi-enthousiast, blogger on webtechie.be and author of the book \u0026ldquo;Getting Started with Java on Raspberry Pi\u0026rdquo;. Software developer at Toadi (Belgium). Lead coach CoderDojo in Ieper, Belgium. Software developer with more than 25 years of experience in video, multimedia, technical project management, digital signage and (web) programming. I\u0026rsquo;m a strong believer in the power and fun of Java on the Raspberry Pi. My goal is to make it as easy as possible to get started for new and experienced Java developers who want to start there first hardware experiment. That was the reason I wrote a book about this subject and share my experiments on my blog and GitHub. Pi4J V.2 brings a lot of improvements to an already great project, and - just one example - the use of the BCM pin numbers will make it even a lot easier to use the GPIO\u0026rsquo;s. That\u0026rsquo;s why I join this great team to assist in delivering this V.2 and extend it further so we can bring even more Java to the Raspberry Pi.    Robert von Burg aka \u0026ldquo;Eitch\u0026rdquo;, Developer. As lead developer for strolch.li we use Raspberry Pi as our platform to connect with products, and to implement a PLC in Java. The Pi4J project allows us to encapsulate the low level aspects of communicating with the hardware, and stay in our preferred choice. The strolch.li/plc.html project allows us to also stay in the same DSL for writing server applications, as well as communicating with low level devices. Since I love open source projects, it felt natural to me to start investing time in the Pi4J projects to assist in the further development.    "},{"uri":"https://pi4j.com/getting-started/crowpi/crowpi-os/","title":"CrowPi OS","tags":[],"description":"","content":"You can start experimenting with the default Raspberry Pi OS, but to make things easier a prepackaged OS is available with additional tools. Follow these steps to get started quickly with this CrowPi OS.\nInstall the Raspberry Pi Imager The official Imager Tool can be downloaded directly from the Raspberry Pi website. This simple tool works on all common operating systems and can be installed very easily with just a few keystrokes. More detailed instructions for installation are also available on the homepage of the Raspberry Pi website or here on \u0026ldquo;Set up a new Raspberry Pi\u0026rdquo;.\nDownload the CrowPi Image The image for the CrowPi OS which contains the operating system for the Raspberry PI can be obtained directly from the Github repository of the CrowPi example project. The latest release of the operating system can be found under this link: Download CrowPi Image.\n   GitHub Download CrowPi OS Image\n    The image can then be downloaded from GitHub here: GitHub Download CrowPi Image\nAfter the download, unzip the .zip archive. Everything is now ready for the next step!\nWriting the image to an SD card When the image is written to the SD card, all data that is still on it will be overwritten!\n First, the SD card must be available as a drive on the computer. There are different possibilities for this. Card readers are just as suitable as USB adapters. The Raspberry Pi Imager tool is now started. First, the operating system must be selected. Press the button \u0026ldquo;Choose OS\u0026rdquo;.\n   Choose OS in Imager Tool\n    At the bottom of the list, select \u0026ldquo;Use custom\u0026rdquo;. In the selection dialog, select the previously downloaded and unzipped crowpi.img.\n   Use custom in Imager Tool\n    The second step is to select the SD card. To do this, press the button \u0026ldquo;Choose storage\u0026rdquo;. It automatically shows you only the available removable media such as USB sticks or SD cards. It is now very important to select the correct entry in order to avoid unwanted data loss. On Windows, the drive letter that is actually affected is shown under the data carrier, so that this can be easily checked in Explorer. In case of doubt, however, simply unplug the data carrier with important media beforehand so that nothing can happen.\n    TODO picture select SD card\nEverything is ready to write the image to the SD card. The process can be started by pressing the \u0026ldquo;Write\u0026rdquo; button. Another confirmation dialog follows before the SD card is finally overwritten. Writing the image to the SD card can take a few minutes which is completely normal. As soon as the process is completed, a message appears. The SD card can now be removed from the computer.\nInsert the SD card into the Raspberry Pi To insert the prepared SD card into the CrowPi, the 4 retaining screws may have to be loosened. These can be found here:\n    Raspberry Pi in the CrowPi with marked screws\n    After loosening the screws, the Raspberry Pi can be lifted. At most, a few cables must be unplugged. The SD card slot can now be found on the underside. Here the SD card with the contact surfaces can be inserted in the Raspberry Pi. The slot is marked again in the picture below. As soon as the SD card is inserted, the Raspberry Pi can be correctly installed in the CrowPi and any cables that may have been disconnected can be plugged in again. As soon as everything is back in its place, the CrowPi can be connected to the power.\n   Raspberry Pi SD card slot\n    Before the CrowPi is put into operation, it should be checked again whether all 3 cables are connected to the Raspberry Pi. The HDMI adapter on the left, the USB cable on the lower side and the GPIO ribbon cable on the right should be connected. These mandatory cables are framed with red circles in the next graphic. Optionally, a keyboard and mouse can be connected via USB, which is marked with a pink circle below:\n   Raspberry Pi cables\n    Establish the network connection Only the network connection of the freshly started Raspberry Pi still has to be made manually. Otherwise, all settings are already optimally contained in the FHNW CrowPi image. Now there are a few options for the network connection:\n Connection via WLAN Connection via Ethernet cable (DHCP) Connection via Ethernet cable directly to the computer  The easiest way to make the settings is to use the mouse and keyboard connected to the Raspberry Pi. Setting up via WLAN is explicitly recommended, as it can be used in almost any environment and works great with the hotspot function on your own smartphone even when you are out and about.\nIn the following, only the connection via WLAN is described, however, if there is expertise in this area, a connection via cable can also be established.\nEstablishing a WLAN connection To connect via wireless network, the two arrows on the desktop of the CrowPi must be pressed on the top right, after which you can select the desired network. Then enter the corresponding password in the dialog for secure connections. A few seconds after the connection, the CrowPi\u0026rsquo;s background image will automatically update and display the assigned IP address. An Ethernet address is also visible on the images. This means that at the moment of the recording there was also an Ethernet cable connected to the Raspberry Pi. Now that we have a network connection to the CrowPi, we are ready to set up the development environment as the next step.\n    CrowPi OS select WLAN\n      CrowPi OS WLAN password\n      CrowPi OS background with IP addresses\n                               "},{"uri":"https://pi4j.com/getting-started/crowpi/develop-with-intellij/","title":"Develop with Intellij IDEA","tags":[],"description":"","content":"In this tutorial, IntelliJ IDEA is used for the development. The articles, instructions and pictures are created accordingly. IntelliJ IDEA is from available Jetbrains in different versions. The community version has enough functionality for development with the CrowPi and is available for Windows, MacOS and Linux, but NOT for Raspberry Pi. The download can be found here.\nThe subsequent setup of IntelliJ IDEA is identical on all platforms.\nClone the repository As soon as we have installed the development environment, it is time to clone the entry-level project for the CrowPi. The source code can be found on GitHub. In order to clone the repository, the corresponding link must be copied on GitHub and then imported into IntelliJ IDEA. Now step-by-step in pictures a more detailed instruction.\nVisit CrowPi on GitHub and copy the link to clone as described in the picture.\n    CrowPi source link\n                               Import the project In the start window of IntelliJ is the option Get from VCS available. This must be selected so that the code can be cloned directly from GitHub. Then you can simply paste the link that was previously copied from GitHub. By confirming with Clone the process is started and any necessary authentication of the user is carried out. Simply follow the instructions of the tool.\n   Import from VCS\n      Insert import from VCS link\n    As soon as the project has been completely cloned on the local computer, the project opens automatically in the development environment. A small dialog pops up at the bottom right. This must be confirmed so that the repository can be properly initialized. Maven is a software project management tool, more information can be found in the Apache Maven Project. Basically, however, nothing needs to be changed. The CrowPi project already offers a complete setup and is easy to use.\n   Import Maven Project\n    Importing the Maven project triggers a security warning at IntelliJ. Click on \u0026ldquo;Trust project\u0026rdquo; to confirmed when you downloaded the soruces from the official Pi4J CrowPi repository.\n   Trust Project confirmation\n    Now a last import step. To be able to better research errors or understand how the code of the dependencies works, the \u0026ldquo;Maven Sources and Documentation\u0026rdquo; must be downloaded. This can be done with a few clicks. Open the Maven project menu on the far right. Click on \u0026ldquo;Download Sources and/or Documentation\u0026rdquo;. Then in the context menu \u0026ldquo;Download Sources and Documentation\u0026rdquo;. Now all used libraries are locally available and visible.\n   Download Dependencies and Sources\n    Now only the start configuration of the project is missing, which is described in the next section.\nSetting the run configuration The CrowPi project uses 3 run configurations. These define which parts of the code are executed and how. However, there is no need to worry, because most of it is already predefined and all you have to do is enter the IP address of your Raspberry Pi to push and run the code from your PC to the Pi. The following configurations are used:\n crowpi-examples [install] crowpi-examples [debug] Remote Debug  With \u0026ldquo;crowpi-examples [install]\u0026rdquo; the current code is copied to the Raspberry Pi. This works via a combination of SSH/SCP. The copied code is then started on the Raspberry Pi. \u0026ldquo;crowpi-examples [debug]\u0026rdquo; does the same, but other options are selected during the connection, and a debugger is waiting until the application is actually executed. \u0026ldquo;Remote Debug\u0026rdquo; provides exactly this debugger. This connects to the Raspberry Pi and troubleshooting can begin.\nTo make everything work smoothly, the IP address of the Raspberry Pi must first be configured. To do this, click here and select \u0026ldquo;Edit Configurations\u0026rdquo;. As explained before, the IP address of the Raspberry Pi is displayed on the background image of CrowPi.\n   Select configuration menu\n    The dialog for setting the configurations now opens. A little hint: wherever the IP address of the Raspberry Pi is required, there is already a placeholder \u0026ldquo;Add CrowPi IP here\u0026rdquo;.\n   The three configurations\n    First we configure \u0026ldquo;crowpi-examples [debug]\u0026rdquo;. For this, as in the picture, go to the tab \u0026ldquo;Runner\u0026rdquo; open and double click on \u0026ldquo;Add CrowPi IP here\u0026rdquo;. The dialog window to provide the IP address opens. Confirm with \u0026ldquo;OK\u0026rdquo; and press \u0026ldquo;Apply\u0026rdquo; to save.\n   Settings debug\n    Now we can configure \u0026ldquo;crowpi-examples [install]\u0026rdquo;. This works exactly the same as \u0026ldquo;crowpi-examples [debug]\u0026rdquo;. The same setting is required. Again use \u0026ldquo;Apply\u0026rdquo; to save.\n   Settings Install\n    Now the last configuration for \u0026ldquo;Remote Debug\u0026rdquo;. The menu is a bit different here. However, it is easier to use than the previous ones. Add the IP Address in the \u0026ldquo;Host\u0026rdquo; field. With \u0026ldquo;OK\u0026rdquo; the setting is finished.\n   Remote Debug Settings\n    First test run Everything is set up to start the CrowPi project for the first time directly from the development environment. Select the run configuration \u0026ldquo;crowpi-examples [install]\u0026rdquo;. Then start the application by pressing the green play button.\n   Start the application\n    It immediately opens that Run Fensterby IntelliJ. It takes a moment and some text is displayed on the command line. After a few seconds the output stops and it looks like this:\n   Run Output in IntelliJ\n    A number can now be typed in here according to the instruction and with Enterbeeing confirmed. The corresponding sample application is then executed. If there are still error messages in the command line, it is worth checking the network connection of the computer and the Raspberry Pi again. There are also some tips and tricks for troubleshooting in the troubleshooting section of this tutorial.\n"},{"uri":"https://pi4j.com/documentation/create-context/","title":"Creating a Pi4J Context","tags":[],"description":"","content":"The context is an immutable runtime object that holds the configured state and manages the lifecycle of a Pi4J instance. It includes all loaded plugins, providers, platforms, I/O instance registry, environmental configuration and runtime objects including executor thread pools, I/O event listeners, etc.\nTerminating/destroying the context stops and releases all resources, threads, listeners, and provisioned I/O instances held by the context.\nVersion 1 was implemented using a static singleton, while version 2 uses a \u0026ldquo;Context\u0026rdquo; to avoid static singletons.\nA Pi4J Context can be created automatically (accepting all default context configurations) or manually (builder) allowing users to customize the context configuration.\nAutomatic An auto context includes AUTO-DETECT BINDINGS enabled which will load all detected Pi4J extension libraries (Platforms and Providers) in the class path.\nvar pi4j = Pi4J.newAutoContext(); Builder If you need more flexibility are specific use-cases, the builder can be used to define all the parameters of the context, for example when you want to use your own providers, use mocked instances for testing\u0026hellip;:\nContext pi4j = Pi4J.newContextBuilder() .add(new MockPlatform()) .add(MockAnalogInputProvider.newInstance(), MockAnalogOutputProvider.newInstance(), MockSpiProvider.newInstance(), MockPwmProvider.newInstance(), MockSerialProvider.newInstance(), MockI2CProvider.newInstance(), MockDigitalInputProvider.newInstance(), MockDigitalOutputProvider.newInstance()) .add(new MyCustomADCProvider(/* implements AnalogInputProvider, id=\u0026#34;my-adc-prov\u0026#34; */)) .add(new MyCustomSPIProvider(/* implements SpiProvider, id=\u0026#34;my-spi-prov\u0026#34; */)) .build(); "},{"uri":"https://pi4j.com/getting-started/user-interface-with-javafx/","title":"User interface with JavaFX","tags":["Digital Input","Digital Output","JavaFX"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-javafx\n JavaFX is a framework to create user interfaces for desktop (Windows, Mac, Linux) and mobile phones. JavaFX is an opensource project which is documented on openjfx.io and the sources are available in this GitHub project.\nThe main goal of Java has always been to be able to create applications which are \u0026ldquo;write once, run everywhere\u0026rdquo;. JavaFX promises the same for Graphical User Interface applications.\nGluon is the main maintainer of the OpenJFX project and offers commercial support to companies who want to use JavaFX in critical applications. They also provide tools to build and compile Java code to native applications for all platforms.\nDeveloping a JavaFX application The best part of Java is the \u0026ldquo;Write Once, Run Everywhere\u0026rdquo;. This means you can develop your application on any PC (Windows, Mac, Linux) and run it on any other one of these (yes even on mobile) with the exact same look-and-feel and behavior. The only limitation is the part you develop specifically for the Raspberry Pi: controlling the GPIOs with Pi4J.\nThe most used IDE for Java development is IntelliJ IDEA, which is not available for Raspberry Pi. If you are using it on your PC and want to learn more about the best approach to get started with JavaFX, read this great tutorial \u0026ldquo;Beginning JavaFX Applications with IntelliJ IDEA\u0026rdquo; by Carl Dea.\nJavaFX on Raspberry Pi JavaFX is also an ideal framework to build Java applications with a user interface for the Raspberry Pi!\nYou can find a runtime version dedicated to the Raspberry Pi on the Gluon download page. Let\u0026rsquo;s install it on our board, so we can start Java+JavaFX applications which make best use of the capabilities of the Raspberry Pi.\nInstallation To get the latest version on your Raspberry Pi, first check the Gluon download page for the download link.\nCopy the link and use it with wget to download the file:\n Download the file  $ wget -O openjfx.zip https://gluonhq.com/download/javafx-17-ea-sdk-linux-arm32/ Unzip the file  $ unzip openjfx.zip Move the unzipped directory to the opt-directory (optionally, but it\u0026rsquo;s a logical place)  $ sudo mv javafx-sdk-17/ /opt/javafx-sdk-17/ Start an application Now the OpenJFX-runtime is available on our Raspberry Pi, we can start each Java application which was compiled to a JAR with some additional parameters to run it with the best rendering support.\nThe additional arguments are needed to link to the downloaded JavaFX library and select the correct Monocle platform.\njava \\ -Dglass.platform=gtk \\ -Djava.library.path=/opt/javafx-sdk-17/lib \\ -Dmonocle.platform.traceConfig=false \\ -Dprism.verbose=false \\ -Djavafx.verbose=false \\ --module-path .:/opt/javafx-sdk-17/lib \\ --add-modules javafx.controls \\ --module {YOUR_MAIN_CLASS} $@ TODO: describe each of the startup arguments, here or in a sub page.\nMinimal example application Sources In this repository https://github.com/Pi4J/pi4j-example-javafx, a minimal example project is provided which combines Java, JavaFX, Pi4J and a few buttons. The wiring for this example is identical to the Minimal example application with a single LED and button.\n    JavaFX UI after start-up\n      JavaFX UI after click on physical button\n      LED turned on by clicking on the JavaFX button\n                               Steps to test the application  Download the sources to your Raspberry Pi  $ git clone https://github.com/pi4j/pi4j-example-javafx Move to the downloaded directory  $ cd pi4j-example-javafx Build the project  $ mvn package Move to the target \u0026gt; distribution directory  $ cd target/distribution Run the application with the provided run-script  $ sudo ./run.sh "},{"uri":"https://pi4j.com/documentation/platforms/","title":"Choosing a Platform","tags":[],"description":"","content":"Platforms are extensible service modules responsible for defining a set of default I/O providers and specific hardware capabilities for an embedded hardware system where Pi4J is deployed/running.\nTechnically speaking \u0026hellip; multiple platforms could be loaded into the runtime context, but only one will be considered the default platform for most I/O provisioning and operations. An example of this could be both a RaspberryPi Platform and Mock Platform are detected as plugins and loaded into the context, but only one will be determined at runtime to be the default platform used by the context.\nSome priority scheme will need to be implemented and invoked at runtime to resolve which is the best \u0026ldquo;platform\u0026rdquo; to accept as the default platform at runtime (on start up).\n The idea here is that a user could have multiple platform plugins in their directory but only one, theoretically the best suited, will be determined and used at runtime based on the runtime environment which makes it possible to develop, run and test on e.g. Windows with the MockPlatform and when finished run on the Raspberry Pi with the same generated jar\u0026rsquo;s which use the RaspberryPiPlatform.\nCurrent supported platforms:\n Raspberry Pi  "},{"uri":"https://pi4j.com/getting-started/game-development-with-fxgl/","title":"Game development with FXGL","tags":["JavaFX"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl\n As described on the previous page you can use JavaFX to build user interfaces which behave exactly the same on your PC and Raspberry Pi. Let\u0026rsquo;s go a step further and make a game with an \u0026ldquo;Arcade\u0026rdquo; controller.\nFor this project, we will be using FXGL, an opensource library on top of JavaFX to build games.\nThe controller This project uses an Arcade kit in combination with a Picade X HAT USB-C to easily connect the wires of the buttons and joystick.\nConnect the USB power to the hat instead of your Raspberry Pi, and use the power button on the hat to start your Raspberry Pi.\n    Arcade kit components\n      Picade Hat\n      Assembled Picade Hat and Arcade kit\n      Connected wires on Picade Hat\n      Picade Hat pin numbers\n                               Pimoroni provides a GitHub project with software to use this hat with RetroPie, but this project aims to take full control of the hardware with Java.\nThe GPIO numbers are defined by the hat and can be found on pinout.xyz\nThe application TODO, currently only minimal implementation is done based on Snake game created by Almas and Frank\n"},{"uri":"https://pi4j.com/documentation/providers/","title":"Choosing an I/O Provider","tags":[],"description":"","content":"Providers are extensible service modules responsible for the concrete implementation of a specific I/O type. Multiple providers for the same I/O type can be loaded into a Pi4J context concurrently. For example a \u0026ldquo;RaspberryPi-DigitalInputProvider\u0026rdquo; and \u0026ldquo;GertBoard-DigitalInputProvider\u0026rdquo; could both be loaded and both providing digital inputs at the same time.\nThe providers also allow to seperate the internal logic of the Pi4J core from the concrete implementation of the board on which they are used.\nCurrent supported providers:\n PiGpio  Possible future providers:\n LinuxFileSystemProvider: e.g. to use native Linux serial interfaces RemoteProvider to control the I/O from a remote device e.g. through websockets  "},{"uri":"https://pi4j.com/documentation/build-io/","title":"Building an I/O Instance","tags":[],"description":"","content":"TODO\n"},{"uri":"https://pi4j.com/getting-started/learn-more/","title":"Learn more...","tags":[],"description":"","content":"Pi4J is used in a lot of projects, and you can find a lot of examples online. On this page we want to keep an up-to-date list. Do you want to add something? Please hit \u0026ldquo;Edit this page\u0026rdquo; on the top and create a pull request!\nTwitter Please share your personal or professional projects where you combine Java and the Raspberry Pi on Twitter with the hashtag #JavaOnRaspberryPi.\nOnline articles  Foojay.io is a place for friends of OpenJDK, providing articles, updated analyses, selected highlights, and categorized lists on all things Java. There is also a category of posts dedicated to Java on the Raspberry Pi..  Books Getting Started with Java on the Raspberry Pi This book by Frank Delporte includes a lot of info and history about Java itself and how to install it on the Raspberry Pi. Also, a lot of tips and tricks to become or be a better developer. And above all many simple examples on these and even more other topics:\n The magic of Bits and Bytes and solving the confusion of Java signed values with the help of a led number display. Beautiful user interfaces made with JavaFX so you can interact with the hardware. Pi4J applications to be able to control different types of hardware like LEDs, buttons, displays, led strips, relay boards, and many more. Spring applications to interact with your Pi via web interfaces. How to set up a queue to send and receive messages to and from Arduino boards or other Pi’s. Interviews with Karen Mouws (STEM and diversity), Trisha Gee (IntelliJ IDEA), Xiaokai He (Visual Studio Code), Alexander Belokrylov (BellSoft Liberica JDK), Jakob Jenkov (Java and tutorials.jenkov.com), Johan Vos (OpenJFX, JavaFX and GluonHQ), Gerrit Grunwald (Java, JavaFX, TilesFX), Mark Heckler (Spring), Vlad Mihalcea (JPA, Hibernate)  The ebook is available on Leanpub and the paper book on Elektor.\n"},{"uri":"https://pi4j.com/documentation/io-events/","title":"Listening for I/O Events","tags":[],"description":"","content":"TODO\n"},{"uri":"https://pi4j.com/documentation/io-examples/","title":"I/O Examples","tags":[],"description":"","content":"Here you can find detailed examples for the different functionalities of Pi4J per I/O type.\n Digital Output (GPIO)   Digital Input (GPIO)   Pulse Width Modulation (PWM)   Inter-Integrated Circuit (I²C)   Serial Peripheral Interface (SPI)   Serial (UART/RS232)   The supported low-level I/O interface types are defined in the core library as an enumerated list.\nANALOG_INPUT(AnalogInputProvider.class, AnalogInput.class, AnalogInputConfig.class, AnalogInputConfigBuilder.class), ANALOG_OUTPUT(AnalogOutputProvider.class, AnalogOutput.class, AnalogOutputConfig.class, AnalogOutputConfigBuilder.class), DIGITAL_INPUT(DigitalInputProvider.class, DigitalInput.class, DigitalInputConfig.class, DigitalInputConfigBuilder.class), DIGITAL_OUTPUT(DigitalOutputProvider.class, DigitalOutput.class, DigitalOutputConfig.class, DigitalOutputConfigBuilder.class), PWM(PwmProvider.class, Pwm.class, PwmConfig.class, PwmConfigBuilder.class), I2C(I2CProvider.class, com.pi4j.io.i2c.I2C.class, I2CConfig.class, I2CConfigBuilder.class), SPI(SpiProvider.class, Spi.class, I2CConfig.class, I2CConfigBuilder.class), SERIAL(SerialProvider.class, Serial.class, SerialConfig.class, SerialConfigBuilder.class); "},{"uri":"https://pi4j.com/documentation/device-examples/","title":"Devices examples","tags":[],"description":"","content":"The core Pi4J V.2 library doesn\u0026rsquo;t contain any specific support for devices like buttons, motors, LCD\u0026hellip; This was part of V.1 but made it much more difficult to maintain and fully test the library.\nOn this page we want to keep a list of projects which contain implementation code for specific devices using the Pi4J V.2 core library. Please let us know through the forum if you want to have your project added to this list.\nCurrent available device support projects    Device(s) Developed by Link     MCP230008, MCP23017, TCA9548 Thomas Aarts github.com/Pi4J/pi4j-device-tca9548    "},{"uri":"https://pi4j.com/documentation/registry/","title":"I/O Registry","tags":[],"description":"","content":"An additional V.2 feature is an I/O registry where all I/O instances that have been created can be maintained, managed, re-accessed, etc. As the library keeps track of all the created I/O instances, they become publicly accessible through a registry where users can interrogate, iterate, identify and access all created I/O instances that Pi4J is managing.\nThis is very useful for add-ons/plugins that want to provide runtime information about the state of all I/O, for example a web app illustrating the current state of I/O.\nThe registry is responsible for managing I/O instance lifecycles and provides a means for your program to easily access any I/O instance using its unique identifier.\n"},{"uri":"https://pi4j.com/documentation/shutdown/","title":"Shutting down the Pi4J Context","tags":[],"description":"","content":"At the end of our application, the context needs to be shutdown to release the I/O and clean up the used resources.\n# Start of program var pi4j = Pi4J.newAutoContext(); # YOUR CODE GOES HERE # End of program pi4j.shutdown(); "},{"uri":"https://pi4j.com/documentation/io-examples/digital-output/","title":"Digital Output (GPIO)","tags":["Digital Output"],"description":"","content":"// Initialize Pi4J with an auto context // An auto context includes AUTO-DETECT BINDINGS enabled // which will load all detected Pi4J extension libraries // (Platforms and Providers) in the class path var pi4j = Pi4J.newAutoContext(); // create a digital output instance using the default digital output provider var output = pi4j.dout().create(DIGITAL_OUTPUT_PIN); output.config().shutdownState(DigitalState.HIGH); // setup a digital output listener to listen for any state changes on the digital output output.addListener(System.out::println); // lets invoke some changes on the digital output output.state(DigitalState.HIGH) .state(DigitalState.LOW) .state(DigitalState.HIGH) .state(DigitalState.LOW); // lets toggle the digital output state a few times output.toggle() .toggle() .toggle(); // another friendly method of setting output state output.high() .low(); // lets read the digital output state System.out.print(\u0026quot;CURRENT DIGITAL OUTPUT [\u0026quot; + output + \u0026quot;] STATE IS [\u0026quot;); System.out.println(output.state() + \u0026quot;]\u0026quot;); // pulse to HIGH state for 3 seconds System.out.println(\u0026quot;PULSING OUTPUT STATE TO HIGH FOR 3 SECONDS\u0026quot;); output.pulse(3, TimeUnit.SECONDS, DigitalState.HIGH); System.out.println(\u0026quot;PULSING OUTPUT STATE COMPLETE\u0026quot;); // shutdown Pi4J pi4j.shutdown(); "},{"uri":"https://pi4j.com/documentation/io-examples/digital-input/","title":"Digital Input (GPIO)","tags":["Digital Input"],"description":"","content":"V.2 provides a declarative style of configuration for I/O provisioning instead of the hard-coded approach offered in V1.\nExamples of the various methods and approaches which can be used to provision the I/O needs are available in the examples project.\nProperties properties = new Properties(); properties.put(\u0026quot;id\u0026quot;, \u0026quot;my_digital_input\u0026quot;); properties.put(\u0026quot;address\u0026quot;, DIGITAL_INPUT_PIN); properties.put(\u0026quot;pull\u0026quot;, \u0026quot;UP\u0026quot;); properties.put(\u0026quot;name\u0026quot;, \u0026quot;MY-DIGITAL-INPUT\u0026quot;); var config = DigitalInput.newConfigBuilder(pi4j) .load(properties) .build(); var input = pi4j.din().create(config); "},{"uri":"https://pi4j.com/documentation/io-examples/pwm/","title":"Pulse Width Modulation (PWM)","tags":["PWM"],"description":"","content":"What is it? The abbreviation PWM stands for \u0026ldquo;Pulse Width Modulation\u0026rdquo; and is also often referred to in German as pulse width modulation or pulse width modulation. This technology is used, among other things, to control servomotors and is also used, for example, for the fans of a regular computer.\nWith PWM, it is possible to control a component such as a motor no longer purely binary, i.e. off (0% power) or on (100% power), but to control them almost at will. The functionality of PWM works in such a way that the component is switched off and on again and again within a certain period of time.\nSoftware vs. Hardware Two different types of PWM are available on the Raspberry Pi, specifically a software and a hardware implementation. Both basically offer the same options, but the software version cannot achieve precise or particularly fast frequencies.\nThe reason for this is that in the software implementation for each individual cycle (on / off) a new control command must be transmitted from the JVM (Java Virtual Machine) to the corresponding component, while in the hardware implementation of the Raspberry Pi notices the desired frequency and regulates it independently directly on the board.\nThe Raspberry Pi supports 2 hardware based PWM channels. You can access these two channels via 2 separate sets of 4 GPIO header pins, but still limited to only 2 channels (2 unique PWM timing configurations).\nThe same PWM channel is available on multiple GPIO. The latest frequency and dutycycle setting will be used by all GPIO which share a PWM channel. The GPIO must be one of the following: 12 PWM channel 0 All models but A and B 13 PWM channel 1 All models but A and B 18 PWM channel 0 All models 19 PWM channel 1 All models but A and B 40 PWM channel 0 Compute module only 41 PWM channel 1 Compute module only 45 PWM channel 1 Compute module only 52 PWM channel 0 Compute module only 53 PWM channel 1 Compute module only As Pi4J is using PiGPIO \u0026ldquo;under the hood\u0026rdquo;, you can take advantage of the additional PWM functionalities of it. PiGPIO is providing additional (soft) PWM support to any of the GPIO pins (0-31) and its using some hardware timing technique to optimize performance \u0026mdash; but its not the same as the actual hardware PWM pins natively on the RaspberryPi. In the Pi4J API, we call this \u0026ldquo;Software\u0026rdquo; PWM and you would need to set .pwmType(PwmType.SOFTWARE). We consider this software-based PWM because its being provided at a software layer, in this case by the PIGPIO library.\nIf you need more than 2 PWM pins, use the software PWM functionality, it may be perfectly fine for your application. If they are not good enough, then you will probably need a PWM expander board/chip (controlled by I2C/SPI) to provide additional PWM support.\nTechnical implementation For the technical control of a component with PWM, two values must be defined:\n Pulse-pause ratio (English: Duty Cycle): This value defines the ratio between the switched-on and switched-off status and is represented by a number between 0% and 100%. A value of 50% means that within one cycle the component is switched on exactly half the time and then switched off. A value of 25%, on the other hand, would mean that the component is switched on only a quarter of the time and the component remains switched off for the remaining three quarters of the cycle. Frequency: This value defines how often per second a cycle (on / off) takes place for this component and is usually specified in the unit Hertz (Hz). With a value of 10Hz, the component would alternate 10 times between being switched on and switched off in one second.  These two values can be controlled via the Pi4J library and are also used internally by this project.\nAdditional Information  Wikipedia on PWM Wikipedia with audio frequencies  "},{"uri":"https://pi4j.com/documentation/io-examples/i2c/","title":"Inter-Integrated Circuit (I²C)","tags":["I2C"],"description":"","content":"What is it? I²C (spoken as I-Squared-C) is a bus originally invented by Philips. It is designed as a classic master-slave bus. A data transfer is always i nitiated by a master. It can also be set up in a multi-master system. I²C is connected via two signal lines (data line and clock line). The transmission rate of the bus can be between 0.1 Mbit/s up to 3.4 Mbit/s depending on the clock rate. If only a unidirectional connection is required, even 5.0 Mbit/s would be possible. It should be noted: the higher the clock rate, the more susceptible to failure the overall system becomes. The low operating voltage of only 3.3V does not contribute to interference resistance either.\nUses I²C is mainly used for communication between microcontrollers. The advantage that a whole series of microcontrollers can be controlled via just 2 lines is of course very interesting for the circuit board layout. The main advantages of I²C are its simplicity. There are certainly newer bus systems with better transmission rates. Hardly any bus system is as easy to use as I²C. Even “hot plugging”, ie plugging in and unplugging the devices during operation, is possible with I²C.\nAddressing I²C uses an address space of 7 bits. This allows up to 112 nodes on one bus. The remaining 16 addresses are reserved for special applications. Usually the address of a device is defined directly by the manufacturer. It can therefore be found in the relevant data sheets. Due to the shortage of addresses, there is also a variant with a 10-bit address space. Up to 1136 nodes are possible, and the protocol is compatible with the smaller 7-bit address space.\nTransfer rates    Mode Max. transfer rate Direction     Standard Mode 0.1 Mbit/s bidirektional   Fast Mode 0.4 Mbit/s bidirektional   Fast Mode Plus 1.0 Mbit/s bidirektional   High Speed Mode 3.4 Mbit/s bidirektional   Ultra Fast-mode 5.0 Mbit/s unidirektional    Additional information  Wikipedia I²C I²C Bus  Please be aware there are some hardware issues when using the Raspberry Pi with devices that expect to be able to use clock stretching, for more info see \u0026ldquo;Adventures in I2C: clock stretching on the Raspberry Pi\u0026rdquo; and \u0026ldquo;I2C stretch bug. Been fixed or not?\u0026quot;.\n "},{"uri":"https://pi4j.com/documentation/io-examples/spi/","title":"Serial Peripheral Interface (SPI)","tags":["SPI"],"description":"","content":"What is it? The Serial Peripheral Interface, abbreviated to SPI, is a bus system which enables communication between a main device (called “master”) and one or more secondary devices (called “slave”). A direct communication between all participants is not possible here, much more the master can choose at any time with which slave he would like to exchange data.\nIn order to address only one slave, a total of 3 signal lines are required, two of which are used for bidirectional data transmission and one as a clock generator for serial transmission. If further slaves are to be addressed, additional signal lines are required depending on the desired topology.\nUses In addition to communication between microcontrollers, SPI is also used to address numerous sensors and actuators. Similar to I²C, a large number of control commands and data can be transmitted in both directions with a relatively high clock rate over 3 lines. A particular advantage here is the support for “full duplex”, ie the simultaneous transmission of data in both directions.\nThe technical implementation is very simple and is also used, for example, to communicate with SD cards. The Nintendo Game Boy already used this protocol to connect several game consoles via the Game Boy Link Cable.\nAddressing As already mentioned in the first section, multiple slaves can also be connected to SPI. The number available depends on the hardware used. On the Raspberry Pi, the standard SPI0 with two different slaves use what is called Chip Select Pins is controlled.\nAdditional Information  Wikipedia SPI SPI pinout for Raspberry Pi  "},{"uri":"https://pi4j.com/documentation/io-examples/serial/","title":"Serial (UART/RS232)","tags":["Serial"],"description":"","content":"TODO\n"},{"uri":"https://pi4j.com/architecture/advanced/annotated-provisioning/","title":"Annotated provisioning","tags":[],"description":"","content":" To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations\n Next to the declarative approach, Java annotations are available for the configuration of I/O provisioning instead of the hard-coded approach offered in V.1.\nThis implementation still needs to be further fine-tuned and unified somehow to make things cleaner and more straightforward, but would provide a way to initialize a I/O for instance like this:\n@Register(0) @Address(\u0026#34;my.digital.input.pin.zero\u0026#34;) @Name(\u0026#34;My Digital Input Pin\u0026#34;) @Debounce(300000) // microseconds @WithProvider(type=PiGpioDigitalInputProvider.class) private DigitalInput input; "},{"uri":"https://pi4j.com/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/dependency-injection/","title":"Dependency injection","tags":[],"description":"","content":" To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations\n Along with the annotated I/O configuration the ability to support I/O provisioning via dependency injection also makes a lot of sense. There is some basic brute-force stuff working but this needs more work to make this a compatible implementation for Spring or CDI.\n@Inject private Context pi4j; // register a digital input listener to listen for any value changes on the digital input pin @Register(DIGITAL_INPUT_PIN_ID) private DigitalStateChangeListener changeListener = event -\u0026gt; System.out.println(\u0026#34; (LISTENER #1) :: \u0026#34; + event); // setup a digital input event listener to listen for any value changes on the digital input // using a custom method with a single event parameter @OnEvent(DIGITAL_INPUT_PIN_ID) private void onDigitalInputChange(DigitalStateChangeEvent event){ System.out.println(\u0026#34; (LISTENER #2) :: \u0026#34; + event); } "},{"uri":"https://pi4j.com/tags/digital-input/","title":"Digital Input","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/digital-output/","title":"Digital Output","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/i2c/","title":"I2C","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/javafx/","title":"JavaFX","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/library-path/","title":"Native Library Path","tags":[],"description":"","content":"Overview Some Pi4J plugins, such as the Pi4J PiGpio Provider plugin, depend on native JNI libraries to communicate with the underlying system. By default Pi4J embeds these native libraries as resources inside the plugin\u0026rsquo;s JAR file. At runtime Pi4J extracts the native library into a temporary directory so the JVM can load the library from the filesystem. Upon termination the temporary file is automatically removed.\nThis automatic extration behavior works well for most users; however, there are certain edge cases where this may fail. On failure, its common to see a UnsatisfiedLinkError on startup of your application or when you create a Pi4J context. Edge cases such as the following may require customization of the runtime to deal with native library loading.\n Systems that do not support a writable temporary directory (/tmp) may encounter the UnsatisfiedLinkError and fail to load the native library. Systems with very strict security policies may encounter the UnsatisfiedLinkError and fail to load the native library if unable to extract the resource from the JAR at runtime. Users attempting to use Pi4J under Android may also experience the UnsatisfiedLinkError and fail to load the native library.   Explicitly Define the Library Path In the event of a failure to extract and load the embedded native library from the JAR file at runtime, a user can override this default behavior by defining the system property: pi4j.library.path.\nUsage: pi4j.library.path=(system|/some/directory) Values:    Property Value Description     system The default system defined library path for the JVM (java.library.path) will be used to resolve the native libraries.   local Native libraries will be resolved in the same local directory as the plugin JAR file on the file system.   absolute file path(/some/directory) This user defined library path (absolute filesystem path) will be used to resolve the native libraries.    Examples: The pi4j.library.path system property can be assigned in the command line used to launch your Java application using the -D flag.\njava --Dpi4j.library.path=\u0026quot;system\u0026quot; ... -or- java --Dpi4j.library.path=\u0026quot;local\u0026quot; ... -or- java --Dpi4j.library.path=\u0026quot;/some/directory\u0026quot; ... The pi4j.library.path system property can be assigned in your code at startup and prior to creating a Pi4J Context.\nSystem.setProperty(\u0026quot;pi4j.library.path\u0026quot;, \u0026quot;/some/directory\u0026quot;); -or- System.setProperty(\u0026quot;pi4j.library.path\u0026quot;, \u0026quot;system\u0026quot;); -or- System.setProperty(\u0026quot;pi4j.library.path\u0026quot;, \u0026quot;local\u0026quot;);  For more details about the native library loading behavior, please see the NativeLibraryLoader.java class: https://github.com/Pi4J/pi4j-v2/blob/master/libraries/pi4j-library-pigpio/src/main/java/com/pi4j/library/pigpio/util/NativeLibraryLoader.java\n  Where To Get The Native Libraries The Pi4J native libraries can be obtained by extracting the architecture specific libpi4j-xxx.so file from the plugin JAR file\u0026rsquo;s resources.\nAdditionally, the Pi4J native libraries are published as independant artifacts in the Maven Repository: https://oss.sonatype.org/#nexus-search;quick~pi4j-library-pigpio\n"},{"uri":"https://pi4j.com/documentation/providers/pigpio/","title":"PiGpio","tags":[],"description":"","content":"TODO\n"},{"uri":"https://pi4j.com/architecture/advanced/plugins/","title":"Plug-ins","tags":[],"description":"","content":"The goal of Pi4J V.2 is to provide a solid base with all required \u0026ldquo;minimal functionality\u0026rdquo; while at the same time, promote third-party development and extensibility, thus enabling developers to build and maintain their extensions outside of the Pi4J core projects codebase.\nThis will enable us to deliver a stable, fully tested framework as the number of features inside of Pi4J can be limited and support for specific I/O hardware can be provided with an extension for Pi4J.\nMore info about how this extensibility is achieved:\n Extensible I/O hardware PROVIDERS: things like GPIO expanders, I2C bus expanders, GertBoard, add-on hardware shields, etc. Extensible SBC platforms PLATFORMS: the core project may only support Raspberry Pi, but the platform and libraries should be written to allow a third party to create plugins for alternate hardware platforms/boards. Extensible plugins.  Plugins are extensible service modules that interact with or augment the Pi4J infrastructure. The most common plugins are I/O Providers and Platforms. Other plugin examples could be a web app to view/control the Pi4J runtime state/status, some third-party observer to the Pi4J runtime state/status,\u0026hellip;\nPlugins are implemented as Java modules using Service Provider Interfaces (SPI).\nPlugins must declare their pluggable interface in their \u0026ldquo;module-info.java\u0026rdquo; config file. Example from the Raspberry plugin:\nmodule com.pi4j.plugin.raspberrypi { requires com.pi4j; exports com.pi4j.plugin.raspberrypi; exports com.pi4j.plugin.raspberrypi.platform; exports com.pi4j.plugin.raspberrypi.provider.gpio.digital; exports com.pi4j.plugin.raspberrypi.provider.pwm; exports com.pi4j.plugin.raspberrypi.provider.serial; exports com.pi4j.plugin.raspberrypi.provider.spi; exports com.pi4j.plugin.raspberrypi.provider.i2c; provides com.pi4j.extension.Plugin with RaspberryPiPlugin; } "},{"uri":"https://pi4j.com/tags/pwm/","title":"PWM","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/documentation/platforms/raspberry-pi/","title":"Raspberry Pi","tags":[],"description":"","content":"TODO\n"},{"uri":"https://pi4j.com/architecture/advanced/remote-support/","title":"Remote support","tags":[],"description":"","content":"One of the big features on the wish-list for V.2: native support for remote I/O capability. Predominantly to support the ability for a user to perform development work on their desktop/laptop and be able to run their project with remote support slaving the I/O to a daemon running on the Raspberry Pi (or other supported SBC).\nTO BE DECIDED: the V.2 codebase does support this currently by using the PiGpio daemon.\nThis may be an OK place to start for the first release, but a separate Pi4J daemon may be ideal for a long term solution to capture some of the edge cases and provide remote I/O capability no matter which underlying I/O library is being used.\n "},{"uri":"https://pi4j.com/tags/serial/","title":"Serial","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/spi/","title":"SPI","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/3rd-party/","title":"Third-Party Integration","tags":[],"description":"","content":"TODO\n"},{"uri":"https://pi4j.com/","title":"Welcome to Pi4J","tags":[],"description":"","content":"Welcome to Pi4J This project is intended to provide a friendly object-oriented I/O API and implementation libraries for Java Programmers to access the full I/O capabilities of the Raspberry Pi platform. This project abstracts the low-level native integration and interrupt monitoring to enable Java programmers to focus on implementing their application business logic.\nBrief History The Pi4J Project was started in 2012, the same year the Raspberry Pi was introduced as a tool to provide Java developers a simple and familiar object-oriented interface library to access the low-level I/O capabilities of the Raspberry Pi including GPIO, I2C, SPI, PWM and Serial communications.\nProject Mission/Goals The Pi4J Project\u0026rsquo;s mission is to provide a rich and powerful, yet simple to use, Java-friendly API library enabling programmatic access to the low-level hardware I/O capabilities of embedded platforms such as the Raspberry Pi.\nProject Status Summary The Pi4j project has evolved in all these years as the whole Java eco-system and Raspberry Pi systems have been evolving.\nThis resulted in two main versions.\nVersion 1 The original library which started in 2012 and got a last release in 2021. Up till version 1.3 the library targets Java 8, while version 1.4 relies on Java 11. More info is provided on \u0026ldquo;Previous versions (V.1)\u0026quot;.\nVersion 2 As of Version 2.0, Pi4J will no longer include support for peripheral devices and add-on chipsets/boards as part of the core project. A new plugin model has been introduced in version 2.0 that should help enable third-party development and support third-party add-ons which may be developed and maintained independently of the core Pi4J project.\nRead more on \u0026ldquo;What\u0026rsquo;s New (V.2)\u0026quot;.\n"}]