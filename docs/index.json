[{"uri":"https://pi4j.com/about/","title":"About","tags":[],"description":"","content":"Project Status/Summary Pi4J V.2 is a complete re-write and does not maintain API compatibility with previous versions. It is not intended to be a drop-in replacement for previous versions of Pi4J. Pi4J V.2 is a completely new design bringing modern conventions, development practices, extensibility support and simplified integration experience for Pi4J users.\nThis website aims to be the source of documentation for all things Java on Raspberry Pi. As such, you will not only find info on Pi4J, but also getting started examples for basic Java Pi4J projects, JavaFX user interface applications, FXGL games, etc.\nThis is a true open-source project, meaning it can only evolve, grow and improve by the support of the community. Any idea, documentation improvement, bug fix\u0026hellip; is greatly welcomed through the normal GitHub flow!\n"},{"uri":"https://pi4j.com/pi4j-os/prepare-sd-with-pi4j-os/","title":"Prepare SD with Pi4J OS","tags":["Pi4J OS"],"description":"","content":"To prepare an SD-card with one of these flavors, download the latest build from pi4j.com/download and follow the steps described in \u0026ldquo;Set up a new Raspberry Pi, but instead of selecting one of the OS\u0026rsquo;s predefined in the Imager tool, select \u0026ldquo;Choose OS \u0026gt; Use custom\u0026rdquo;, and selected the downloaded file.\nInstall the Raspberry Pi Imager The official Imager Tool can be downloaded directly from the Raspberry Pi website. This simple tool works on all common operating systems and can be installed very easily with just a few keystrokes. More detailed instructions for installation are also available on the homepage of the Raspberry Pi website or here on \u0026ldquo;Set up a new Raspberry Pi\u0026rdquo;.\nDownload the Pi4J OS Image The image for the Pi4J OS which contains the operating system for the Raspberry Pi can be obtained directly from the pi4j.com/download/.\n   Download Pi4J OS Image\n    After the download, unzip the .zip archive. Everything is now ready for the next step!\nWriting the image to an SD card When the image is written to the SD card, all data that is still on it will be overwritten!\n First, the SD card must be available as a drive on the computer. There are different possibilities for this. Card readers are just as suitable as USB adapters. The Raspberry Pi Imager tool is now started. First, the operating system must be selected. Press the button \u0026ldquo;Choose OS\u0026rdquo;.\nAt the bottom of the list, select \u0026ldquo;Use custom\u0026rdquo;. In the selection dialog, select the previously downloaded and unzipped Pi4J OS img-file.\n   Choose OS in Imager Tool\n      Use custom in Imager Tool\n    The second step is to select the SD card. To do this, press the button \u0026ldquo;Choose storage\u0026rdquo;. It automatically shows you only the available removable media such as USB sticks or SD cards. It is now very important to select the correct entry in order to avoid unwanted data loss. On Windows, the drive letter that is actually affected is shown under the data carrier, so that this can be easily checked in Explorer. In case of doubt, however, simply unplug the data carrier with important media beforehand so that nothing can happen.\nEverything is ready to write the image to the SD card. The process can be started by pressing the \u0026ldquo;Write\u0026rdquo; button. Another confirmation dialog follows before the SD card is finally overwritten. Writing the image to the SD card can take a few minutes which is completely normal. As soon as the process is completed, a message appears. The SD card can now be removed from the computer.\nInsert the SD card into the Raspberry Pi To use the new operating system with your Raspberry Pi, insert the prepared SD card. Power up the device and it will probably restart a few times, after which it\u0026rsquo;s ready to be used.\nUsing Pi4J CrowPi OS When using a CrowPi, the 4 retaining screws may have to be loosened. These can be found here:\nAfter loosening the screws, the Raspberry Pi can be lifted. At most, a few cables must be unplugged. The SD card slot can now be found on the underside. Here the SD card with the contact surfaces can be inserted in the Raspberry Pi. The slot is marked again in the picture below. As soon as the SD card is inserted, the Raspberry Pi can be correctly installed in the CrowPi and any cables that may have been disconnected can be plugged in again. As soon as everything is back in its place, the CrowPi can be connected to the power.\nBefore the CrowPi is put into operation, it should be checked again whether all 3 cables are connected to the Raspberry Pi. The HDMI adapter on the left, the USB cable on the lower side and the GPIO ribbon cable on the right should be connected. These mandatory cables are framed with red circles in the next graphic. Optionally, a keyboard and mouse can be connected via USB, which is marked with a pink circle below:\n   Raspberry Pi in the CrowPi with marked screws\n      Raspberry Pi SD card slot\n      Raspberry Pi cables\n    Establish the network connection Only the network connection of the freshly started Raspberry Pi still has to be made manually. Otherwise, all settings are already optimally contained in the image. Now there are a few options for the network connection:\n Connection via WLAN Connection via Ethernet cable (DHCP) Connection via Ethernet cable directly to the computer  The easiest way to make the settings is to use the mouse and keyboard connected to the Raspberry Pi. Setting up via WLAN is explicitly recommended, as it can be used in almost any environment and works great with the hotspot function on your own smartphone even when you are out and about.\nIn the following, only the connection via WLAN is described, however, if there is expertise in this area, a connection via cable can also be established.\nEstablishing a WLAN connection To connect via wireless network, the two arrows on the icon on the desktop must be pressed on the top right, after which you can select the desired network. Then enter the corresponding password in the dialog for secure connections. A few seconds after the connection, the desktop background image will automatically update and display the assigned IP address. An Ethernet address is also visible on the images. This means that at the moment of the recording there was also an Ethernet cable connected to the Raspberry Pi. Now that we have a network connection, we are ready to set up the development environment as the next step.\n    Select WLAN\n      WLAN password\n      Background with IP addresses\n                               "},{"uri":"https://pi4j.com/architecture/about-the-code/","title":"Project source structure","tags":[],"description":"","content":"To ensure the Pi4J V.2 project is easy to maintain, there is a clear separation between the core functions and isolated test, example and plugin projects.\nOn this page we want to give you an overview of the projects which are part of the GitHub Pi4J Project.\nPi4J V.2 Main project  github.com/Pi4J/pi4j-v2 This is the main Pi4J V.2 project providing all (basic) I/O functionalities.  Pi4J Parent POM  /pom.xml This is \u0026ldquo;the grandparent POM\u0026rdquo; and the place to build the entire project.  Pi4J Libraries  /libraries/* This folder contains (JNI native) libraries that Pi4J or Pi4J plugins may require for runtime. Libraries are not Pi4J extension, plugins, providers, platforms, etc. At this moment only a PiGpio library is included, but could be extended in the future. By isolation the native functions in libraries, the underlying I/O interface can easily be replaced later without breaking the core library.  Pi4J Libraries Parent POM  /libraries/pi4j-library/pom.xml Base library to be used when creating a new library. Contains the parent pom.xml-file for all library implementations.  Pi4J PiGPIO JNI Wrapper Library  /libraries/pi4j-library-pigpio This library is a Java library to wrap the PiGPIO API and implement the JNI layer to facilitate use of PiGPIO in Java. There is no Pi4J specific API or code in this library. This PiGPIO wrapper can be used directly without using the Pi4J-core but in that case your application highly depends on the methods of PiGPIO and will be very hard to refactor if you need to use another wrapper.  Pi4J Core Library  /pi4j-core This is the Pi4J V.2 API and core implementation of the framework and runtime. Doesn\u0026rsquo;t contain any actual I/O providers, platforms or IO/platform implementation \u0026ndash;\u0026gt; those are all provided via extensions/plugins.  Pi4J Unit/Integration Test  /pi4j-test This is intended to be a place for unit and integration tests to test the APIs and features. It only performs tests using MOCK I/O via the Mock IO Provider (plugin). It should not attempt to perform any real I/O testing.  Pi4J Plugins: the actual I/O providers, platforms and implementations  /plugins/* This folder contains any plugins for use with Pi4J such as IO providers, platforms, or extensions. Plugins must implement the Pi4J Plugin Interface (com.pi4j.extension.Plugin) and declare the implementation class using the \u0026ldquo;provides\u0026rdquo; directive in the module info class. See for an example in /plugins/pi4j-plugin-mock/src/main/java/module-info.java  Pi4J Libraries Parent POM  /plugins/pi4j-plugin/pom.xml* Base library to be used when creating a new plugin. Contains the parent pom.xml-file for all plugin implementations.  Pi4J LinuxFS Provider  /plugins/pi4j-plugin-linuxfs This plugin is intended to implement I/O Providers for Linux file system operations such as SERIAL, SPI, I2C and perhaps basic GPIO. This plugin is mostly empty at this moment. Goal is to have an I/O Provider which is totally independant of an underlying program.  Pi4J Mock Platform \u0026amp; Provider  /plugins/pi4j-plugin-mock This plugin implements both a Mock Platform and Mock I/O Providers for every I/O type supported by Pi4J. This Mock plugin is used by the unit and integration testing project.  Pi4J PiGPIO Provider  /plugins/pi4j-plugin-pigpio This plugin implements I/O Providers for every I/O type supported by the PiGPIO library. At this moment, this single plugin supports both ** local/native connectivity to PiGPIO ** remote (TCP) connectivity to PiGPIO ** TO BE DISCUSSED: Perhaps this should be separated into two plugins? Or moved to a separate \u0026ldquo;remote connectivity project\u0026rdquo;?  Pi4J RaspberryPi Platform \u0026amp; Provider  /plugins/pi4-plugin-raspberrypi This plugin is intended to implement the Provider for the Raspberry Pi models and declare the default I/O providers for each of the I/O types supported by each RPi model.  Pi4J WiringPi Provider  NOT IN THE PROJECT CODE This plugin was intended to implement I/O Providers for use with the WiringPi library, similar to the PiGPIO provider. However with the WiringPi project no longer being maintained publicly, this plugin was not implemented  Stand-alone projects Pi4J Test Harness  github.com/Pi4J/pi4j-test-harness This project contains the source code (both Java library and Arduino code) for the hardware test harness which has been created to eventually perform hardware testing at the physical layer to help speed up verification for each RPI hardware model Current state is very rough but functional. This project has been moved outside of the core project as this is only used for the validation test cycle before releasing a new version. For more info, see \u0026ldquo;Hardware testing\u0026rdquo;  Pi4J Example projects Pi4J Minimal example  github.com/Pi4J/pi4j-example-minimal Example project only showing the use of a digital input and output with minimal code but a lot of comments  Pi4J Examples  github.com/Pi4J/pi4j-examples This project contains numerous code examples to demonstrate how to use Pi4J Certain functions have examples to reach the same goal with different use types, e.g. initialization of a DigitalInput with code, properties and annotations.  Pi4J Telegraph example  github.com/Pi4J/pi4j-example-telegraph Example project demonstrated during Oracle Code One 2019  "},{"uri":"https://pi4j.com/examples/crowpi/develop-crowpi-with-intellij/","title":"Develop with Intellij IDEA","tags":["Pi4J OS","CrowPi","IntelliJ IDEA"],"description":"","content":"The CrowPi example project contains settings to make it easy to develop on a PC with IntelliJ IDEA and execute the application on the CrowPi. The articles, instructions and pictures are created accordingly. IntelliJ IDEA is from available Jetbrains in different versions. The community version has enough functionality for development with the CrowPi and is available for Windows, MacOS and Linux, but NOT for Raspberry Pi. The download can be found here.\nThe subsequent setup of IntelliJ IDEA is identical on all platforms.\nClone the repository As soon as we have installed the development environment, it is time to clone the entry-level project for the CrowPi. The source code can be found on GitHub. In order to clone the repository, the corresponding link must be copied on GitHub and then imported into IntelliJ IDEA. Now step-by-step in pictures a more detailed instruction.\nVisit CrowPi on GitHub and copy the link to clone as described in the picture.\n    CrowPi source link\n                               Import the project In the start window of IntelliJ is the option Get from VCS available. This must be selected so that the code can be cloned directly from GitHub. Then you can simply paste the link that was previously copied from GitHub. By confirming with Clone the process is started and any necessary authentication of the user is carried out. Simply follow the instructions of the tool.\n   Import from VCS\n      Insert import from VCS link\n    As soon as the project has been completely cloned on the local computer, the project opens automatically in the development environment. A small dialog pops up at the bottom right. This must be confirmed so that the repository can be properly initialized. Maven is a software project management tool, more information can be found in the Apache Maven Project. Basically, however, nothing needs to be changed. The CrowPi project already offers a complete setup and is easy to use.\n   Import Maven Project\n    Importing the Maven project triggers a security warning at IntelliJ. Click on \u0026ldquo;Trust project\u0026rdquo; to confirmed when you downloaded the soruces from the official Pi4J CrowPi repository.\n   Trust Project confirmation\n    Now a last import step. To be able to better research errors or understand how the code of the dependencies works, the \u0026ldquo;Maven Sources and Documentation\u0026rdquo; must be downloaded. This can be done with a few clicks. Open the Maven project menu on the far right. Click on \u0026ldquo;Download Sources and/or Documentation\u0026rdquo;. Then in the context menu \u0026ldquo;Download Sources and Documentation\u0026rdquo;. Now all used libraries are locally available and visible.\n   Download Dependencies and Sources\n    Now only the start configuration of the project is missing, which is described in the next section.\nSetting the run configuration The CrowPi project uses 3 run configurations. These define which parts of the code are executed and how. However, there is no need to worry, because most of it is already predefined and all you have to do is enter the IP address of your Raspberry Pi to push and run the code from your PC to the Pi. The following configurations are used:\n crowpi-examples [install] crowpi-examples [debug] Remote Debug  With \u0026ldquo;crowpi-examples [install]\u0026rdquo; the current code is copied to the Raspberry Pi. This works via a combination of SSH/SCP. The copied code is then started on the Raspberry Pi. \u0026ldquo;crowpi-examples [debug]\u0026rdquo; does the same, but other options are selected during the connection, and a debugger is waiting until the application is actually executed. \u0026ldquo;Remote Debug\u0026rdquo; provides exactly this debugger. This connects to the Raspberry Pi and troubleshooting can begin.\nTo make everything work smoothly, the IP address of the Raspberry Pi must first be configured. To do this, click here and select \u0026ldquo;Edit Configurations\u0026rdquo;. As explained before, the IP address of the Raspberry Pi is displayed on the background image of CrowPi.\n   Select configuration menu\n    The dialog for setting the configurations now opens. A little hint: wherever the IP address of the Raspberry Pi is required, there is already a placeholder \u0026ldquo;Add CrowPi IP here\u0026rdquo;.\nDepending on the configuration of your Raspberry Pi, you may need to define one of this available properties:\n crowpi.remote.port, default 22 crowpi.remote.username, default pi crowpi.remote.password, default pi crowpi.remote.target, default ??? crowpi.launcher.class, default ??? crowpi.launcher.args, default ???  crowpi.remote.host specifies the IP/hostname of the CrowPi, defaults to empty crowpi.remote.port defaults to 22 and specifies the SSH server port crowpi.remote.username defaults to pi crowpi.remote.password defaults to crowpi (this deviates from the Raspberry Pi OS default which is raspberry) crowpi.remote.target is the destination folder on the CrowPi where the compiled JAR files are copied to before execution and defaults to /home/pi/deploy (auto-created if missing) crowpi.launcher.class is the class path which should get launched by the JVM, defaults to com.pi4j.crowpi/com.pi4j.crowpi.Launcher and should not be changed (warranty void if you do so :wink:) crowpi.launcher.args are the arguments passed to the application launched by the JVM, specified as a string, passed through as-is without quoting, so e.g. BuzzerApp to launch that directly. Defaults to empty / no args.\nThe first five are only needed for remote deployments. Leaving crowpi.remote.host empty triggers local deployment.\nThere is also crowpi.remote.jvmOptions if you want to add any custom JVM options, defaults to empty or options for remote debug if Maven profile debug is used (edited)\n   The three configurations\n    First we configure \u0026ldquo;crowpi-examples [debug]\u0026rdquo;. For this, as in the picture, go to the tab \u0026ldquo;Runner\u0026rdquo; open and double click on \u0026ldquo;Add CrowPi IP here\u0026rdquo;. The dialog window to provide the IP address opens. Confirm with \u0026ldquo;OK\u0026rdquo; and press \u0026ldquo;Apply\u0026rdquo; to save.\n   Settings debug\n    Now we can configure \u0026ldquo;crowpi-examples [install]\u0026rdquo;. This works exactly the same as \u0026ldquo;crowpi-examples [debug]\u0026rdquo;. The same setting is required. Again use \u0026ldquo;Apply\u0026rdquo; to save.\n   Settings Install\n    Now the last configuration for \u0026ldquo;Remote Debug\u0026rdquo;. The menu is a bit different here. However, it is easier to use than the previous ones. Add the IP Address in the \u0026ldquo;Host\u0026rdquo; field. With \u0026ldquo;OK\u0026rdquo; the setting is finished.\n   Remote Debug Settings\n    First test run Everything is set up to start the CrowPi project for the first time directly from the development environment. Select the run configuration \u0026ldquo;crowpi-examples [install]\u0026rdquo;. Then start the application by pressing the green play button.\n   Start the application\n    It immediately opens the \u0026ldquo;Run\u0026rdquo; window in IntelliJ IDEA. It takes a moment, and some text is displayed on the command line. After a few seconds the output stops, and it looks like this:\n   Run Output in IntelliJ\n    A number can now be typed in here according to the displayed list (+ Enter). The corresponding sample application is then executed. If there are still error messages in the command line, it is worth checking the network connection of the computer and the Raspberry Pi again.\n"},{"uri":"https://pi4j.com/architecture/about-the-code/download-sources/","title":"Download/Install","tags":[],"description":"","content":"You can build the project from sources available on GitHub.\nPi4J V.2  Checkout the project pi4j-v2 Select JDK11, e.g. sdk use java 11.0.16.1-zulu In the root of pi4j-v2 run mvn clean install  [INFO] Executed tasks [INFO] ------------------------------------------------------------------------ [INFO] Reactor Summary for Pi4J :: Parent POM 2.0-SNAPSHOT: [INFO] [INFO] Pi4J :: Parent POM ................................. SUCCESS [ 0.972 s] [INFO] Pi4J :: DOCKER :: Docker Parent POM .............. SUCCESS [ 0.290 s] [INFO] Pi4J :: TESTING :: Arduino Test Harness ........... SUCCESS [ 1.832 s] [INFO] Pi4J :: LIBRARY :: Libraries Parent POM ........... SUCCESS [ 0.064 s] [INFO] Pi4J :: LIBRARY :: JNI Wrapper for PIGPIO Library . SUCCESS [ 6.615 s] [INFO] Pi4J :: LIBRARY :: Java Library (CORE) ............ SUCCESS [ 6.260 s] [INFO] Pi4J :: PLUGIN :: Plugins Parent POM ............. SUCCESS [ 0.061 s] [INFO] Pi4J :: PLUGIN :: Mock Platform \u0026amp; Providers ...... SUCCESS [ 0.683 s] [INFO] Pi4J :: PLUGIN :: PIGPIO I/O Providers ........... SUCCESS [ 2.084 s] [INFO] Pi4J :: PLUGIN :: RaspberryPi Platform \u0026amp; Providers SUCCESS [ 0.447 s] [INFO] Pi4J :: TESTING :: Unit/Integration Tests ......... SUCCESS [ 2.350 s] [INFO] Pi4J :: EXAMPLE :: Sample Code .................... SUCCESS [ 0.632 s] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ Example application Building the example application  Checkout the project Pi4J V.2 - Telegraph Demo Project Select JDK11, e.g. sdk use java 11.0.16.1-zulu In the root of pi4j-demo-telegraph run mvn clean install Check the directory target\\distribution \u0026ndash;\u0026gt; this contains all the files to be copied to the Raspberry Pi  /target/distribution/pi4j-core-2.0-SNAPSHOT.jar /target/distribution/pi4j-demo-telegraph-1.0-SNAPSHOT.jar /target/distribution/pi4j-library-pigpio-2.0-SNAPSHOT.jar /target/distribution/pi4j-plugin-pigpio-2.0-SNAPSHOT.jar /target/distribution/pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar /target/distribution/run.sh /target/distribution/slf4j-api-2.0.0-alpha0.jar /target/distribution/slf4j-simple-2.0.0-alpha0.jar Running on the Raspberry Pi  After copying all files from target/distribution to a Raspberry Pi, start ./run.sh  "},{"uri":"https://pi4j.com/getting-started/","title":"Getting started with Pi4J","tags":[],"description":"","content":"You have a Raspberry Pi? And you want to use Java as your programming language to build performant, easy-to-maintain and powerful applications? This is the place to be!!!\nThe pages in this chapter explain you how to get started in different steps. The full documentation for the library, with more in-depth and technical info, can be found in the \u0026ldquo;Documentation\u0026rdquo; chapter.\nThis part of the site takes you through the different steps to start \u0026ldquo;from scratch\u0026rdquo;:\n Setting up the Raspberry Pi with all the tools needed Understanding the GPIO pins Java development on the Raspberry Pi with Visual Studio Code Using a Linux/Windows/Mac separate computer as developing workstation Minimal example application with an LED and button Introduction to electronics with CrowPi Adding a user interface with JavaFX Game development with FXGL and an Arcade controller  And if you still want to learn more, we have a list of additional resources.\n"},{"uri":"https://pi4j.com/about/previous-version-v1/","title":"Previous versions (V.1)","tags":[],"description":"","content":"Documentation of the 1.X versions Pi4J Version 1.4  Released 2021-03-03 Support for JDK/JRE 11 and 64-bit ARM platforms This release is the final release for the Pi4J Version 1.x codebase The Pi4J project is now prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform Changed project to Apache License, Version 2.0 Removed pi4j-device and pi4j-gpio-extension library Removed platform support for Odroid, BananaPi, BPi, NanoPi, OrangePi Various improvements and bug fixes listed here: GitHub Issues (v1.4) Not using Java-modules yet, this will be part of the V.2 Documentation website V1.4  Pi4J Version 1.3  Released 2021-01-29 Added support for Raspberry Pi 4B, 400, and Compute Module 4 Various improvements and bug fixes listed here: GitHub Issues (v1.3) Based on JDK8 Documentation website V1.3  Pi4J Version 1.2  Released 2019-02-26 Based on Java 8 Documentation website V1.2  Pi4J Version 1.1  Released 2016-07-26 Documentation webiste V1.1  Pi4J Version 1.0  Released 2015-04-18 Documentation website V1.0  "},{"uri":"https://pi4j.com/architecture/about-the-code/build-instructions/","title":"Build Instructions","tags":[],"description":"","content":"Building the Pi4J Project is simple and requires minimal effort. Pi4J is primarily built using Apache Maven and Java 11. Pi4J can be built directly on your host computer or inside a Docker container where all toolchains and dependencies are already installed, configuired and cached.\nIf you wish to build using a Docker container, please skip ahead to the Building with Docker topic.\n  Prerequsites In order to build Pi4J, the host system must have the following toolchains pre-installed.\n   Name Version URL     Java Development Kit (JDK) 11.0.7 (or newer) https://openjdk.java.net/   Apache Maven 3.6.3 (or newer) https://maven.apache.org/download.cgi     Build Environment The JAVA_HOME system environment variable must be configiured to point to the JDK installed path.\n Building with Maven To build the Pi4J project, use the following Maven comand from the parent Pi4J directory.\nmvn clean install If you prefer to skip all unit/integration testing, use the folllowing Maven command:\nmvn clean install -DskipTests  Building with Docker Alternatively, the Pi4J project can be entirely compiled inside a prebuilt Pi4J Builder Docker container. This eliminates the need/requirement to install the build toolchains and configure your system to build Pi4J. To build the Pi4J project using Docker, run the following shell script from the parent Pi4J directory.\n./build-docker.sh The project which provides these Docker images can be found on GitHub \u0026gt; Pi4J/pi4j-docker and includes an extensive README with the full info on how to build and use these images.\nExtract from the README:\nThis project contains the Dockerfiles and build scripts to create the Pi4J builder\ndocker images used for compiling/building the Pi4J projects. The Pi4J builder images include the following:\n  Pi4J Base Builder pi4j/pi4j-builder-base:latest : This is the base image used by all the other builder images. It's based on Ubuntu 18.04 with JDK 11 and Maven pre-installed. This image's entry point is a Bash shell. (https://hub.docker.com/repository/docker/pi4j/pi4j-builder-base)\n  Pi4J Native Builder pi4j/pi4j-builder-native:latest : This image is derived from pi4j/pi4j-builder-base and adds support for native cross-compilers and build tools for architectures: arm, armhf, aarch64/arm64. This image's entry point is a bash shell attempting to execute the file ./build.sh in the volume mounted under the /build path.\n  Pi4J v1.4 Builder pi4j/pi4j-builder:1.4 : This image is derived from pi4j/pi4j-builder-native and additionally includes pre-cached Maven build plugins and dependencies for Pi4J v1.4 builds. This image's entry point is a Maven shell. If not explicitly provided, the default maven build arguments will be: clean install -DskipTests -Pall-platforms. This will effectively build all Pi4J projects including the pi4j-native project containing native libraries which will be cross-compiled for RaspberryPi/ARM (32-bit \u0026amp; 64-bit) devices.\n  Pi4J v2.0 Builder pi4j/pi4j-builder:2.0 : This image is derived from pi4j/pi4j-builder-native and additionally includes pre-cached Maven build plugins and dependencies for Pi4J v2.0 builds. This image's entry point is a Maven shell. If not explicitly provided, the default maven build arguments will be: clean install -DskipTests -native. This will effectively build all Pi4J projects including the native library projects which will be cross-compiled for RaspberryPi/ARM (32-bit \u0026amp; 64-bit) devices.\n  Note: Pi4J versions prior to v1.4 are not currently tested or supported in these Docker images.\n Building Pi4J Native Libraries Pi4J V.2 also includes native libraries that will need to be compiled if you are modifying any native code. Most users will never need to compile the native libraries as these artifacts are automatically downloaded when building the Pi4J JARs from Maven repositories. One of the following commands can be used to build the Pi4J JARs and Native Libraries:\nmvn clean install -Pnative mvn clean install -Pnative,docker mvn clean install -Pnative,cross-compile  See the custom build profiles in the Custom Build Profiles section for more information about the profiles illustrated in these commands.\n Additional information about Docker Builds vs Cross-Compiler builds can be found here: https://github.com/Pi4J/pi4j-v2/issues/21#issuecomment-651976487\n Custom Build Profiles The Pi4J Maven build includes a number of custom profiles that can be activated to perform various build steps.\n   Profile Description Notes     sources Package raw sources for each JAR Only needed when performing a snapshot or release build.   javadoc Compile and package JavaDoc for each JAR Only needed when performing a snapshot or release build.   native Compile any native libraries included in the build Only needed when modifying native code or performing a snapshot or release build.   docker Use docker builder containers to compile native library artifacts Only used when incuding the native profile or performing a snapshot or release build.   cross-compile Use cross-compilers on host to compile native library artifacts Only used when incuding the native profile or performing a snapshot or release build.   test-hardware Perform hardware integration testing EXPERIMENTAL   mac Use docker builder containers to compile native library artifacts (Same as docker profile) Automatically activated when running build from a MacOS host system.   windows Use docker builder containers to compile native library artifacts (Same as docker profile) Automatically activated when running build from a Windows host system.   transfer Perform SSH/SCP file transfers for each JAR to a remote Raspberry Pi Used for parallel development and testing.    You can activate a build profile using the -P{profile-name} argument in the Maven command:\nmvn clean install -Pjavadoc Release/Snapshot Builds Pi4J release and snapshot builds are reserved for the Pi4J Development Team. A release build ensures all JARs, resources, source-bundles, native libraries, and javadoc artifacts are compiled and deployed to the public Maven repositories. You can use the following command to perform all the build steps that would be performed during a release or snapshot build.\nmvn clean install -Drelease-build "},{"uri":"https://pi4j.com/examples/crowpi/crowpi-examples/","title":"CrowPi examples","tags":["Pi4J OS","CrowPi"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-crowpi\n The CrowPi example code contains examples for the following components. The links in this table will bring you to the German documentation written by the students who created these examples.\n   Component Link     7-Segment Display seven-segment   Button button   Button Matrix button-matrix   Buzzer buzzer   Infrared Receiver ir-receiver   LCD Display lcd-display   LED Matrix led-matrix   Light sensor light-sensor   PIR Motion Sensor pir-motion-sensor   Relais relay   RFID rfid   Step motor step-motor   Servomotor servo-motor   Sound Sensor sound-sensor   Temperature and humidity sensor humi-temp-sens   Tilt Sensor tilt-sensor   Touch Sensor touch-sensor   Ultrasonic distance sensor ultrasonic-sensor   Vibration motor vibration-motor    "},{"uri":"https://pi4j.com/documentation/","title":"Documentation","tags":[],"description":"","content":"Pi4J wants to provide the best possible solution for Java development on the Raspberry Pi for two use-cases.\n Do you want to develop an application without the need to touch the internal code of Pi4J?  In that case you\u0026rsquo;re at the right place for all the documentation you need! In this section you can find multiple examples to get you started.\n Do you want to go a few steps further and contribute to Pi4J, extend it with additional plugins or understand how it is build?  In that case you\u0026rsquo;ll find more information in the Architecture/Design section. Table of contents of the \u0026ldquo;Documentation\u0026rdquo; section  Pin numbering     Java for ARMv6/7/8     Logging with SLF4J     Creating a Pi4J Context     Choosing a Platform    Raspberry Pi      Choosing an I/O Provider    LinuxFS     PiGpio      Building an I/O Instance     I/O Examples    Digital Output (GPIO)     Digital Input (GPIO)     Pulse Width Modulation (PWM)     Inter-Integrated Circuit (I²C)    I²C Clock Stretching    Serial Peripheral Interface (SPI)     Serial (UART/RS232)      I/O Registry     Shutting down the Pi4J Context     Building and running    Building with javac     Build as a FAT JAR with Maven     Build Java modules with Maven     Build Java modules with Gradle     Running Pi4J with JBang      "},{"uri":"https://pi4j.com/getting-started/set-up-a-new-raspberry-pi/","title":"Set up a new Raspberry Pi","tags":[],"description":"","content":"Introduction The Raspberry Pi is a powerful machine with many use-cases. A lot of this power is based on the operating system you use. For our \u0026ldquo;Getting Started\u0026rdquo; examples we will be using the \u0026ldquo;official Raspberry Pi OS\u0026rdquo; (formerly known as \u0026ldquo;Raspbian OS\u0026rdquo;) but there is a long list of other possibilities which is listed for example on the\u0026ldquo;Awesome Raspberry Pi\u0026rdquo; list on GitHub.\nIn this article we start with a brand new Raspberry Pi board.\nStep-by-step First step: take your new Raspberry Pi out of the box of course :-)\nTake a good look at it, what you are holding in your hands is a true master piece. A wonder of technical engineering with a perfect mix of powerful yet inexpensive components.\nBut be aware! This is also some piece of sensitive electronics. It\u0026rsquo;s always a good idea to first touch the grounding pin of a power outlet to make sure your body is not electrically charged which could damage one of the components on the board.\nMaterial list  Raspberry Pi Micro SD card, minimally 16Gb b PC (or other Raspberry Pi) with an SD card slot (maybe you will need an SD card adapter) Power supply (5V, 2 or 3A) Monitor, keyboard, mouse  SD card The SD card will hold the operating system. On the Raspberry Pi website, on the download page, you can find the Imager tool. Select the version for your computer, download and install it.\nStart the Imager and follow these steps:\n Click on \u0026ldquo;Operating System\u0026rdquo; \u0026gt; \u0026ldquo;CHOOSE OS\u0026rdquo; Select \u0026ldquo;Raspberry Pi OS (other)\u0026rdquo; Select \u0026ldquo;Raspberry Pi OS Full (32-bit)\u0026rdquo;                                           By selecting the \u0026ldquo;Full\u0026rdquo; edition, we will have an operating system which is preloaded with a load of additional tools, including \u0026ldquo;OpenJDK 11\u0026rdquo;, so will be able to take a quick start with Java development.\nPut your SD card into your computer or in an SD card reader you can connect to USB Click on \u0026ldquo;SD Card\u0026rdquo; \u0026gt; \u0026ldquo;CHOOSE SD CARD\u0026rdquo; Select the SD card  First start-up Additional Raspberry Pi OS settings Check the Java version As we have put the Full edition on the SD card, Java is already available. Open a terminal window and type in java -version. Java will be started to show you the installed version.\n$ java -version openjdk version \u0026#34;11.0.9\u0026#34; 2020-10-20 OpenJDK Runtime Environment (build 11.0.9+11-post-Raspbian-1deb10u1) OpenJDK Server VM (build 11.0.9+11-post-Raspbian-1deb10u1, mixed mode) Install Pi4J Nothing to do here! Pi4J are dependencies you add to your project with Maven or Gradle. So nothing to be installed\u0026hellip;\nIf you want to get started with Pi4J V2 without creating a full Java project, take a look at the \u0026ldquo;single source file\u0026rdquo; example with JBang.\nKeep your Raspberry Pi up-to-date Update to the latest version Open a terminal and perform following commands\nsudo apt update sudo apt full-upgrade Raspberry Pi OS is based on Debian - one of the largest Linux distrubutions. When running these commands regularly, you will keep your installation up to date for the particular major Raspberry Pi OS release you are using (e.g. Debian V9, aka Stretch). It will not update from one major release to another, for example, Stretch (V9) to Buster (V10).\n"},{"uri":"https://pi4j.com/pi4j-os/test-pi4j-basic-os/","title":"Test Pi4J Basic OS","tags":["Pi4J OS"],"description":"","content":"The Pi4J Basic OS contains two simple applications in directory java-examples and a sample file to test the audio channel. As Pi4J CrowPi OS and Pi4J Picade OS are based on Pi4J Basic OS, they also contain these tests.\nYou can start the tests via ssh.\nAudio Test cd /home/pi nvlc Music/StarTrekTheme.mp3 Pure JavaFX Application Compile the JavaFX application\ncd /home/pi/java-examples/pure-javafx javac --module-path /opt/javafx-sdk/lib --add-modules=javafx.controls,javafx.media hellofx/HelloFX.java To start HelloFX in X11-Mode\nDISPLAY=:0 XAUTHORITY=/home/pi/.Xauthority sudo -E java --module-path /opt/javafx-sdk/lib --add-modules javafx.controls,javafx.media -Dglass.platform=gtk hellofx.HelloFX To start HelloFX in DRM (Direct Rendering Mode)\nsudo java-kiosk hellofx.HelloFX  java-kiosk is a command provided by our image. It assures to call java with the correct (and huge) set of parameters.\n Pure Pi4J Application Attach a button to pin 25.\n On CrowPi that\u0026rsquo;s the left-button. on Picade Console that\u0026rsquo;s the button-4-button.   Otherwise:  Compile and start the Java application\ncd /home/pi/java-examples/pure-pi4j javac -cp \u0026#34;/home/pi/deploy/*:.\u0026#34; hellopi4j/MinimalPi4J.java sudo java -cp \u0026#34;/home/pi/deploy/*:.\u0026#34; hellopi4j.MinimalPi4J "},{"uri":"https://pi4j.com/about/new-in-v2/","title":"What&#39;s New (V.2)","tags":[],"description":"","content":"What\u0026rsquo;s New in 2.0? Pi4J version 2.0 brings with it many new features, and an entirely new architecture that focuses on extensibility, simplified integration and a modern Java API including the following:\n Fluent APIs/Interfaces Immutable Runtime Context Extensible Provider/Platform/Plug-in Architecture Builder-patterns for creating new I/O instances Well-documented source code Hardware PWM Support Java 11  Future plans:\n Dependency Injection via Pi4J Annotations Remote I/O Support (via TCP/IP)  In addition to the features listed above, Pi4J version 2.0 also abandons the old WiringPi pin numbering scheme in favor of the more traditional and commonly used Broadcom pin numbering scheme. This pin numbering scheme has been a source of confusion for a number of years, especially with beginners and is somewhat cumbersome to maintain as new Raspberry Pi models are introduces with differing or added GPIO pins. Moving forward, Pi4J will only use the Broadcom (BCM) pin numbering scheme.\nThe WiringPi project has now been deprecated (see wiringpi.com/wiringpi-deprecated/). Pi4J version 2.0 will no longer be based on WiringPi and has moved to using the PIGPIO library (http://abyz.me.uk/rpi/pigpio/) internally for low level integation. With this move, we will also support the remote I/O features (via TCP socket) offered by the PIGPIO daemon (http://abyz.me.uk/rpi/pigpio/pigpiod.html).\nWhat are the differences compared to V.1? Starting with the Pi4J 2.0 builds, the Pi4J project is prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform. Earlier versions of Pi4J were perhaps too ambitious in scope and that led to significant project bloat to the point that the project was becoming unsustainable. The goal moving forward is to limit scope to that of the raw I/O capabilities of the Raspberry Pi platform and provide timely updates and releases for bug fixed and new RaspberryPi model introductions. Reducing the scope of the project should better serve the Java community for basic I/O access by reducing complexity.\nThe following features have been removed from the Pi4J library:\n IO Expanders \u0026ndash; IO expansion is still supported but concrete implementations should be provided outside the core Pi4J core project such that they can be maintained and extended independently. Other Platforms \u0026ndash; Other platforms such as Odroid, BananaPi, NanoPi, OrangePi, etc. have been removed and will no longer be supported. The challenge with supporting these additional platforms is that Pi4J depends on the underlying WiringPi project and WiringPi ports for these other platforms is not well supported by the various SoC vendors or community. The various WiringPi ports for these other platforms are also inconsistent causing inconsistent features and functionality of Pi4J. Additionally, regression testing of bug fixes and new features in Pi4J is compounded with each additional supported platform. Components \u0026amp; Devices \u0026ndash; Pi4J originally provided higher level interfaces for components and devices that provided an abstraction layer between real world devices (things) and lower-level I/O interfaces. While a noble goal, unfortunately this part of the project never received the attention and time that it deserved and never gained much adoption by the community. We are removing these to allow Pi4J to focus solely on the raw I/O supported by the Raspberry Pi platform.  Sources The Pi4J V.2 source code is available in this GitHub repository: Pi4J V.2 GitHub Repository\ngit clone https://github.com/Pi4J/pi4j-v2 Pi4J V.2 had the first release in August 2021. Rework from V.1 to V.2 took quit some time and will never be finished, but we are confident this is a great library to develop Java application on the Raspberry Pi. Any remarks and contributions are welcome as either bug reports or discussions in the GitHub repository.\n"},{"uri":"https://pi4j.com/examples/","title":"Example Implementations","tags":[],"description":"","content":"The core Pi4J V.2 library doesn\u0026rsquo;t contain any specific support for devices like buttons, motors, LCD\u0026hellip; This was part of V.1 but made the project much more difficult to maintain and fully test the library.\nIn this section, we want to provide you example implementations of several devices that are maintained by the community.\nCurrent code providers    Provider Link     FHNW University Components   FHNW University Electronics with CrowPi   Community Implementation Community Implementation   Pi4J JBang examples    Simple Implementation For a simple implementation of a project with one of the components, the recommendation is to use the Template-Project. The Readme.md describes how to get started with the project. To get a better understanding, look at one of those finished template-projects: Theremin or Photobooth\nElectrical Engineering General inputs and help on electrical engineering can be looked up on the Getting started with PI4J / Electrical Engineering page.\nTable of contents of the \u0026ldquo;Example Implementations\u0026rdquo; section  Component Examples    Simple Button     Simple LED     AD Converter ADS1115     Buzzer     Camera     Joystick     Joystick Analog     LCD Display     LED Button     LED Matrix     LED Strip     Potentiometer     ServoMotor      Electronics with CrowPi    Develop with Intellij IDEA     CrowPi examples      Community Implementations    Prototype Board     BMP280 Sensor      JBang Examples    Minimal Example     BME280 Sensor     Pixelblaze Output Expander      "},{"uri":"https://pi4j.com/getting-started/understanding-the-pins/","title":"Understanding the GPIO pins","tags":[],"description":"","content":"Connecting electronic components to the Pi is done via one or more of the pins in the so-called header. The number of pins has \u0026ldquo;grown\u0026rdquo; between the different Raspberry Pi board versions, but all recent ones have a 40-pin header. It\u0026rsquo;s of course important to be aware of the correct numbering to not correct components the wrong way.\nType of pins The pins have different uses\nPower and ground Both 5V and 3.3V are available as power pins and, of course, also ground pins. Anytime the board is powered you have a fixed power supply available for your components. You have to take into account not to connect devices that need a lot of current, otherwise the Raspberry Pi itself will not behave as expected and reboot for instance.\nDigital GPIO The other ones are \u0026ldquo;General-Purpose Input/Output\u0026rdquo; (GPIO) pins. These pins can be addressed with software to act as input or output for an application. They use 3.3V, meaning an output pin will be set to 0V (low) or 3.3V (high) and an input pin will read 0V as low and 3.3V as high.\nMost of the GPIOs have an internal pull-up or pull-down resistor which can be enabled in software.\nOverview The following image gives you an overview of the pins and types of a typical 40-pin header. Note the different numbers being used:\n PIN: 1 to 40 logical order of the pin BCM: the number to be used in your Java code to specify the GPIO to be used. BCM refers to the \u0026ldquo;Broadcom SOC channel\u0026rdquo; number, which is the numbering inside the chip which is used on the Raspberry Pi. These numbers changed between board versions as you can see in the previous tables for the 26-pin header type 1 versus 2, and or not sequential. WPI: WiringPi number which was used by V.1 of Pi4J. The WiringPi numbering has a \u0026ldquo;historical reason\u0026rdquo;. When development for the very first Raspberry Pi\u0026rsquo;s was ongoing, only 8 pin-numbers were foreseen. But, when the designs further evolved and more pins were added, the numbering in WiringPi was extended to be able to address the extra pins.  "},{"uri":"https://pi4j.com/pi4j-os/","title":"Pi4J Operating System","tags":["Pi4J OS"],"description":"","content":"Yes, Raspberry Pi OS is great! And we made if even more awesome by adding some \u0026ldquo;goodies\u0026rdquo; for Java developers! So, to be clear, Pi4J OS is not yet another OS. It\u0026rsquo;s the official Raspberry Pi OS, with additional tools and preconfigurations to make it the ideal OS for any Java developer who wants to use a Raspberry Pi.\nAdditional Feature on top of Raspberry Pi OS This project provides pre-built versions of OS images with all you need to develop 100% pure Java applications for specific Raspberry Pi setups. They are based on the latest official Raspberry Pi OS and are automatically built using Packer.\nBy using these images, you will get:\n Preconfigured locale (en_US), keyboard (US) and timezone (Europe/Zurich). Preconfigured wireless country (Switzerland) by default. Remote management via SSH and VNC enabled by default. Preinstalled OpenJDK 17 with latest JavaFX 20. Starter script to launch JavaFX-apps in DRM (aka kiosk-mode). Preconfigured /boot/config.txt supporting all components out of the box. Dynamic wallpaper showing Ethernet/WLAN address and hostname. User account pi, password pi4j.  You have to set the corresponding preferences in Raspberry Pi Imager.   Default WLAN connection.  Setup a hotspot, for example on your smartphone, and you are ready to go.  SSID: Pi4J-Spot. Password: MayTheSourceBeWithYou!.   Your laptop has to be in the same WLAN as the Rasperry Pi.    Available Flavors Pi4J-Basic-OS  Support for building 100% pure Java applications using Pi4J, JavaFX Can be used for all kind of Pi4J- , or JavaFX-projects Use Pi4J Component Catalogue and corresponding GitHub project to experiment with popular hardware components attached to your RaspPi. Use RaspiFX template project to start your own JavaFX/Pi4J or plain Pi4J project  Download latest release of Pi4J-Basic-OS Image\nPi4J-CrowPi-OS  All of Pi4J-Basic-OS Support for CrowPi Comes with lirc preinstalled to run the IR receiver component Use CrowPi template project to start your CrowPi experiments  Download latest release of Pi4J-CrowPi-OS\nPi4J-Picade-OS  All of Pi4J-Basic-OS Support for Picade Console and Picade X HAT USB-C Use link:[FXGL template project] to start your Picade project (available soon)  Download latest release of Pi4J-Picade-OS\nTable of content of the \u0026ldquo;Pi4J OS\u0026rdquo; section  Prepare SD with Pi4J OS     Test Pi4J Basic OS     Test Pi4J Picade OS     "},{"uri":"https://pi4j.com/architecture/","title":"Architecture/Design","tags":[],"description":"","content":"The code of Pi4J is based on a layered approach, visualized in the picture below.\nSince Pi4J is a low-level library, it tries to avoid inheriting third-party libraries at all costs. More complex dependency chains make it more difficult for users, especially novice users. Therefor, the only dependency Pi4J V.2 has is SLF4J to provide a standardized and extensible logging framework.\nThe dark grey blocks \u0026ldquo;Annotation Engine\u0026rdquo;, \u0026ldquo;@Register\u0026rdquo; and \u0026ldquo;@Inject\u0026rdquo; are here as a future idea but are not included in the current V2.\n"},{"uri":"https://pi4j.com/getting-started/electricalengeneering/","title":"Electrical Engineering","tags":[],"description":"","content":"Resistor dimensioning Resistors can be used for different effects. One application is to improve the stability of the application with PullUp and PullDown resistors. Another application is to use resistors to protect the PI against voltage peaks or short circuit currents.\nPullUp PullDown In electronic logic circuits, a pull-up resistor or pull-down resistor is a resistor used to ensure a known state for a signal. It is typically used in combination with components such as switches and transistors, which physically interrupt the connection of subsequent components to ground or to VCC. Closing the switch creates a direct connection to ground or VCC, but when the switch is open, the rest of the circuit would be left floating (i.e., it would have an indeterminate voltage).\nFor a switch that is used to connect a circuit to VCC (e.g., if the switch or button is used to transmit a \u0026ldquo;high\u0026rdquo; signal), a pull-down resistor connected between the circuit and ground ensures a well-defined ground voltage (i.e. logical low) across the remainder of the circuit when the switch is open. For a switch that is used to connect a circuit to ground, a pull-up resistor (connected between the circuit and VCC) ensures a well-defined voltage (i.e. VCC, or logical high) when the switch is open.\nThe size of the resistor can vary between 1kOhm and 100kOhm. Here it is necessary to weigh what is useful for the application. The closer the resistor is to 0, the stronger the level is defined, but the greater the current consumption in the open state. The higher the resistance, the less current is consumed in the off state, but the more unstable the signal becomes. For a start value PullUp and PullDown resistors with 10kOhm are to be used.\n    PullUp Pull Down Breadboard\n      PullUp electrical drawing\n      PullDown electrical drawing\n                               Voltage divider If components have a lower operating voltage than the 3.3V of the Raspberry Pi, a voltage divider can be used to achieve the desired voltage. For example, a red LED has an operating voltage of 1.8V. This means that 1.5V must drop across a second load. If we assume that the LED needs 20mA of current, this means that we should connect a resistor of 75 Ohm in series to the LED.\nIf the required current and the required voltage of the load are known, the exact required resistance can be calculated here.\n    Voltage Divider Breadboard\n      Voltage Divider electrical drawing\n    3.3V \u0026lt;\u0026ndash;\u0026gt; 5V level shifter To protect the Pi from 5V devices, a level shift/conversion can be done with the \u0026ldquo;Adafruit TXB0104 Bi-Directional Level Shifter\u0026rdquo; component. The bi-directional level shifter works for an I2C bus, for a TTL serial connection, for a slow \u0026lt;2MHz SPI connection and any other digital interface both uni- and bidirectional.\n    Logic Level Converter\n    Additional power supply If one or more large loads are required for the project, it may be necessary to use an additional power supply. A solution for this is the Mini Power Supply Module HW-131 Breadboard Power Module which provides two voltages 3.3V and 5V and a maximum output current of 700mA.\n    Mini Power Supply Module\n      Mini Power Supply Module Front Back\n    Do not use the USB port of the computer to power the electronics. Errors in the wiring can destroy the USB port of the computer.\n In case of an additional power supply, the ground of the Raspberry Pi and the ground of the power supply must be connected to each other.\n Breadboard Here is a short video that explains the basics of breadboards.    Breadboard\n    The red and blue lines on the side show which pins are connected. Be aware that red and blue can also be swapped, because not all suppliers use them in the same position.\nOn some boards these lines are interrupted in the middle (see picture breadboard). This means at this point, the pins are interrupted and not electrically connected.\n Soldering tutorial Here is a short video that explains the basics of soldering.\nHere is a short video that explains how to remove solder.\nIf a breakout with two pin headers like the TXB0104 is used, the pin headers can be mounted on the breadboard first, then the breakout is placed on the pin headers and finally everything can be soldered. So the pin headers are mounted exactly in 90° angle to the breakout and can be mounted on the breadboard without any problem.\n     Soldering Two Pins Part 1\n      Soldering Two Pins Part 2\n    Automatic wire stripper Here is a short video that explains how the automatic wire stripper works.\n    Automatic Wire Stripper\n    Crimping tutorial Here is a short video that explains the basics of crimping wires.\n    Crimping Tool\n    If the crimp connection does not hold, the following measures can lead to a better connection: - Strip wire to double length, lay on top of each other and twist (see picture below) - The crimping tool is too short, crimp the sleeve twice in different places (see picture below)\n     Strip double length\n      Crimping step 1\n      Crimping step 2\n      Crimping step 3\n      Crimping step 4\n    Crimping ferrules tutorial Here is a short video that explains the basics of crimping ferrules to wires.\n    Crimping Ferrules Tool\n    "},{"uri":"https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/","title":"Java development with VSC","tags":["Visual Studio Code"],"description":"","content":"Java on the Raspberry Pi To use Pi4J V.2 you\u0026rsquo;ll need Java 11 or newer. Luckily this version is included in the current version of Raspberry Pi OS. In the release notes you can see that the version of 2019-06-20 includes OpenJDK Java 11:\n2019-06-20: Based on Debian Buster Oracle Java 7 and 8 replaced with OpenJDK 11 But you will need to keep in mind this version is only compatible with ARMv7 or higher and doesn\u0026rsquo;t support all Raspberry Pi board versions. If you have a Raspberry Pi A (version 3), B (version 2 or higher), or Compute (version 3 or higher), you are good to go! For all other boards you will need some additional steps that are described on \u0026ldquo;Java for ARMv6/7/8\u0026rdquo;.\nIf you prepared a microSD card with the latest version of Raspberry Pi OS (full version), as described on \u0026ldquo;Set up a new Raspberry Pi\u0026rdquo;, you can check the installed Java version in the terminal. On a board with ARMv7 or ARMv8 you will get this result:\n$ java -version openjdk version \u0026#34;11.0.3\u0026#34; 2019-04-16 OpenJDK Runtime Environment (build 11.0.3+7-post-Raspbian-5) OpenJDK Server VM (build 11.0.3+7-post-Raspbian-5, mixed mode) If you get an error like below, you\u0026rsquo;ll need to follow the steps described on \u0026ldquo;Java for ARMv6/7/8\u0026rdquo;.\n$ java -version Error occurred during initialization of VM Server VM is only supported on ARMv7+ VFP Maven Pi4J is using Maven as build tool, this allows you to compile your code with the required modules into JAR-file thanks to the pom.xml configuration file which you can find in the root of a project. We need to install Maven and can do this with a single command, after which we can immediately check the installation by requesting the version:\n$ sudo apt install maven $ mvn -v Apache Maven 3.6.0 Maven home: /usr/share/maven Visual Studio Code Visual Studio Code (VSC) is the free IDE (Integrated Developer Environment) by Microsoft. It\u0026rsquo;s designed as a universal tool that you can use for multiple programming languages with extensions. On your Raspberry Pi open a web browser, go to the \u0026ldquo;VSC Download page (code.visualstudio.com/Download)\u0026quot; and select the \u0026ldquo;Linux .deb ARM\u0026rdquo; version.\n    Download page for VSC\n      VSC in the list of programming tools\n      VSC running on the Raspberry Pi with Maven and Java Extension Pack\n                               When the download is finished, open a terminal, go to the Download directory and install the downloaded deb-file like this:\n$ cd /home/pi/Downloads $ sudo apt install ./code_1.53.0-1612367698_armhf.deb Since 02/2021 there is even an easier way, as Visual Studio Code is now available as a Raspberry Pi OS apt package. Use the following commands:\n$ sudo apt update $ sudo apt install code -y "},{"uri":"https://pi4j.com/architecture/about-the-code/maven-settings/","title":"Maven settings","tags":[],"description":"","content":"To simplify development but not commit sensitive information, you can add personal or PC-specific settings in the Maven settings.xml file. This file is stored or needs to be created in the \u0026ldquo;.m2\u0026rdquo; directory in your home directory:\n Windows: C:\\Users\\YOUR_NAME.m2 Linux: /home/YOUR_NAME/.m2 Mac: /Users/YOUR_NAME/.m2  For more info see this article on Baeldung.\nThis is an example settings file, including settings for compiling of Pi4J and credentials to upload the generated code to a Raspberry Pi.\n\u0026lt;settings xmlns=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/SETTINGS/1.0.0 https://maven.apache.org/xsd/settings-1.0.0.xsd\u0026quot;\u0026gt; \u0026lt;localRepository/\u0026gt; \u0026lt;interactiveMode/\u0026gt; \u0026lt;offline/\u0026gt; \u0026lt;pluginGroups/\u0026gt; \u0026lt;servers/\u0026gt; \u0026lt;mirrors/\u0026gt; \u0026lt;proxies/\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;pi4j\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;!-- Docker compiler settings --\u0026gt; \u0026lt;pi4j.native.compiler\u0026gt;DOCKER-COMPILER\u0026lt;/pi4j.native.compiler\u0026gt; \u0026lt;!-- SSH credentials of your test Raspberry Pi --\u0026gt; \u0026lt;pi4j.dev.transfer\u0026gt;false\u0026lt;/pi4j.dev.transfer\u0026gt; \u0026lt;pi4j.dev.host\u0026gt;192.168.1.1\u0026lt;/pi4j.dev.host\u0026gt; \u0026lt;pi4j.dev.port\u0026gt;22\u0026lt;/pi4j.dev.port\u0026gt; \u0026lt;pi4j.dev.user\u0026gt;pi\u0026lt;/pi4j.dev.user\u0026gt; \u0026lt;pi4j.dev.password\u0026gt;raspberry\u0026lt;/pi4j.dev.password\u0026gt; \u0026lt;pi4j.dev.directory\u0026gt;/home/pi/pi4j-temp\u0026lt;/pi4j.dev.directory\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;activeProfiles\u0026gt; \u0026lt;activeProfile\u0026gt;pi4j\u0026lt;/activeProfile\u0026gt; \u0026lt;/activeProfiles\u0026gt; \u0026lt;/settings\u0026gt; "},{"uri":"https://pi4j.com/documentation/pin-numbering/","title":"Pin numbering","tags":[],"description":"","content":"Pi4J V.1 took a pretty opinionated approach to pin numbering as the scheme was based on the underlying WiringPi. This scheme was incompatibility with other pin diagrams and pin numbering used by other development platforms and libraries.\nAs Pi4J V.2 is build as a \u0026ldquo;pass thru library\u0026rdquo;, and uses PiGpio as the underlying framework, the more well-known BCM numbering is being used now.\nThis drawing shows the different numbers for WiringPi and BCM in a 40-pins Raspberry Pi header:\n"},{"uri":"https://pi4j.com/about/release-notes/","title":"Release Notes","tags":[],"description":"","content":"All releases of Pi4J V.2 are listed on github.com/Pi4J/pi4j-v2/releases.\n2023-02-06 - V2.3.0  Improvements for PIGPIO.gpioCfgInterfaces by @bwaldvogel. New i2c interface to support multibyte register address by @taartspi. Fix in LinuxFsI2C byte array offset by @harlanhu. Remove unused JNA references by @taartspi.  2022-10-17 - V2.2.1 Multiple fixes by @taartspi:\n Better error message when mixing 32- and 64-bit artifacts SPI improvements:  Add missing initialization in constructor Track weather the user set the mode or bus config values to improve the use of SPI flags    2022-08-30 - V2.2.0 What an amazing achievement! No major issues were found in the previous release, but several small fixes were added by more people than ever before in the Pi4J-history. This is a real confirmation of the openness of this project and how a community can work together to further improve a project.\nA big thank you to everyone who experimented with Pi4J, took part in the discussions, filed an issue, created a merge request, added examples,\u0026hellip;!\nNew example implementations Thanks to the work of FHNW students and @taartspi, the list of available example implementations has become larger and larger. We even moved them to their own section of this documentation website! Take a look at Example implementations if you need a quick-start to use a buzzer, camera, LED strip, TCA9548, MCP4725,\u0026hellip; or any of the other examples.\nChanges in V2.2.0 Multiple improvements were added in this release (and others are already in progress for the next one!):\n by @taartspi to improve SPI initialization, see #229 by @haumacher regarding the use of ByteBuffers, see #185 by @savageautomate regarding the polarity of digital output, see #93 by @gugrim to ensure positive values are returned from reading unless at end of file, see #164 by @eitch to also export LinuxFS I2C in module-info.java by @eitch to also copy native libs to distribution zip by @hagen to be able to configure sample rate and peripheral in PiGpio by Saskia Bikle to add an implementation of deregistration/shutdown for IO\u0026rsquo;s by @savageautomate to add a new value \u0026ldquo;flags\u0026rdquo; too SPI implementation  All the differences can be checked by comparing with the previous release 2.1.1 via this link.\nEarlier release notes Release notes of the previous releases of Pi4J V.2 are available on github.com/Pi4J/pi4j-v2/releases.\n"},{"uri":"https://pi4j.com/pi4j-os/test-pi4j-picade-os/","title":"Test Pi4J Picade OS","tags":["Pi4J OS"],"description":"","content":"Pi4J Picade OS contains an additional Test and the audio test should use the internal loudspeaker.\nCompile the JavaFX application\ncd /home/pi/java-examples/pure-picade javac --module-path /opt/javafx-sdk/lib --add-modules=javafx.controls,javafx.media hellopicade/HelloPicade.java To start HelloPicade in X11-Mode\nDISPLAY=:0 XAUTHORITY=/home/pi/.Xauthority sudo -E java --module-path /opt/javafx-sdk/lib --add-modules javafx.controls,javafx.media -Dglass.platform=gtk hellopicade.HelloPicade To start HelloPicade in DRM\nsudo java-kiosk hellopicade.HelloPicade Check the mapping of the Picade buttons to JavaFX KeyCodes:\n   Picade KeyCode     Joystick up KeyCode.UP   Joystick down KeyCode.DOWN   Joystick left KeyCode.LEFT   Joystick right KeyCode.RIGHT   right side black button KeyCode.ENTER   left side black button KeyCode.ESCAPE   all other buttons no mapping    "},{"uri":"https://pi4j.com/getting-started/developing-on-a-remote-pc/","title":"Developing on a remote PC","tags":["Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-maven-archetype\n Developing Java programs using a remote PC workstation Writing your Java program, compiling and running it directly on the Raspberry Pi board as shown in the previous chapter is perfectly fine, of course, but there is an alternative way to arrange your developing laboratory, using a normal desktop computer as Remote Developing Workstation (RDW).\nThis Maven Archetype will give you a tool to generate Pi4J V.2 skeleton Java projects. You can use it for your next Pi4j project and you will be able to develop your program on the remote workstation (RDW), compile them, transmit the executable code on the target Pi board and run it. You can also start a remote debugging session.\nThere are some pros. and cons. in such a developing arrangement:\n Pros:  Your RDW has much more resources like memory, disk capacity and CPU power than a Raspberry Pi, and this is true for a P4 model too. You can store all your programs in the desktop computer. You do not have to install on the Raspberry Pi the Visual Studio Code (or your preferred IDE program), the Java JDK (JRE it is enough), Maven and the other development tools. You do not need to connect the screen, the keyboard and the mouse to the Raspberry Pi You can use smaller PI models   Cons:  You can\u0026rsquo;t run Web applications (using a web container like Tomcat or similar)    Setting up Configure the RPi for Headless mode The Headless Mode configuration enables the RPi board to communicate with the RDW over SSH protocol.\nThese are the needed steps:\n Check if the RDW is equipped with a SSH Client. If the RDW OS is Linux you already have it For Windows you can use putty, MobaXterm or you can enable the (new) OpenSsh Client porting on Windows 10 Connect both the RPi and RDW to your local network Follow this guide to configure your RPi Install the Maven tool on the RDW  You should now be able to open a SSH Terminal window on RDW and to remotely login on the RPi board.\nInstall the raspimaven-archetype Goto the Github Pi4J Project and download the project clicking on the green Code button and selecting Download ZIP\n Unzip the archetype file in a FOLDER cd FOLDER/pi4j-maven-archetype-master mvn install  Congratulation ! - Now you are ready to generate your first Project Template\nGenerate a new Project Template Let suppose you want to begin the new wonderful PI4J V.2 project my-project, to do this follow these steps:\n mkdir my-project cd my-project mvn archetype:generate -DarchetypeCatalog=local answer to the questions the archetype asks you (see below for details)  Configuring your new project Before starting the new project generation, the archetype asks some configuration data. The list of question and the replies are shown here below:\n Choose archetype: select the raspimaven-archetype from the list proposed Define value for property \u0026lsquo;groupId\u0026rsquo;: choose the Maven groupId for your project. (If don\u0026rsquo;t know what is a groupId, don\u0026rsquo;t worry, just type \u0026ldquo;com.example\u0026rdquo; for now) Define value for property \u0026lsquo;artifactId\u0026rsquo;: choose a name for the program executable your project will produce Define value for property \u0026lsquo;version\u0026rsquo;: 1.0-SNAPSHOT: type Enter to accept the default value shown, or type the initial program version, something like 1.0.0 Define value for property \u0026lsquo;package\u0026rsquo;: com.example: type Enter to accept the default value shown  The archetype now shows you a summary of the configuration parameters you have just typed in, plus the values proposed for the main-class and package parameters. If the list is ok for you, reply Y to accept, otherwise reply N to change one or more values (you will have to re-type all parameter values \u0026hellip;)\nAfter the list confirmation, the archetype generates a new maven project template for you.\nCongratulations\nYou should be able to open the new project with your preferred java IDE. The IDE should be able to recognize the project as a valid Maven project.\nNote on the Java runtime If you are not using the default Raspberry Pi OS full edition and/or included Java, you may get this kind of error:\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-antrun-plugin:3.0.0:run (exec) on project ...: An Ant BuildException has occured: The following error occurred while executing this line: [ERROR] ...\\antrun\\build.xml:166: The following error occurred while executing this line: [ERROR] ...\\antrun\\build.xml:123: Remote command failed with exit status 1 [ERROR] around Ant part ...... @ 9:59 in ...\\antrun\\build-main.xml This can be caused by a mis-configured Java runtime. The default value in raspberry.properties is:\ntarget.remote.jre=/usr/lib/jvm/default-java Check if this value exists and links to your Java runtime, or find the location of your installed JDK with sudo find / -iname java and use the result in your configuration.\nFor instance: a Raspberry Pi Zero (type 1) with ARMv6 requires a specific Java version for this type of processor. This is described more in detail on \u0026ldquo;Java for ARMv6/7/8\u0026rdquo;. If you use Azul Zulu JDK, you will need to change the configuration to:\ntarget.remote.jre=/usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf Explore the new project template Feel free to explore the new project familiarizing with the folder structure. These are the most important features:\n The file README.md contains the intruction to configure the connection(s) to your RPi board(s) and the decription of the Maven commands to build your project, transfer the executable code to the target RPi, run it and also open a debugger session. The pom.xml file already includes the dependencies needed to compile your program with the Pi4J V.2 libraries. The platform folder contains an example configuration file for connecting to you RPi board. Read the README.md explanation, open the platform/raspberry.properties file (or copy it to a new file) and edit it to describe how to connect to your RPi   Thanks to Adi and Luca Buraggi for this contribution.\n"},{"uri":"https://pi4j.com/about/download/","title":"Pi4J Downloads","tags":[],"description":"","content":"All downloads provided by the project can be found on pi4j.com/download.\nThe compiled artifacts (releases and snapshots) are available in the Sonatype Maven repository.\n"},{"uri":"https://pi4j.com/kotlin/","title":"Pi4J Kotlin DSL","tags":[],"description":"Pi4J Kotlin DSL &amp; API Example &amp; Documentation","content":"Pi4J-Kotlin (aka Pi4K) is an implementation on top of Pi4J to facilitate the development of Kotlin applications for the Raspberry Pi that can interact with the GPIOs.\nKotlin makes extensive use of Domain Specific Language (DSL) to provide APIs that are cleaner, easier to read, and more structured. The DSLs provided here on top of Pi4J make it very easy to use this library in a Kotlin application. These Kotlin DSLs don\u0026rsquo;t introduce added runtime overhead of a new layer when used. DSL builders are always inlined on Compile-Time.\nInstallation Install the Pi4J dependency and pi4j-ktx in your app\u0026rsquo;s build.gradle.ktx file:\ndependencies { implementation(\u0026#34;com.pi4j:pi4j-ktx:2.4.0\u0026#34;) // Kotlin DSL  implementation(\u0026#34;com.pi4j:pi4j-core:2.3.0\u0026#34;) implementation(\u0026#34;com.pi4j:pi4j-plugin-raspberrypi:2.3.0\u0026#34;) implementation(\u0026#34;com.pi4j:pi4j-plugin-pigpio:2.3.0\u0026#34;) } If you want to use the Console DSL to log with SLF4J, add the dependency:\nimplementation(\u0026#34;org.slf4j:slf4j-api:1.7.32\u0026#34;) implementation(\u0026#34;org.slf4j:slf4j-simple:1.7.32\u0026#34;) GitHub projects:  Kotlin Interface \u0026amp; DSL for Pi4J V2: Pi4J-Kotlin For Pi4J V1 Kotlin Bindings, check Pi4K  "},{"uri":"https://pi4j.com/kotlin/minimal-kotlin-example/","title":"Minimal Kotlin Pi4J example","tags":[],"description":"Pi4J Kotlin DSL &amp; API Example","content":" Full Example on GitHub: https://github.com/Pi4J/pi4j-kotlin/blob/master/example/src/main/kotlin/MinimalExample.kt\n For full documentation, visit the Kotlin Docs\n This is a minimal working example, make sure to check it out from the link above for the full introduction and comments.\nIt does exactly the same functionality of the Minimal Example using the Java API:\n The application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.\n   Wiring This minimal example application uses this wiring:\nCode const val PIN_BUTTON = 24 // PIN 18 = BCM 24 const val PIN_LED = 22 // PIN 15 = BCM 22 var pressCount = 0 console { title(\u0026#34;\u0026lt;-- The Pi4J Project --\u0026gt;\u0026#34;, \u0026#34;Minimal Example project\u0026#34;) pi4j { digitalInput(PIN_BUTTON) { id(\u0026#34;button\u0026#34;) name(\u0026#34;Press button\u0026#34;) pull(PullResistance.PULL_DOWN) debounce(3000L) piGpioProvider() }.onLow { pressCount++ +\u0026#34;Button was pressed for the ${pressCount}th time\u0026#34; } } digitalOutput(PIN_LED) { id(\u0026#34;led\u0026#34;) name(\u0026#34;LED Flasher\u0026#34;) shutdown(DigitalState.LOW) initial(DigitalState.LOW) piGpioProvider() }.run { while (pressCount \u0026lt; 5) { +\u0026#34;LED ${state()}\u0026#34; toggle() Thread.sleep((500L / (pressCount + 1))) } } } } } Building \u0026amp; Running the application You can simply run the example app using gradle on the target device (Raspberry Pi for example):\n./gradlew :example:run "},{"uri":"https://pi4j.com/blog/","title":"Blogs","tags":[],"description":"","content":"Some tutorials, experiments, etc. don\u0026rsquo;t fit in the documentation part of this site. These are shared in this section as blog posts.\n Pi4J Operating System     LED strip with Pi4J and JBang     Kotlin on the Raspberry Pi     Getting Started Template     "},{"uri":"https://pi4j.com/kotlin/kotlin-api-docs/","title":"Kotlin API &amp; DSL Documentation","tags":[],"description":"Pi4J Kotlin DSL &amp; API Documentation","content":" Here you can find the provided APIs and the dead-simple DSLs of the Kotlin package.\n Components Context To create a new Pi4J context, use the pi4j function. It creates a new auto Context object and uses it as a receiver for your lambda:\npi4j { // You have access to a newly created auto context  describe() } You don\u0026rsquo;t need to call shutdown(), it\u0026rsquo;s called automatically at the end of the block.\nYou can think of the pi4j block as your entire routine/ program.\nCustom Context You can build a custom context using the buildContext function:\nval ctx = buildContext { +MockPlatform() // add a platform to our context  +MockPwmProvider.newInstance() // add a provider to our context  +File(\u0026#34;tmp.txt\u0026#34;) // add a file property  +(\u0026#34;key\u0026#34; to \u0026#34;value\u0026#34;) // add a String property } You can add other properties the same way like InputStream, Reader, and Properties instances.\nGenerics You can also have access to Context properties using generics and type safe methods:\ncontext.run { hasPlatform\u0026lt;T\u0026gt;() // equivalent to Context::hasPlatform(Type::class.java)  hasProvider\u0026lt;T\u0026gt;() // equivalent to Context::hasProvider(Type::class.java)  provider\u0026lt;T\u0026gt;() // equivalent to Context::provider(Type::class.java) }  I/O You can easily create and configure I/O pins using this DSL\nDigital I/O From any Context object you can create I/O instances using:\ndigitalInput(address = 24) { name(\u0026#34;Button\u0026#34;) pull(PullResistance.PULL_DOWN) debounce(3000L) } digitalOutput(22) { name(\u0026#34;LED Flasher\u0026#34;) initial(DigitalState.LOW) } Using this DSL you get access to convenient functions like:\ndigitalInput(24).run { listen { // listens on state changes  val currentState = it.state() } onLow { // fires when state changes to DigitalState.LOW  } onHigh { // fires when state changes to DigitalState.High  } if (isLow) { // you get isLow property  } if (isHigh) { // you get isHigh property  } } Also, when you need to specify a provider for the pin you\u0026rsquo;re creating you can use these 2 safe providers:\ndigitalOutput(22) { mockProvider() // uses the mock provider  piGpioProvider() // uses the pi_gpio provider } Analog I/O There are common APIs between Analog I/O and Digital I/O like:\nanalogInput(address = 24) { name(\u0026#34;Button\u0026#34;) mockProvider() // uses the mock provider  piGpioProvider() // uses the pi_gpio provider }.run { listen { // listens on value changes  val currentValue = it.value() } } However, Analog I/O get their own unique treats:\nanalogOutput(24).run { whenInRange(0..5) { // fires when value is in the supplied range  } whenOutOfRange(0..5) { // fires when value is not in the supplied range  } onMin(0..5) { // fires when value changes to the minimum of the range  } onMax(0..5) { // fires when value changes to the maximum of the range  } } PWM PWM has its share of love as well:\npwm(address = 24) { frequency(10_000) dutyCycle(40) mockProvider() // uses the mock provider  piGpioProvider() // uses the pi_gpio provider }  Console Using the console function, you can create a Console object and use it to print output to the console:\nconsole { +\u0026#34;This will be printed as a new line\u0026#34; box(\u0026#34;This will be printed inside a box\u0026#34;) +\u0026#34;Another line because I really like it\u0026#34; } You also get other helper functions found in the Minimal Example like printLoadedPlatforms, printDefaultPlatform , printProviders, and printRegistry.\n Platform There are some convenient functions added to the Platform API\nGenerics context.platform\u0026lt;MockPlatform\u0026gt;().run { hasProvider\u0026lt;T\u0026gt;() // equivalent to Platform::hasProvider(Type::class.java)  provider\u0026lt;T\u0026gt;() // equivalent to Platform::provider(Type::class.java)  createFrom\u0026lt;IO\u0026gt;(IOConfig\u0026lt;*\u0026gt;) // equivalent to Platform::create(IOConfig\u0026lt;*\u0026gt; ,IO::class.java)  createFrom\u0026lt;IO\u0026gt;(String) // equivalent to Platform::create(String ,IO::class.java) } "},{"uri":"https://pi4j.com/kotlin/coroutines/","title":"Coroutines Support","tags":[],"description":"Coroutines for Pi4J -Kotlin","content":"pi4jAsync Same with the pi4j DSL, you can create a pi4j block to execute within a CoroutineScope using the pi4jAsync DSL.\npi4jAsync { delay(100) // suspended call  describe() } Inside pi4jAsync you have access to a newly created auto context and you can run your code in the provided CoroutineScope.\nCustom CoroutineScope You can also use a custom CoroutineScope instance.\npi4jAsync(CoroutineScope(Dispatchers.Default)) { delay(100) // suspended call  describe() } Minimal Example with Coroutines This is a the same as the minimal example, but leveraging Kotlin\u0026rsquo;s Coroutines\n private const val PIN_BUTTON = 24 // PIN 18 = BCM 24 private const val PIN_LED = 22 // PIN 15 = BCM 22 private var pressCount = 0 pi4jAsync { console { digitalInput(PIN_BUTTON) { id(\u0026#34;button\u0026#34;) name(\u0026#34;Press button\u0026#34;) pull(PullResistance.PULL_DOWN) debounce(3000L) piGpioProvider() }.onLow { pressCount++ +\u0026#34;Button was pressed for the ${pressCount}th time\u0026#34; } digitalOutput(PIN_LED) { id(\u0026#34;led\u0026#34;) name(\u0026#34;LED Flasher\u0026#34;) shutdown(DigitalState.LOW) initial(DigitalState.LOW) piGpioProvider() }.run { while (pressCount \u0026lt; 5) { +\u0026#34;LED ${state()}\u0026#34; toggle() delay(500L / (pressCount + 1)) } } } } "},{"uri":"https://pi4j.com/kotlin/i2c/","title":"I²C Kotlin DSL","tags":[],"description":"I²C DSL Pi4J-Kotlin","content":" Feel free to checkout the Pi4J docs on I²C\n Installation Add LinuxFs dependency\ndependencies { implementation(\u0026#34;com.pi4j:pi4j-plugin-linuxfs:2.3.0\u0026#34;) } I²C DSL i2c(1, 0x3f) { id(\u0026#34;TCA9534\u0026#34;) linuxFsI2CProvider() }.use { tca9534Dev -\u0026gt; // use here. Will auto close } Writing i2c(1, 0x3f) { id(\u0026#34;TCA9534\u0026#34;) linuxFsI2CProvider() }.use { tca9534Dev -\u0026gt; val newState = tca9534Dev.setPin(currentState, pin = 8, TCA9534_REG_ADDR_OUT_PORT) } Minimal I²C Example This is the Kotlin DSL version of the same I²C example here, but leveraging the Kotlin DSL\n private const val TCA9534_REG_ADDR_OUT_PORT: Int = 0x01 private const val TCA9534_REG_ADDR_CFG: Int = 0x03 fun main() { pi4j { i2c(1, 0x3f) { id(\u0026#34;TCA9534\u0026#34;) linuxFsI2CProvider() }.use { tca9534Dev -\u0026gt; val config = tca9534Dev.readRegister(TCA9534_REG_ADDR_CFG) check(config \u0026gt;= 0) { \u0026#34;Failed to read configuration from address 0x${\u0026#34;%02x\u0026#34;.format(TCA9534_REG_ADDR_CFG)}\u0026#34; } var currentState = tca9534Dev.readRegister(TCA9534_REG_ADDR_OUT_PORT) if (config != 0x00) { println( \u0026#34;TCA9534 is not configured as OUTPUT, setting register 0x${\u0026#34;%02x\u0026#34;.format(TCA9534_REG_ADDR_CFG)}to 0x00\u0026#34; ) currentState = 0x00 tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, currentState) tca9534Dev.writeRegister(TCA9534_REG_ADDR_CFG, 0x00) } tca9534Dev.run { // bit 8, is pin 1 on the board itself, so set pins in reverse:  console { currentState = setPin(currentState, 8, TCA9534_REG_ADDR_OUT_PORT) +\u0026#34;Setting TCA9534 to new state ${currentState.binStr()}\u0026#34; sleep(500L) currentState = setPin(currentState, 8, TCA9534_REG_ADDR_OUT_PORT, false) +\u0026#34;Setting TCA9534 to new state ${currentState.binStr()}\u0026#34; sleep(500L) currentState = setPin(currentState, 7, TCA9534_REG_ADDR_OUT_PORT) +\u0026#34;Setting TCA9534 to new state ${currentState.binStr()}\u0026#34; sleep(500L) currentState = setPin(currentState, 7, TCA9534_REG_ADDR_OUT_PORT, false) +\u0026#34;Setting TCA9534 to new state ${currentState.binStr()}\u0026#34; sleep(500L) } } } } } "},{"uri":"https://pi4j.com/architecture/about-the-code/code-styling/","title":"Code styling","tags":[],"description":"","content":"To prevent unnecessary code (tabs versus spaces, number of characters per line\u0026hellip;) we have defined an editorconfig for IntelliJ IDEA. You can find more info here about its use.\nSome tips to keep the code clean and readable:\n Short methods with a clear name Use SonarLint to get improvement tips while code Use shortcuts  CTRL+ALT+L: Reformat code CTRL+ALT+O: Optimize imports    "},{"uri":"https://pi4j.com/examples/components/","title":"Component Examples","tags":[],"description":"","content":"The FHNW University contributed a full project with example implementations of the following devices.\nCurrent available components    Device(s) Developed by Link     Simple Button Reto Stutz, Mike Schoder Example Devices   Simple LED Reto Stutz, Mike Schoder Example Devices   AD Converter ADS1115 Reto Stutz, Mike Schoder Example Devices   Buzzer Reto Stutz, Mike Schoder Example Devices   Camera Reto Stutz, Mike Schoder Example Devices   Joystick Reto Stutz, Mike Schoder Example Devices   Joystick Analog Reto Stutz, Mike Schoder Example Devices   LCD Display Reto Stutz, Mike Schoder Example Devices   LED Button Reto Stutz, Mike Schoder Example Devices   LED Matrix Reto Stutz, Mike Schoder Example Devices   LED Strip Reto Stutz, Mike Schoder Example Devices   Potentiometer Reto Stutz, Mike Schoder Example Devices   ServoMotor Reto Stutz, Mike Schoder Example Devices    Simple Implementation For a Simple Implementation, the recommendation is to use the Launcher Class. With this, a simple application can be started.\nElectrical Engineering General inputs and help on electrical engineering can be looked up on Getting started with PI4J / Electrical Engineering page.\n"},{"uri":"https://pi4j.com/featured-projects/","title":"Featured Projects","tags":[],"description":"","content":" Did you use Pi4J in one of your projects? We would love to hear from you!  Please let us know by sending an e-mail to frank at pi4j.com with a brief description, URL, links and pictures of the product or project you are working on.\n   Soft real time PLC  Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available. Conveyors for containers filled by a dispensing robot\n PiJukeBox  Daniel Mårtensson used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators. Features: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi\u0026rsquo;s, terminal based.\n Cocktail Maker  The CocktailMaker is a cocktail mixing machine by Alexander Liggesmeyer. It can control as many pumps as the RaspberryPi provides GPIO pins. For every pump that gets added to the system, the user has to provide the amount of time that that pump needs to pump one centiliter in milliseconds. The machine uses peristaltic pumps. So that number is perfectly accurate. The flow rate won\u0026rsquo;t vary over time. It uses a relay board for closing the electronic circuit for all pumps.\n Didier the street artist robot  Meet \u0026ldquo;Didier\u0026rdquo; the street artist robot, a project by Duvam. The sources are shared on github.com/duvamduvam/didier-java.  JMonkeyEngine with Joystick  Pavl G. created a Java Gradle library to control a car in a JMonkeyEngine game with an arduino joystick module connected to a Raspberry Pi4 model B, using GPIO digital pins and SPI interfacing through MCP3008 ADC (Analog~Digital Converter). Requirements Raspberry Pi with arm processor (pi3, pi4, piZero) with a working java8 (preferred). Female-to-male jumper wires. Breadboard. Arduino Joystick module. MCP3008 IC (ADC \u0026ndash; other adcs may work too, but we are covering only MCP3008 here).\n Sensor drivers  In case you want to read the data from various I2C sensors connected to Raspberry Pi the difficult part is usually writing a piece of code which talks to the I2C sensor. rpi-drivers is a Java library implementing simple APIs and communication code for some widely used I2C sensors. You can easily measure temperature, pressure and humidity, get ambient light intensity or measure voltage in your java Raspberry Pi projects.\n  "},{"uri":"https://pi4j.com/architecture/about-the-code/hardware-testing/","title":"Hardware testing","tags":[],"description":"","content":" This is an experimental project which will need a lot of love\u0026hellip; The new Raspberry Pi Pico with a lot of GPIOs for a very low price, seems even to be a better fit for this project compared to the Arduino Due\u0026hellip; To be further investigated!\n To minimize the required time and efforts to test a new release, V.2 aims to include an automated test which performs I/O testing on each I/O interface on each model of RPi. Ideally this would happen as part of the unit testing sequence for each code commit or at least as part of the release cycle.\nTo achieve this, an Arduino Due board with lots of on board I/O capability is being used. The firmware that gets loaded onto the Arduino board listens on the serial port for instructions on which pins to use and what type of test to perform. The \u0026ldquo;Test Harness\u0026rdquo; project also includes a Java library that is used to communicate with the Arduino and instrument tests.\nNext, a given I/O provider plugin includes test classes that instrument the test harness and perform live I/O testing between the SBC (or other hardware) and the Arduino Test Harness.\nTo be able to fully test all board types, a custom PCB needs to be created to perform all the interconnects between the Raspberry Pi 26-pin/40-pin headers, and the Arduino board. This way enough test harnesses could be build for each Raspberry Pi model and have a permanent setup for on-demand testing. This of course is a huge effort just by itself, and perhaps too ambitious \u0026ndash; but seeking a means to reach automated testing is really needed for the long term.\n"},{"uri":"https://pi4j.com/documentation/java-installation/","title":"Java for ARMv6/7/8","tags":[],"description":"","content":" Raspberry Pi OS Full comes with Java 11 pre-installed. But this version only works on board-versions with an ARMv7 or ARMv8. In some cases you will need to do some additional steps to install a Java version which works on your board.\n Board versions With ARMv6 processor  Raspberry Pi 1 A and A+ Raspberry Pi 1 B and B+ Compute Module 1 Zero 1.2, 1.3 and W  With ARMv7 or ARMv8 processor  Model A+, version 3 Model B, version 2, 3 and 4 Compute Module, version 3  How to check and install Java Check the current version If you prepared a microSD card with the latest version of Raspbian OS (full version), Java is already installed! You can check the installed Java version in the terminal. On a board with ARMv7 or ARMv8 you will get this result:\n$ java -version openjdk version \u0026quot;11.0.3\u0026quot; 2019-04-16 OpenJDK Runtime Environment (build 11.0.3+7-post-Raspbian-5) OpenJDK Server VM (build 11.0.3+7-post-Raspbian-5, mixed mode) On an ARMv6 version, you will get an error:\n$ java -version Error occurred during initialization of VM Server VM is only supported on ARMv7+ VFP Check your board version If you are not sure which type of board you have, you can check this in the terminal with cat /proc/cpuinfo, for instance for a Raspberry Pi B+ 1.2:\n$ cat /proc/cpuinfo processor\t: 0 model name\t: ARMv6-compatible processor rev 7 (v6l) BogoMIPS\t: 697.95 Features\t: half thumb fastmult vfp edsp java tls CPU implementer\t: 0x41 CPU architecture: 7 CPU variant\t: 0x0 CPU part\t: 0xb76 CPU revision\t: 7 Hardware\t: BCM2835 Revision\t: 0010 Serial\t: 000000005f9ba615 Model\t: Raspberry Pi Model B Plus Rev 1.2 Install Java 11 on ARMv6 The sources for Java are available as open-source on OpenJDK, which means, if you can\u0026rsquo;t find the correct version for a specific board, it is possible to compile it yourself. Luckily there are different suppliers providing ready-made packages of the JDK for multiple platforms. But only Azul seems to have one which is a perfect fit for Raspberry Pi\u0026rsquo;s with an ARMv6: the Zulu community edition of JDK 11.\nTo get started with Zulu JDK, download and uncompress it to your board:\n$ cd /usr/lib/jvm $ sudo wget https://cdn.azul.com/zulu-embedded/bin/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ sudo tar -xzvf zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ sudo rm zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf.tar.gz $ ls -l total 12 lrwxrwxrwx 1 root root 21 Jul 23 15:58 java-1.11.0-openjdk-armhf -\u0026gt; java-11-openjdk-armhf drwxr-xr-x 9 root root 4096 Aug 20 11:41 java-11-openjdk-armhf drwxr-xr-x 2 root root 4096 Aug 20 11:41 openjdk-11 drwxrwxr-x 10 111 122 4096 Jul 10 16:50 zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf Now we have the JDK11 ready to be used, but it still needs to be configured so the OS is aware of it.\n$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java 1 $ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac 1 At this moment we can select the new JDK to link it to the “java” and “javac” command.\n$ sudo update-alternatives --config java There are 2 choices for the alternative java (providing /usr/bin/java). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/java-11-openjdk-armhf/bin/java 1111 auto mode 1 /usr/lib/jvm/java-11-openjdk-armhf/bin/java 1111 manual mode 2 /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java 1 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 2 update-alternatives: using /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/java to provide /usr/bin/java (java) in manual mode $ sudo update-alternatives --config javac There are 2 choices for the alternative javac (providing /usr/bin/javac). Selection Path Priority Status ------------------------------------------------------------ * 0 /usr/lib/jvm/java-11-openjdk-armhf/bin/javac 1111 auto mode 1 /usr/lib/jvm/java-11-openjdk-armhf/bin/javac 1111 manual mode 2 /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac 1 manual mode Press \u0026lt;enter\u0026gt; to keep the current choice[*], or type selection number: 2 update-alternatives: using /usr/lib/jvm/zulu11.41.75-ca-jdk11.0.8-linux_aarch32hf/bin/javac to provide /usr/bin/javac (javac) in manual mode Now let\u0026rsquo;s check the Java version:\n$ java -version openjdk version \u0026quot;11.0.8\u0026quot; 2020-07-14 LTS OpenJDK Runtime Environment Zulu11.41+75-CA (build 11.0.8+10-LTS) OpenJDK Client VM Zulu11.41+75-CA (build 11.0.8+10-LTS, mixed mode) OK, ready to run Java 11 applications on the Raspberry Pi with ARMv6!\nMore info If you want more info, or use JavaFX, check these blog posts:\n Installing Java and JavaFX on the Raspberry Pi (for ARMv7+) How to install and use Java 11 and JavaFX 11 on Raspberry Pi boards with ARMv6 processor  "},{"uri":"https://pi4j.com/about/license/","title":"License (Open Source)","tags":[],"description":"","content":"The Pi4J Version 2.0 project is distributed and licensed under the Apache License, Version 2.0 license (A business-friendly OSS license).\n apache.org/licenses/LICENSE-2.0 github.com/Pi4J/pi4j-v2/blob/master/LICENSE.txt   Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n  Definitions.\n\u0026ldquo;License\u0026rdquo; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.\n\u0026ldquo;Licensor\u0026rdquo; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.\n\u0026ldquo;Legal Entity\u0026rdquo; shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \u0026ldquo;control\u0026rdquo; means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity.\n\u0026ldquo;You\u0026rdquo; (or \u0026ldquo;Your\u0026rdquo;) shall mean an individual or Legal Entity exercising permissions granted by this License.\n\u0026ldquo;Source\u0026rdquo; form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files.\n\u0026ldquo;Object\u0026rdquo; form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types.\n\u0026ldquo;Work\u0026rdquo; shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below).\n\u0026ldquo;Derivative Works\u0026rdquo; shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof.\n\u0026ldquo;Contribution\u0026rdquo; shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \u0026ldquo;submitted\u0026rdquo; means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \u0026ldquo;Not a Contribution.\u0026rdquo;\n\u0026ldquo;Contributor\u0026rdquo; shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work.\n  Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form.\n  Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed.\n  Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n(a) You must give any other recipients of the Work or Derivative Works a copy of this License; and\n(b) You must cause any modified files to carry prominent notices stating that You changed the files; and\n(c) You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and\n(d) If the Work includes a \u0026ldquo;NOTICE\u0026rdquo; text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\nYou may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\n  Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions.\n  Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file.\n  Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License.\n  Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages.\n  Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability.\n  END OF TERMS AND CONDITIONS\nAPPENDIX: How to apply the Apache License to your work.\n To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \u0026quot;[]\u0026quot; replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \u0026quot;printed page\u0026quot; as the copyright notice for easier identification within third-party archives.  Copyright (C) 2012 - 2019 Pi4J\nLicensed under the Apache License, Version 2.0 (the \u0026ldquo;License\u0026rdquo;); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \u0026ldquo;AS IS\u0026rdquo; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\n"},{"uri":"https://pi4j.com/getting-started/minimal-example-application/","title":"Minimal example application","tags":["Digital Input","Digital Output","Maven","Gradle"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\n In the \u0026ldquo;pi4j-example-minimal\u0026rdquo; GitHub project you can find a project which contains the minimal code to control a digital input and output with Pi4J. The project is further described on this page. The application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.\n  Wiring This minimal example application uses this wiring:\nBuilding the application The main build tool used by the Pi4J project is Maven, but for this example we provided both the Maven and Gradle approach, so you can select the tool you prefer.\nMaven This project can be built with Apache Maven 3.6 (or later) and Java 11 OpenJDK (or later). These prerequisites must be installed prior to building this project as described on the previous pages. The following command can be used to download all project dependencies and compile the Java module. You can build this project directly on a Raspberry Pi with Java 11+.\nmvn clean package Gradle You can also use the Gradle Build Tool from these same sources. Use version 6.6 (or later) and Java 11 OpenJDK (or later). The Gradle wrapper is used as described on docs.gradle.org. The Gradle configuration file build.gradle-file is included in the sources.\nOn Linux:\n./gradlew build On Windows:\ngradlew.bat build Dependency in pom.xml For the Maven approach, a pom.xml file defines all the dependencies, and the build process.\nIn this project we will be using slf4 for logging, pi4j-core and the pi4j-plugins for the Raspberry Pi and PiGPIO. To make the versions easy to update, we add those numbers as properties.\n\u0026lt;properties\u0026gt; \u0026lt;!-- DEPENDENCIES VERSIONS --\u0026gt; \u0026lt;slf4j.version\u0026gt;1.7.32\u0026lt;/slf4j.version\u0026gt; \u0026lt;pi4j.version\u0026gt;2.0\u0026lt;/pi4j.version\u0026gt; \u0026lt;/properties\u0026gt; These are the dependencies we need:\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${slf4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- include Pi4J Core --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- include Pi4J Plugins (Platforms and I/O Providers) --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-pigpio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Pi4J code blocks which are used Initialization Before you can use Pi4J you must initialize a new runtime context.\nThe Pi4J static class includes a few helper context creators for the most common use cases. The newAutoContext() method will automatically load all available Pi4J extensions found in the application\u0026rsquo;s classpath which may include Platforms and I/O Providers.\nvar pi4j = Pi4J.newAutoContext(); Output Pi4J Context information The library contains helper functions to output info about the available and used platforms and providers. To keep the example code clean, these are part of the PrintInfo.java class. For example to print the loaded platforms:\nPlatforms platforms = pi4j.platforms(); console.box(\u0026#34;Pi4J PLATFORMS\u0026#34;); console.println(); platforms.describe().print(System.out); console.println(); Handle the button presses To handle digital input events we first need a configuration for it. With that configuration, Pi4J can create the object for us and the state changes can be handled.\nAdditional info on the newConfigBuilder can be found on \u0026ldquo;Building an I/O Instance\u0026rdquo;.\nprivate static int pressCount = 0; private static final int PIN_BUTTON = 24; // PIN 18 = BCM 24  var buttonConfig = DigitalInput.newConfigBuilder(pi4j) .id(\u0026#34;button\u0026#34;) .name(\u0026#34;Press button\u0026#34;) .address(PIN_BUTTON) .pull(PullResistance.PULL_DOWN) .debounce(3000L) .provider(\u0026#34;pigpio-digital-input\u0026#34;); var button = pi4j.create(buttonConfig); button.addListener(e -\u0026gt; { if (e.state() == DigitalState.LOW) { pressCount++; console.println(\u0026#34;Button was pressed for the \u0026#34; + pressCount + \u0026#34;th time\u0026#34;); } }); Toggle a LED For the LED we use a similar approach with a configuration. The created led-object can be used to toggle its state.\nprivate static final int PIN_LED = 22; // PIN 15 = BCM 22  var ledConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;led\u0026#34;) .name(\u0026#34;LED Flasher\u0026#34;) .address(PIN_LED) .shutdown(DigitalState.LOW) .initial(DigitalState.LOW) .provider(\u0026#34;pigpio-digital-output\u0026#34;); var led = pi4j.create(ledConfig); while (pressCount \u0026lt; 5) { if (led.equals(DigitalState.HIGH)) { led.low(); } else { led.high(); } Thread.sleep(500 / (pressCount + 1)); } Closing the application Before the application quits, we need to call the shutdown() function on the Pi4J static helper class. This will ensure that all I/O instances are properly shutdown, released by the system and shutdown in the appropriate manner. Termination will also ensure that any background threads/processes are cleanly shutdown and any used memory is returned to the system.\npi4j.shutdown(); Steps to run this application on your Raspberry Pi  Attach a LED and button as shown in the image above Use a recent Raspbian OS image which has Java 11. To check if you have the correct Java version in the terminal:  $ java -version openjdk version \u0026#34;11.0.6\u0026#34; 2020-01-14 OpenJDK Runtime Environment (build 11.0.6+10-post-Raspbian-1deb10u1) OpenJDK Server VM (build 11.0.6+10-post-Raspbian-1deb10u1, mixed mode)  Download the project from GitHub and build it:  $ git clone https://github.com/Pi4J/pi4j-example-minimal.git $ cd pi4j-example-minimal/ $ mvn clean package  Change to the distribution directory where you can find the generated package and required Java-modules.  $ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 364456 Jun 19 10:04 pi4j-core-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 7243 Jun 19 10:04 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 142461 Jun 19 10:04 pi4j-library-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 37302 Jun 19 10:04 pi4j-plugin-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 26917 Jun 19 10:04 pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run.sh -rw-r--r-- 1 pi pi 52173 Jun 19 10:04 slf4j-api-2.0.0-alpha0.jar -rw-r--r-- 1 pi pi 15372 Jun 19 10:04 slf4j-simple-2.0.0-alpha0.jar  Start the application with the provided run.sh script. Make sure to start with sudo as Pi4J (at this moment) needs to be started with it, to enable the native library that is part of Pi4J to communicate with the GPIOs:  $ sudo ./run.sh  The output will first show you some info about the platforms and providers. Then the LED starts blinking and shows how many times you pushed the button:  LED high LED low LED high Button was pressed for the 1th time LED low LED high Button was pressed for the 2th time LED low LED high LED low LED high Button was pressed for the 3th time LED low LED high LED low LED high Button was pressed for the 4th time LED low LED high LED low LED high Button was pressed for the 5th time  If you get an error like shown below, you probably didn\u0026rsquo;t start the application with sudo, which is (at the moment) required for the PiGpio native library that handles the interfacing with the GPIOs.  WARN com.pi4j.library.pigpio.impl.PiGpioNativeImpl - PIGPIO ERROR: PI_INIT_FAILED; pigpio initialisation failed "},{"uri":"https://pi4j.com/getting-started/minimal-example-application-fatjar/","title":"Minimal example as FAT JAR","tags":["Digital Input","Digital Output","FatJAR"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fatjar\n The \u0026ldquo;Minimal example application\u0026rdquo; uses one LED and button to demonstrate the basic use of Pi4J V.2. When building that project with Maven, all the required Java modules are copied to the target/distribution directory. But a lot of developers like to produce a single, executable JAR that contains all dependencies, also known as a \u0026ldquo;FAT JAR\u0026rdquo;.\nThe repository \u0026ldquo;pi4j-example-fatjar\u0026rdquo; GitHub project contains a Maven project with identical wiring, dependencies and build command to the \u0026ldquo;Minimal example application\u0026rdquo;, but results in such a FAT JAR instead of separate Java modules.\nMaven plugins By using three build plugins the FAT JAR is created:\n maven-compiler-plugin maven-jar-plugin maven-shade-plugin  For the full description, take a look at the README.md in the sources and the page \u0026ldquo;Build as a FAT JAR with Maven\u0026rdquo;.\nBuilding and running Build with:\nmvn clean package Once the build is complete and was successful, you can find the compiled FAT JAR pi4j-example-fatjar.jar in the target directory. You can build directly on your Raspberry Pi or if you are developing on a different computer, copy the file to your Raspberry Pi with (in this example the Pi has IP 192.168.0.252):\nscp target/pi4j-example-fatjar.jar pi@192.168.0.252://home/pi On the Raspberry Pi open a terminal, or via SSH from your PC, execute this command:\n$ sudo java -jar pi4j-example-fatjar.jar [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - \u0026lt;-- The Pi4J Project --\u0026gt; [main] INFO com.pi4j.util.Console - Minimal Example project [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PLATFORMS | [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - PLATFORMS: [1] \u0026quot;Pi4J Runtime Platforms\u0026quot; \u0026lt;com.pi4j.platform.impl.DefaultPlatforms\u0026gt; └─PLATFORM: \u0026quot;RaspberryPi Platform\u0026quot; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - | Pi4J DEFAULT PLATFORM | [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - PLATFORM: \u0026quot;RaspberryPi Platform\u0026quot; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PROVIDERS | [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - PROVIDERS: [12] \u0026quot;I/O Providers\u0026quot; \u0026lt;com.pi4j.provider.impl.DefaultProviders\u0026gt; ├─SPI: [2] \u0026lt;com.pi4j.io.spi.SpiProvider\u0026gt; │ ├─PROVIDER: \u0026quot;PiGpio SPI Provider\u0026quot; {pigpio-spi} \u0026lt;com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl} │ └─PROVIDER: \u0026quot;RaspberryPi SPI Provider\u0026quot; {raspberrypi-spi} \u0026lt;com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl} ├─ANALOG_INPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogInputProvider\u0026gt; ├─SERIAL: [2] \u0026lt;com.pi4j.io.serial.SerialProvider\u0026gt; │ ├─PROVIDER: \u0026quot;PiGpio Serial Provider\u0026quot; {pigpio-serial} \u0026lt;com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl} │ └─PROVIDER: \u0026quot;RaspberryPi Serial Provider\u0026quot; {raspberrypi-serial} \u0026lt;com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl} ├─DIGITAL_INPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalInputProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi Digital Input (GPIO) Provider\u0026quot; {raspberrypi-digital-input} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio Digital Input (GPIO) Provider\u0026quot; {pigpio-digital-input} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl} ├─I2C: [2] \u0026lt;com.pi4j.io.i2c.I2CProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi I2C Provider\u0026quot; {raspberrypi-i2c} \u0026lt;com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio I2C Provider\u0026quot; {pigpio-i2c} \u0026lt;com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl} ├─ANALOG_OUTPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogOutputProvider\u0026gt; ├─DIGITAL_OUTPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalOutputProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi Digital Output (GPIO) Provider\u0026quot; {raspberrypi-digital-output} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio Digital Output (GPIO) Provider\u0026quot; {pigpio-digital-output} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl} └─PWM: [2] \u0026lt;com.pi4j.io.pwm.PwmProvider\u0026gt; ├─PROVIDER: \u0026quot;RaspberryPi PWM Provider\u0026quot; {raspberrypi-pwm} \u0026lt;com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl} └─PROVIDER: \u0026quot;PiGpio PWM Provider\u0026quot; {pigpio-pwm} \u0026lt;com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ------------------- [main] INFO com.pi4j.util.Console - | Pi4J REGISTRY | [main] INFO com.pi4j.util.Console - ------------------- [main] INFO com.pi4j.util.Console - REGISTRY: [2] \u0026quot;I/O Registered Instances\u0026quot; \u0026lt;com.pi4j.registry.impl.DefaultRegistry\u0026gt; ├─IO: \u0026quot;LED Flasher\u0026quot; {led} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutput\u0026gt; {DOUT-22} └─IO: \u0026quot;Press button\u0026quot; {button} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInput\u0026gt; {DIN-24} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high ... [main] INFO com.pi4j.util.Console - LED high [Thread-1] INFO com.pi4j.util.Console - Button was pressed for the 1th time [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [Thread-3] INFO com.pi4j.util.Console - Button was pressed for the 2th time [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high ... "},{"uri":"https://pi4j.com/kotlin/serial/","title":"Serial Kotlin DSL","tags":[],"description":"SERIAL (UART/RS232) DSL Pi4J-Kotlin","content":" Feel free to checkout the Pi4J docs on Serial\n Installation Add PiGPIO dependency\ndependencies { implementation(\u0026#34;com.pi4j:pi4j-plugin-pigpio:2.3.0\u0026#34;) } Serial DSL serial(\u0026#34;/dev/ttyS0\u0026#34;) { use_9600_N81() dataBits_8() parity(Parity.NONE) stopBits(StopBits._1) flowControl(FlowControl.NONE) piGpioSerialProvider() }.open { // use here. } Minimal Serial Example This is the Kotlin DSL version of the same Serial example here, but leveraging the Kotlin DSL\n serial(\u0026#34;/dev/ttyS0\u0026#34;) { // .. }.open { console { +\u0026#34;Waiting till serial port is open\u0026#34; while (!isOpen) { print(\u0026#34;.\u0026#34;) sleep(250) } println() +\u0026#34;Serial port is open\u0026#34; startDaemon { inputStream.bufferedReader().use { while (true) { if (available() != 0) sleep(10) else buildString { (0 until available()).forEach { _ -\u0026gt; readByte().let { b -\u0026gt; // All non-string bytes are handled as line breaks  if (b \u0026lt; 32) return@forEach else append(b.toInt().toChar()) } } }.also { +\u0026#34;Data: \u0026#39;$it\u0026#39;\u0026#34; } } } } while (isOpen) sleep(500) } } And startDaemon is defined as:\nfun startDaemon(runnable: Runnable) = Thread(runnable).apply { isDaemon = true start() } "},{"uri":"https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/","title":"Soft real time PLC","tags":[],"description":"","content":"Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available.\n    Conveyors for containers filled by a dispensing robot\n      eSyBox using pi4j to communicate with the Raspberry Pi\u0026#39;s I2C bus\n      eSyBox slot detection in action\n                               These are projects by the company atexxi.ch.\nA soft real time PLC written in Java running on Strolch This PLC project by Robert von Burg combines Pi4j, Strolch and the Raspberry Pi.\nIt is being used in a material flow controller which coordinates FromStock orders with a medical dispensing robot and dispenses the packets into containers. These containers are then moved by a Strolch based PLC. The containers travel on a 12m long conveyor with multiple segments and entry/exits to position the container at the dispensing robot\u0026rsquo;s exit.\nMedical cabinet with pick-by-light The most recent project are medical cabinets which use I2C to communicate with custom electronics to control the locks, perform a pick-by-light from slots and uses infrared to detect access to a slot with products in it.\n"},{"uri":"https://pi4j.com/architecture/advanced/","title":"Advanced","tags":[],"description":"","content":"Pi4J V.2 tries to focus on its core functionality (the GPIO I/O) but at the same time wants to provide the possibility to extend and adapt to other hardware, underlying framework etc.\nYou can find more info on these pages about some of the current functionalities to achieve this:\n Annotated provisioning   Dependency injection   Native Library Path   Plug-ins   Remote support   "},{"uri":"https://pi4j.com/examples/crowpi/","title":"Electronics with CrowPi","tags":["CrowPi"],"description":"","content":"The CrowPi is an electronics starter kit in a laptop-housing. Of course, you can get any electronics starter kit for this purpose or buy separate components. That\u0026rsquo;s the fun of electronics: components are inexpensive and easy to find on ebay or one of the many web shops.\n    CrowPi 1\n      CrowPi 2\n      Example electronics starter kit\n                               As the CrowPi contains a lot of components, its use is described on the following subpages:\n Develop with Intellij IDEA   CrowPi examples   The CrowPi sources and documentation are provided by the Swiss FHNW University based on a project in 2021 by Pascal Mathis and Tobias Siegrist under supervision of Barbara Scheuner and Dieter Holz. The original documentation (in German) is available on \u0026ldquo;CrowPi goes Java\u0026rdquo; (with sources on GitHub).\n "},{"uri":"https://pi4j.com/documentation/logging/","title":"Logging with SLF4J","tags":[],"description":"","content":"Pi4J uses SLF4J for logging. To include it in your project, add this Maven dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.0-alpha0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; There are different ways to configure the logging output, as described on the SLF4J website, but the shortest is probably with this property in your main-method:\npublic static void main(String[] args) throws Exception { // Configure default logging level, accept a log level as the first program argument  System.setProperty(\u0026#34;org.slf4j.simpleLogger.defaultLogLevel\u0026#34;, \u0026#34;INFO\u0026#34;); // Your code comes here } "},{"uri":"https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/","title":"PiJukeBox","tags":[],"description":"","content":"Daniel Mårtensson used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators.\nFeatures: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi\u0026rsquo;s, terminal based.\nWith a Raspberry Pi B+, OpenJDK 8 and Pi4J inside this radio, it became a juke box. The sources are available on github.com/DanielMartensson/PiJukeBox\n"},{"uri":"https://pi4j.com/about/team/","title":"The Team","tags":[],"description":"","content":"          Robert Savage, Project Founder, Architect, Lead Developer.\nPrincipal Software Architect/Engineer. Consultant, technology enthusiast, entrepreneur, open source contributor, technology blogger. Founder at shadeBlue, LLC and SavageSoftware, LLC. Robert has a more than 20 year career working in the professional audio visual and home/commercial automation industry and an extensive background in developing technology solutions with a special focus on home automation and hardware/firmware/software integration. In 2012, Robert created the Pi4J project which provides Java developers an easy to use Java library enabling access to low-level I/O functionality (GPIO, I2C, SPI, Serial, etc.) of embedded systems like the Raspberry Pi. I created Pi4J to empower Java programmers to get involved with embedded platforms such as the Raspberry Pi and provide an easy to use and accessible Java-centric object-oriented library enabling control of real world (physical) \u0026ldquo;things\u0026rdquo;. Pi4J V.2 brings an entirely new and modern approach to Java I/O programming for embedded systems. I\u0026rsquo;m excited to get V.2 released and see what additional creative projects emerge.    Frank Delporte, Project organization, Documenter, Developer.\nJava and Raspberry Pi-enthousiast, blogger on webtechie.be and author of the book \u0026ldquo;Getting Started with Java on Raspberry Pi\u0026rdquo;. Technical writer at Azul. Lead coach CoderDojo in Ieper, Belgium. Software developer with more than 25 years of experience in video, multimedia, technical project management, digital signage and (web) programming. I\u0026rsquo;m a strong believer in the power and fun of Java on the Raspberry Pi. My goal is to make it as easy as possible to get started for new and experienced Java developers who want to start there first hardware experiment. That was the reason I wrote a book about this subject and share my experiments on my blog and GitHub. Pi4J V.2 brings a lot of improvements to an already great project, and - just one example - the use of the BCM pin numbers will make it even a lot easier to use the GPIO\u0026rsquo;s. That\u0026rsquo;s why I join this great team to assist in delivering this V.2 and extend it further so we can bring even more Java to the Raspberry Pi.    Robert von Burg aka \u0026ldquo;Eitch\u0026rdquo;, Developer, Releaser.\nAs lead developer for strolch.li we use Raspberry Pi as our platform to connect with products, and to implement a PLC in Java. The Pi4J project allows us to encapsulate the low level aspects of communicating with the hardware, and stay in our preferred choice. The strolch.li/plc.html project allows us to also stay in the same DSL for writing server applications, as well as communicating with low level devices. Since I love open source projects, it felt natural to me to start investing time in the Pi4J projects to assist in the further development.    Thomas Aarts (aka Tom), Developer, Creating IC examples.\nMy previous work entailed a decade in Alaska involving HF through Microwave communication and airport Instrument Landing Systems (ILS) DME NDB VASI. The next decade was centered around telephony. Working for ‘ROLM’ I was a software engineer working on the CBX series of switches. Most years in assembler using the DG instruction set. Later years on the larger CBX that used a company designed compiler much like ‘C’ on a much different instruction set. The last two decades I worked within an IBM lab. At the start I worked the AS400, a mid to large size server. Initially development of software at the user interface, above the MI. After a few years I moved in the firmware stack at the time all the servers, mid-mainframe, changed to using the IBM RISC processor. After some years in the firmware stack I moved to a newly formed simulation team. This entailed developing a simulation of the entire central processor complex (CPC) or Central Electronic Complex (CEC) to enable the firmware stack to boot and the partitions to boot on top and run. So after a long time working just above the hardware or simulating the hardware I found the Pi4j project of interest. After its’ use for some sensors and displays I am spending more time learning its capability and if possible offer something to the project. After that by decade history rundown I should add I retired.    Muhammad Hashim aka \u0026ldquo;mhashim6\u0026rdquo;, Developer, Focus on Kotlin.\nI\u0026rsquo;m a Software Engineer at Instabug, Writer \u0026amp; Blogger at The Upside-Down Trees \u0026amp; The Unhappy Folk. I go by \u0026ldquo;Timeless, Placeless\u0026rdquo; As it better reflects the crafts I do; my art and interests; and my life. I\u0026rsquo;ve joined the team to bring Kotlin to Pi4J; The project that brought the JVM to the Raspberry Pi.    "},{"uri":"https://pi4j.com/featured-projects/cocktail-maker-by-alex9849/","title":"Cocktail Maker","tags":[],"description":"","content":"The CocktailMaker is a cocktail mixing machine by Alexander Liggesmeyer. It can control as many pumps as the RaspberryPi provides GPIO pins. For every pump that gets added to the system, the user has to provide the amount of time that that pump needs to pump one centiliter in milliseconds. The machine uses peristaltic pumps. So that number is perfectly accurate. The flow rate won\u0026rsquo;t vary over time. It uses a relay board for closing the electronic circuit for all pumps. This allows to power the pumps with more than 5V. The relay board is connected to the Pi which controls the board with Pi4J V1. The backend-application is written in Java (Spring boot). The frontend is written with VueJS.\n                                                                     A video is available on Reddit\nApplication features  Pumping ingredients in sequential order. Pumping ingredients concurrently and mixing them by spreading the active pump timings within the productionstep. Ingredients that cannot be added automatically (maybe because they didn\u0026rsquo;t get assigned to one pump or are simply not liquid) can be handled. If a recipe with a non-pumpable ingredient got ordered the application will prompt the user to add that ingredient at the corresponding point. Recipes can be resized for every order. The user decides the size of the cocktail he wants to order. All ingredients amount will get recalculated automatically. A drag \u0026amp; drop recipe editor. Recipes can be categorized. Collections: Users can create collections and add recipes to them. Bar: Users can add owned ingredients to their bar. The application can search for recipes that he can order with the owned recipes. If the user tries to order a recipe where he doesn\u0026rsquo;t own all ingredients he will get a warning. The cocktail maker can search for recipes that can be produced fully automatic. (Won\u0026rsquo;t require the user to add ingredients manually) Recipes can be searched by ingredients. Multiple users \u0026amp; permission system: The admin can create new users and assign them to predefined groups, that have different permissions. Track the remaining amount of liquid of the connected bottles and prevent an order if the remaining liquid doesn\u0026rsquo;t reach. It is also able to switch between pumps on the fly. If one order empties one bottle, but another bottle with the same ingredient is connected, the application will empty the first container and will switch to the second one mid-production.  Docker deployment The whole application can be deployed as a docker container that has to be started in privileged mode. This allows even beginners that don\u0026rsquo;t have much experience to build their own machine.\nSources The full sources are available on GitHub\n"},{"uri":"https://pi4j.com/documentation/create-context/","title":"Creating a Pi4J Context","tags":[],"description":"","content":"The context is an immutable runtime object that holds the configured state and manages the lifecycle of a Pi4J instance. It includes all loaded plugins, providers, platforms, I/O instance registry, environmental configuration and runtime objects including executor thread pools, I/O event listeners, etc.\nTerminating/destroying the context stops and releases all resources, threads, listeners, and provisioned I/O instances held by the context.\nVersion 1 was implemented using a static singleton, while version 2 uses a \u0026ldquo;Context\u0026rdquo; to avoid static singletons.\nCreating a Context A Pi4J Context can be created automatically (accepting all default context configurations) or manually (builder) allowing users to customize the context configuration.\nAutomatic An auto context includes AUTO-DETECT BINDINGS enabled which will load all detected Pi4J extension libraries (Platforms and Providers) in the class path.\nvar pi4j = Pi4J.newAutoContext(); Builder If you need more flexibility are specific use-cases, the builder can be used to define all the parameters of the context, for example when you want to use your own providers, use mocked instances for testing\u0026hellip;:\nContext pi4j = Pi4J.newContextBuilder() .add(new MockPlatform()) .add(MockAnalogInputProvider.newInstance(), MockAnalogOutputProvider.newInstance(), MockSpiProvider.newInstance(), MockPwmProvider.newInstance(), MockSerialProvider.newInstance(), MockI2CProvider.newInstance(), MockDigitalInputProvider.newInstance(), MockDigitalOutputProvider.newInstance()) .add(new MyCustomADCProvider(/* implements AnalogInputProvider, id=\u0026#34;my-adc-prov\u0026#34; */)) .add(new MyCustomSPIProvider(/* implements SpiProvider, id=\u0026#34;my-spi-prov\u0026#34; */)) .build(); More information Use a single Context instance A single Context instance must be created in your application and shared between the classes. A Context object contains all the runtime and management state of the I/O. If you would use multiple Context objects and attempt to reuse certain I/O hardware or I/O providers it\u0026rsquo;s possible that they could conflict or get out of sync.\nGet GPIO handlers from the Context The Context maintains a reference to each I/O instance created, until pi4j.shutdown() is called.\nSomewhere you will need to create() your I/O instance giving it a unique ID (String). If you try to call create() a second time with the same ID, you will get an IOAlreadyExistsException.\npi4j.digitalOutput().create(1, \u0026#34;my-gpio\u0026#34;); Elsewhere in your application, you can get access to existing I/O instances using the Context\u0026rsquo;s io() or getIO() methods.\nif (pi4j.hasIO(\u0026#34;my-gpio\u0026#34;)) { DigitalOutput myOutput = pi4j.io(\u0026#34;my-gpio\u0026#34;); } Additional methods to access the registered I/O instances can be obtained through the Registry class.\npi4j.registry().* "},{"uri":"https://pi4j.com/featured-projects/street-artist-robot/","title":"Didier the street artist robot","tags":[],"description":"","content":"Meet \u0026ldquo;Didier\u0026rdquo; the street artist robot, a project by Duvam. The sources are shared on github.com/duvamduvam/didier-java.\n                                         "},{"uri":"https://pi4j.com/getting-started/user-interface-with-javafx/","title":"User interface with JavaFX","tags":["Digital Input","Digital Output","JavaFX","Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-javafx\n JavaFX is a framework to create user interfaces for desktop (Windows, Mac, Linux) and mobile phones. JavaFX is an opensource project which is documented on openjfx.io and the sources are available in this GitHub project.\nThe main goal of Java has always been to be able to create applications which are \u0026ldquo;write once, run everywhere\u0026rdquo;. JavaFX promises the same for Graphical User Interface applications.\nGluon is the main maintainer of the OpenJFX project and offers commercial support to companies who want to use JavaFX in critical applications. They also provide tools to build and compile Java code to native applications for all platforms.\nDeveloping a JavaFX application The best part of Java is the \u0026ldquo;Write Once, Run Everywhere\u0026rdquo;. This means you can develop your application on any PC (Windows, Mac, Linux) and run it on any other one of these (yes even on mobile) with the exact same look-and-feel and behavior. The only limitation is the part you develop specifically for the Raspberry Pi: controlling the GPIOs with Pi4J.\nThe most used IDE for Java development is IntelliJ IDEA, which is not available for Raspberry Pi. If you are using it on your PC and want to learn more about the best approach to get started with JavaFX, read this great tutorial \u0026ldquo;Beginning JavaFX Applications with IntelliJ IDEA\u0026rdquo; by Carl Dea.\nJavaFX on Raspberry Pi JavaFX is also an ideal framework to build Java applications with a user interface for the Raspberry Pi!\nYou can find a runtime version dedicated to the Raspberry Pi on the Gluon download page. Let\u0026rsquo;s install it on our board, so we can start Java+JavaFX applications which make best use of the capabilities of the Raspberry Pi.\nInstallation To get the latest version on your Raspberry Pi, first check the Gluon download page for the download link.\nCopy the link and use it with wget to download the file:\n Download the file  $ wget -O openjfx.zip https://gluonhq.com/download/javafx-17-ea-sdk-linux-arm32/ Unzip the file  $ unzip openjfx.zip Move the unzipped directory to the opt-directory (optionally, but it\u0026rsquo;s a logical place)  $ sudo mv javafx-sdk-17/ /opt/javafx-sdk-17/ Start an application Now the OpenJFX-runtime is available on our Raspberry Pi, we can start each Java application which was compiled to a JAR with some additional parameters to run it with the best rendering support.\nThe additional arguments are needed to link to the downloaded JavaFX library and select the correct Monocle platform.\njava \\  -Dglass.platform=gtk \\  -Djava.library.path=/opt/javafx-sdk-17/lib \\  -Dmonocle.platform.traceConfig=false \\  -Dprism.verbose=false \\  -Djavafx.verbose=false \\  --module-path .:/opt/javafx-sdk-17/lib \\  --add-modules javafx.controls \\  --module {YOUR_MAIN_CLASS} $@ Minimal example application Sources In this repository https://github.com/Pi4J/pi4j-example-javafx, a minimal example project is provided which combines Java, JavaFX, Pi4J and a few buttons. The wiring for this example is identical to the Minimal example application with a single LED and button.\n    JavaFX UI after start-up\n      JavaFX UI after click on physical button\n      LED turned on by clicking on the JavaFX button\n                               Steps to test the application  Download the sources to your Raspberry Pi  $ git clone https://github.com/pi4j/pi4j-example-javafx Move to the downloaded directory  $ cd pi4j-example-javafx Build the project  $ mvn package Move to the target \u0026gt; distribution directory  $ cd target/distribution Run the application with the provided run-script  $ sudo ./run.sh "},{"uri":"https://pi4j.com/featured-projects/joystick-game/","title":"JMonkeyEngine with Joystick","tags":[],"description":"","content":"Pavl G. created a Java Gradle library to control a car in a JMonkeyEngine game with an arduino joystick module connected to a Raspberry Pi4 model B, using GPIO digital pins and SPI interfacing through MCP3008 ADC (Analog~Digital Converter).\nRequirements  Raspberry Pi with arm processor (pi3, pi4, piZero) with a working java8 (preferred). Female-to-male jumper wires. Breadboard. Arduino Joystick module. MCP3008 IC (ADC \u0026ndash; other adcs may work too, but we are covering only MCP3008 here). Some patience and time.  Difference between Analog and Digital signals?  An analog signal is a continuously variable voltage between 0 and Vmax over time, examples : Temperature sensor output, Potentiometers (joysticks)\u0026hellip;. A digital signal is rather a discrete step-by-step output voltage of LOW (fall) to HIGH (rise) according to the switch position among a network of resistors. To convert from analog signals to digial signals, we need to encode the output voltage changing over time to some sequence of bits. We cannot interface analog electronics on digital devices such as (arduinos and raspberry pi w/o converting into digial signals).  What\u0026rsquo;s ADC? Let\u0026rsquo;s have an example of a 3-bit Analogue to Digital Converter :\nThis is how ADC works under the hood, steps of converting Analog to Digital  Analog voltage goes through Vin, Then it\u0026rsquo;s passed to a network of voltage comparators that compares its voltage to the selected reference range (Vref, which is selected at the time of wiring). If Vin \u0026gt; Vref the comparator output would be HIGH aka (1), if Vin \u0026lt; Vref the comparator output would be LOW aka (0). The significant of having a network of comparators is to encode the value of the analog signal into a digital sequence of bits. The output of comparators Dn gets passed into a 3-bit priority encoder. The priority encoder by definition, it encodes based on the high priority input and ignores the low priority input. So, if Vin = 3.5 to 4.0 V then the Comparators output = 11111111, At last when inputting the comparator output into the priority encoder the encoder gives a value of 7 which points to D7 of comparator U7 aka the last voltage level, and that\u0026rsquo;s true because our Vin is bigger than the Vref.  What\u0026rsquo;s SPI?  Serial Peripheral Interface (SPI) is an interface bus commonly used to send data between microcontrollers and small peripherals such as shift registers, sensors, and SD cards. It uses separate clock and data lines, along with a select line to choose the device you wish to talk to. Our target is to transfer the output from our priority encoder to the BCM processor of our Pi throughout the SPI protocol (Synchronously over Tx from MCP3008 to Rx of the Pi). To send and receive synchronous data we use MISO (the same as CIPO) for receving data from peripherals and MOSI (the same as COPI) to send data to the peripherals. MISO : Master-in-Slave-Out = CIPO : Controller-in-peripheral-out. MOSI : Master-out-Slave-In = COPI : Controller-out-Peripheral-in. MCP3008 is used to receive analog input, so MISO or CIPO is our common active data line. CS is the chip select, it\u0026rsquo;s used to select which peripheral device to use. SCLK is the serial clock and it\u0026rsquo;s used to synchronize data on a data line, to have a clear separate message per 8 clocks (8-bit message).  This diagram describes steps of how SPI Communication works in MCP3008 :\n CS = LOW -\u0026gt; signifies the selection to peripheral IO 0. SCLK += Clock. Rising edge of clock (LOW-to-HIGH) -\u0026raquo; Reads data from A/D and latches it for the MCU (micro-controller unit) -\u0026raquo; Creates the rising edges of Din line (Cyan line) -\u0026raquo; MOSI line. Falling edge of clock (HIGH-to_LOW) -\u0026raquo; Writes data from the MCU to the A/D -\u0026raquo; Creates the falling edges of Dout line bits (magneta line) -\u0026raquo; MISO line. Each input (D0, D1, D2, Dn) is an analog input that\u0026rsquo;s encoded into a 10-bit digital output (B0-B9) and then clocked out for the MCU on the falling edge of the SCLK as shown by the last data line (Dout). B-null (red circle) is the leading bit, it marks the last bit clocked out.  MCP3008 ADC  MCP3008 A/D Converter is a 10-bit analog to digital converter. 10-bit means : it has a maximum resolution of 10-bits in binary (1111111111) = in dec (1023) = in hex (3FF) and that\u0026rsquo;s determined by the Vref vs Dn voltage as discussed before using the voltage comparator. MCP3008 has 8 analog input channels that can be used in parallel (updated via SCLK using the SPI), the last number 8 stands for the number of analog inputs. MCP3008 controls its logic using SPI. MCP3008 can accept between 2v7 and 5v5 after which the IC may burn out. MCP3008 comes in various packages for various usages (PDIP, SOIC,\u0026hellip;.), in our case we would use the PDIP. Other adcs like MCP3002 and MCP3004 works by the same analogy, except that they can accept a max of 2 analog inputs and a max of 8 analog inputs respectively, if your project would use a max of 2 analog inputs, then you could buy MCP3002 and still can follow this tutorial.  Cracking the MCP3008 Datasheet Alright, here is how to tackle down the MCP3008/MCP3004 datasheet :\n  Know your package type whether PDIP (Plastic Dual in-Line), SOIC (Small Outline IC), TSSOP (Thin Shrink Small Outline Plastic) :\n  Know your pin configuration and orientation :\n In our case, we do a tutorial, so we will use PDIP (Plastic-Dual-In-Line) package :   So, our pins outline are as follows :    Know the meaning of pins on your package :\n  This is the hardest part of understanding how an IC work, but quick looking on an internal diagram may be insightful :\n  As you can see the MCP has a different way of comparing VREF and Din and encoding the results, it uses a modern way called 10-bit SAR - Successive Approximation Register and a DAC which we will not cover in this tutorial but the net result is the same as a using a network of resistors with comparators.\n  Know the max ratings of various IC properties before wiring up :\n VDD-Max-Rating = 5v5. VREF-Max-Raing = 5v5, min-working-voltage = 2v7. Analog-Channel-Max-Rating = VREF = 5v5 \u0026ndash; after that the channel may burn or the IC may not work. Max-Clock-Rating = f-CLK = 3.6 MHZ on 5v5, 1.35 MHZ on 2v7. Error = +/- 1.0 LSB (least significant bit). Resolution = max analog value = 10-bits = 0b1111111111 = 1023. Other data like CLK rising, falling and setup time are neglectable. You may pay attention to temperature data if your project works in a special temperature case like a hot place or freezer or etc.    Have some fun with the IC.\n  Wiring Up  Vcc : is used for powering up the IC and not to compare with VREF. Vref : is used for controlling the maximum resolution of the input voltage (analog signal), if VREF = 5v5 (maximum voltage received by MCP3008), then the resolution of Vin is a 100%.  Testing the wiring Before going deeper and testing with jme vehicle, please test this code and do your conclusions :\n// Define MCP3008 provider on CS0 -- Peripheral device 0 final MCP3008GpioProvider mcp3008GpioProvider = new MCP3008GpioProvider(SpiChannel.CS0); // define analog input pins on the adc final GpioPinAnalogInput[] gpioPinAnalogInput= new GpioPinAnalogInput[2]; gpioPinAnalogInput[0] = MCP3008Pin.CH0; gpioPinAnalogInput[1] = MCP3008Pin.CH1; // define the threshold analog (the minimum voltage at which the Pi can listen to). mcp3008GpioProvider.setEventThreshold(thresholdAnalogValue, gpioPinAnalogInput); // enable monitoring of analog values with an interval of 250 ms mcp3008GpioProvider.setMonitorEnabled(true); mcp3008GpioProvider.setMonitorInterval(250); // start collecting data from the SPi connected to MCP3008 output. final GpioController gpioController = GpioFactory.getInstance(); gpioController.addListener((GpioPinListenerAnalog) event -\u0026gt; { System.out.println(\u0026#34;Value at CH0 : \u0026#34; + mcp3008GpioProvider.getValue(gpioPinAnalogInput[0])); System.out.println(\u0026#34;Value at CH1 : \u0026#34; + mcp3008GpioProvider.getValue(gpioPinAnalogInput[1])); }, gpioPinAnalogInput); Testing with a jmonkeyengine vehicle It\u0026rsquo;s very hard to give you a full overview of how to create a jmonkeyengine vehicle in this tutorial, so you could fairly refer to jme docs and examples for more :\n Use the physics in your game and control your game via keyboard : https://wiki.jmonkeyengine.org/docs/3.4/tutorials/beginner/hello_physics.html A Keyboard controlled car demo : https://github.com/jMonkeyEngine/jmonkeyengine/blob/master/jme3-examples/src/main/java/jme3test/bullet/TestPhysicsCar.java The idea is simple, any game can be controlled using a keyboard interface (bound to jme update), so you can simply replace that with a custom InputHandler using a custom hardware. The trick is to bind your joystick pi4j interface to jme thread (OpenGL\u0026rsquo;s thread).  Video of operation   More at sources  ADC overview : https://www.electronics-tutorials.ws/combination/analogue-to-digital-converter.html MCP3008 ADC : https://www.microchip.com/en-us/product/MCP3008 SPI overview : https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all Gradle lib : https://github.com/Scrappers-glitch/JoyStickModule Testcase : https://github.com/Scrappers-glitch/JmeCarPhysicsTestRPI  "},{"uri":"https://pi4j.com/documentation/platforms/","title":"Choosing a Platform","tags":[],"description":"","content":"Platforms are extensible service modules responsible for defining a set of default I/O providers and specific hardware capabilities for an embedded hardware system where Pi4J is deployed/running.\nTechnically speaking \u0026hellip; multiple platforms could be loaded into the runtime context, but only one will be considered the default platform for most I/O provisioning and operations. An example of this could be both a RaspberryPi Platform and Mock Platform are detected as plugins and loaded into the context, but only one will be determined at runtime to be the default platform used by the context.\nSome priority scheme will need to be implemented and invoked at runtime to resolve which is the best \u0026ldquo;platform\u0026rdquo; to accept as the default platform at runtime (on start up).\n The idea here is that a user could have multiple platform plugins in their directory but only one, theoretically the best suited, will be determined and used at runtime based on the runtime environment which makes it possible to develop, run and test on e.g. Windows with the MockPlatform and when finished run on the Raspberry Pi with the same generated jar\u0026rsquo;s which use the RaspberryPiPlatform.\nCurrent supported platforms:\n Raspberry Pi  "},{"uri":"https://pi4j.com/getting-started/fxgl/","title":"Game development with FXGL","tags":["JavaFX"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl\n As described on the previous page you can use JavaFX to build user interfaces which behave exactly the same on your PC and Raspberry Pi. Let\u0026rsquo;s go a step further and make a game with an \u0026ldquo;Arcade\u0026rdquo; controller.\nFor this project, we will be using FXGL, an opensource library on top of JavaFX to build games.\nThe image of the crowpi project has every prerequisite installed to work with javaFX/FXGL\nThe controller This project uses an Arcade kit in combination with a Picade X HAT USB-C to easily connect the wires of the buttons and joystick.\nConnect the USB power to the hat instead of your Raspberry Pi, and use the power button on the hat to start your Raspberry Pi.\n    Arcade kit components\n      Picade Hat\n      Assembled Picade Hat and Arcade kit\n      Connected wires on Picade Hat\n      Picade Hat pin numbers\n                               Pimoroni provides a GitHub project with software to use this hat with RetroPie, but this project aims to take full control of the hardware with Java.\nThe GPIO numbers are defined by the hat and can be found on pinout.xyz\nSteps to run snake on your Raspberry Pi  Download the project from GitHub and build it:  $ git clone https://github.com/Pi4J/pi4j-example-fxgl.git $ cd pi4j-example-fxgl/ $ mvn clean package  Change to the distribution directory where you can find the generated package and required Java-modules. Start it with the provided run.sh script:  $ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 364456 Jun 19 10:04 pi4j-core-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 7243 Jun 19 10:04 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 142461 Jun 19 10:04 pi4j-library-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 37302 Jun 19 10:04 pi4j-plugin-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 26917 Jun 19 10:04 pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run.sh -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run-kiosk.sh -rw-r--r-- 1 pi pi 52173 Jun 19 10:04 slf4j-api-2.0.0-alpha0.jar -rw-r--r-- 1 pi pi 15372 Jun 19 10:04 slf4j-simple-2.0.0-alpha0.jar $ sudo ./run.sh  There are two run scripts: run.sh: runs the application in standard windowed mode run-kiosk.sh: runs the application in DRM mode, see kiosk mode\n Picade To control our game we use the hardware mentioned above. Tho following mapper uses a similar binding method as in the minimal example\nPimapper To make use of the picade controls for existing FXGL project we provide an interface to simply extend your application.\nIntegrate piMapping The code for the piMapper is found in the example snake game.\nUpdate Game Change your Game from “extend GameApplication” to “extend PicadeGameApplication” PicadeGameApplication overrides the GameApplication class of FXGL and provides additional functions to map the picade controllers\npublic class FxglExample extends PicadeGameApplication Update Key Inputs Now we can use the new piMapper to address keys as well as picade controls. To do this, we need to tell the onKeyDown function, what control we want. Inputs are defined as in previous tutorials in the picadeControl enum\nonKeyDown(PicadeControl.PIN_BUTTON_1, KeyCode.F, () -\u0026gt; player.getComponent(SnakeHeadComponent.class).grow()); onKeyDown(KeyCode.G, () -\u0026gt; player.getComponent(SnakeHeadComponent.class).log()); GPIO  The Enum PicadeControl handles the the gpio numbers for the connected controls. pinout.xyz  PIN_JOYSTICK_UP(12), PIN_JOYSTICK_DOWN(6), PIN_JOYSTICK_LEFT(20), PIN_JOYSTICK_RIGHT(16), PIN_BUTTON_1(5); Run Scripts run.sh Runs the application in windowed mode\n#!/usr/bin/env bash java \\  -Dglass.platform=gtk \\  -Djava.library.path=/opt/javafx-sdk-17/lib \\  -Dmonocle.platform.traceConfig=false \\  -Dprism.verbose=false \\  -Djavafx.verbose=false \\  --module-path .:/opt/javafx-sdk-17/lib \\  --add-modules javafx.controls \\  --module com.pi4j.example/com.pi4j.example.FxglExample $@ run-kiosk.sh Runs the application with monocle in DRM (Direct rendering mode). More to kiosk mode here\n"},{"uri":"https://pi4j.com/featured-projects/sensor-drivers/","title":"Sensor drivers","tags":[],"description":"","content":"In case you want to read the data from various I2C sensors connected to Raspberry Pi the difficult part is usually writing a piece of code which talks to the I2C sensor.\nrpi-drivers is a Java library implementing simple APIs and communication code for some widely used I2C sensors. You can easily measure temperature, pressure and humidity, get ambient light intensity or measure voltage in your java Raspberry Pi projects.\nSupported sensors are:\n ADS1115 BME280 BMP180 HTU21D PCF8591 BH1750  Simply include rpi-drivers dependency into your Java Gradle or Maven project, and you are good to go!\n"},{"uri":"https://pi4j.com/getting-started/fxgl/fxgl-to-picade/","title":"FXGl to Picade","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl\n In this section we demonstrate how to convert existing FXGL projects to work on a RaspberryPi\nIf you don\u0026rsquo;t have an existing FXGL project, go grab one from FXGLGames\nSteps to get your app running on a RaspberryPi  Add Maven support to your project In our project we use Maven to manage dependencies and build the application, other build tools such as gradle are also viable but not covered in this tutorial.  In the Project tool window, right-click your project and select Add Framework Support In the dialog that opens, select Maven from the options on the left and click OK Add run scripts Create a folder called assets in the root directory of your project.  Copy the run scripts into the folder\nChange the module names according to your projects module\nEdit pom.xml Extend the properties tag with dynamic maven compiler version based of the projects java version\n\u0026lt;!-- JAVA COMPILER VERSIONS --\u0026gt; \u0026lt;java.version\u0026gt;11\u0026lt;/java.version\u0026gt; \u0026lt;maven.compiler.source\u0026gt;${java.version}\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;${java.version}\u0026lt;/maven.compiler.target\u0026gt; Also in the properties tag, additionally to the base dependencies from Minimal example application add the dependency version for FXGL and the build plugins.\n\u0026lt;!-- DEPENDENCIES VERSIONS --\u0026gt; \u0026lt;slf4j.version\u0026gt;2.0.0-alpha0\u0026lt;/slf4j.version\u0026gt; \u0026lt;pi4j.version\u0026gt;2.0-SNAPSHOT\u0026lt;/pi4j.version\u0026gt; \u0026lt;fxgl.version\u0026gt;11.16\u0026lt;/fxgl.version\u0026gt; \u0026lt;!-- BUILD PLUGIN VERSIONS --\u0026gt; \u0026lt;exec-maven-plugin.version\u0026gt;1.6.0\u0026lt;/exec-maven-plugin.version\u0026gt; \u0026lt;maven-compiler-plugin.version\u0026gt;3.8.1\u0026lt;/maven-compiler-plugin.version\u0026gt;  In the FXGL version 11.16 sepcial javaFX libraries are included to run on raspberryPi\n Add following dependency for FXGL:\n\u0026lt;dependencies\u0026gt; \u0026lt;!-- FXGL library which includes JavaFX --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.almasb\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fxgl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${fxgl.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; The following code is used to build the application in order to run it on the raspberryPi. Insert the module path and the path to the main class at the with [INSERT MODULE PATH] marked location.  For example: com.pi4j.example/com.pi4j.example.FxglExample\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- JAVA COMPILER --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-compiler-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;release\u0026gt;${java.version}\u0026lt;/release\u0026gt; \u0026lt;showDeprecation\u0026gt;true\u0026lt;/showDeprecation\u0026gt; \u0026lt;showWarnings\u0026gt;true\u0026lt;/showWarnings\u0026gt; \u0026lt;verbose\u0026gt;false\u0026lt;/verbose\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- DEFAULT JAR EXECUTABLE CLASS --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.mojo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;exec-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${exec-maven-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;java\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;executable\u0026gt;java\u0026lt;/executable\u0026gt; \u0026lt;arguments\u0026gt; \u0026lt;argument\u0026gt;--module-path\u0026lt;/argument\u0026gt; \u0026lt;argument\u0026gt;${project.build.directory}/distribution\u0026lt;/argument\u0026gt; \u0026lt;argument\u0026gt;--module\u0026lt;/argument\u0026gt; \u0026lt;argument\u0026gt;[INSERT MODULE PATH]\u0026lt;/argument\u0026gt; \u0026lt;/arguments\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- BUILD THE FINAL JAR FILE IN THE /target/distribution PATH --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.2\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/distribution\u0026lt;/outputDirectory\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- COPY ANY RUNTIME SCRIPTS TO THE /target/distribution PATH --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-antrun-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;target\u0026gt; \u0026lt;copy todir=\u0026#34;${project.build.directory}/distribution\u0026#34; overwrite=\u0026#34;true\u0026#34; flatten=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;fileset dir=\u0026#34;assets\u0026#34; includes=\u0026#34;*.sh\u0026#34;\u0026gt;\u0026lt;/fileset\u0026gt; \u0026lt;/copy\u0026gt; \u0026lt;chmod dir=\u0026#34;${project.build.directory}/distribution\u0026#34; perm=\u0026#34;ugo+rx\u0026#34; includes=\u0026#34;**/*.sh\u0026#34;/\u0026gt; \u0026lt;/target\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;run\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- DOWNLOAD RUNTIME DEPENDENCIES --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-dependency-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;copy-dependencies\u0026lt;/id\u0026gt; \u0026lt;phase\u0026gt;process-sources\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;copy-dependencies\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;outputDirectory\u0026gt;${project.build.directory}/distribution\u0026lt;/outputDirectory\u0026gt; \u0026lt;includeScope\u0026gt;runtime\u0026lt;/includeScope\u0026gt; \u0026lt;excludeTransitive\u0026gt;false\u0026lt;/excludeTransitive\u0026gt; \u0026lt;overWriteReleases\u0026gt;false\u0026lt;/overWriteReleases\u0026gt; \u0026lt;overWriteSnapshots\u0026gt;true\u0026lt;/overWriteSnapshots\u0026gt; \u0026lt;overWriteIfNewer\u0026gt;true\u0026lt;/overWriteIfNewer\u0026gt; \u0026lt;!-- On the Raspberry Pi we use specific JavaFX dependencies, so we exclude them here and they are added in the run-script. --\u0026gt; \u0026lt;excludeGroupIds\u0026gt;org.openjfx\u0026lt;/excludeGroupIds\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; Add module-info In our build we run modules. This module has to be defined in module-info.java.\nAdd all required dependencies for your project here.\nMore info for modular FXGL here\nopen module com.pi4j.example { // Pi4J MODULES requires com.pi4j; requires com.pi4j.plugin.pigpio; // SLF4J MODULES  requires org.slf4j; requires org.slf4j.simple; requires com.almasb.fxgl.all; uses com.pi4j.extension.Extension; uses com.pi4j.provider.Provider; // allow access to classes in the following namespaces for Pi4J annotation processing  exports com.pi4j.example to com.almasb.fxgl.core; } "},{"uri":"https://pi4j.com/getting-started/fxgl/kiosk-mode/","title":"JavaFX kiosk mode","tags":[],"description":"","content":" Visit webtechie.be for the full blogpost\n Kiosk Mode With Gluon\u0026rsquo;s JavaFX 17-ea, we are able to run applications in different modes: Desktop and Kiosk mode. In this post we focus on the Kiosk mode only.\nWith this approach, the application is the only thing you see on the screen. This prevents the user to open any other applications, or mess up your system. In this case, there is no need for a window manager, and the application directly uses the underlying (hardware) framebuffer. To achieve this, we use Monocle with EGL and DRM, as that is the Linux approach to directly address the hardware acceleration, without a window manager. The JavaFX application is using Direct Rendering Mode (DRM) to be visualized. An extra benefit is the performance boost, as your program is the only thing that needs to be handled towards the screen.\n By using /sbin/init 3 before the application starts, the desktop mode is stopped. As DRM in JavaFX 17-ea is part of the commercial license of Gluon, we need to set the environment value ENABLE_GLUON_COMMERCIAL_EXTENSIONS, for more info see Gluon docs: “JavaFX on Embedded” \u0026gt; “Legal notice”. The display id needs to be defined, if card0 is not working and you get the error [GluonDRM] Device /dev/dri/card0 could be opened, but has no drm capabilities., try card1. More info is provided on Gluon docs: “JavaFX on Embedded” \u0026gt; “Testing JavaFX”. After the application is stopped, we call /sbin/init 5 to restart the regular desktop environment.  #!/usr/bin/env bash /sbin/init 3 export ENABLE_GLUON_COMMERCIAL_EXTENSIONS=true java \\  -Degl.displayid=/dev/dri/card0 \\  -Dmonocle.egl.lib=/opt/javafx-sdk-17/lib/libgluon_drm-1.1.3.so \\  -Djava.library.path=/opt/javafx-sdk-17/lib \\  -Dmonocle.platform.traceConfig=false \\  -Dprism.verbose=false \\  -Djavafx.verbose=false \\  -Dmonocle.platform=EGL \\  --module-path .:/opt/javafx-sdk-17/lib \\  --add-modules javafx.controls \\  --module com.pi4j.example/com.pi4j.example.FxglExample $@ /sbin/init 5 To run the application in kiosk mode it is recommended to have an open ssh session on the side to follow the process or in case of errors, being able to restart the desktop with:\n/sbin/init 5 Performance By disabling the window manager, more ressources are available for the application, therefore running more performant. To test the performance of the windowed mode and kiosk mode, several tests have been executed.\nRaspberryPi model: RaspberryPi 4 8G Model B\nThe tests were run with 50, 100 and 500 balls. The results of the study show that even thought many more resources are available, the game does not run the expected amount smoother. A slight increase of RAM and CPU is noticeable, but the average frames per second do not improve that much. Non the less, the FPS was more stable while running in kiosk mode and might be an advantage when running games.\nOverall the kiosk mode has advantages over the windowed mode but using the kiosk mode exclusively to boost the performance is not recommended.\nExtra tips Gluon documentation Gluon keeps the documentation for Raspberry Pi constantly updated, keep an eye on gluonhq to stay up-to-date.\n64-bit OS and JavaFX If you want to go 64-bit, you can use the same approach. There is no official 64-bit Raspberry Pi OS yet, but you can find more information on “Faster \u0026amp; More Reliable 64-bit OS on Raspberry Pi 4 with USB Boot”.\nUnclutter Another great addition for a kiosk approach is Unclutter, a small tool which hides your mouse cursor when you do not need it. You only have to move the mouse for the cursor to reappear.\nsudo apt install unclutter To run the application in kiosk mode it is recommended to have an open ssh session on the side to follow the process or in case of errors, being able to restart the desktop with:\n/sbin/init 5 "},{"uri":"https://pi4j.com/documentation/providers/","title":"Choosing an I/O Provider","tags":[],"description":"","content":"Providers are extensible service modules responsible for the concrete implementation of a specific I/O type. Multiple providers for the same I/O type can be loaded into a Pi4J context concurrently. For example a \u0026ldquo;RaspberryPi-DigitalInputProvider\u0026rdquo; and \u0026ldquo;GertBoard-DigitalInputProvider\u0026rdquo; could both be loaded and both providing digital inputs at the same time.\nThe providers also allow to separate the internal logic of the Pi4J core from the concrete implementation of the board on which they are used.\nCurrent supported providers:\n PiGpio  Pro  Most performant at this moment, natively Can be used remotely   Contra  Needs to run as sudo     LinuxFS  Pro  Generic for any SoC supporting LinuxFS Doesn\u0026rsquo;t need sudo   Contra  Latency (? - still to be tested)      Possible future providers:\n RemoteProvider to control the I/O from a remote device e.g. through websockets  "},{"uri":"https://pi4j.com/getting-started/javafx-mvc-template/","title":"JavaFX GUI and MVC template","tags":["Digital Input","Digital Output","JavaFX","Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-template-javafx\n The FHNW University created a template project which is now part of the Pi4J example repositories.\nThe goal of this project is to:\n Provide a clear step-by-step how to prepare your Raspberry Pi Provide multiple test and start applications Explain the use of a MVC-model (Model-View-Controller) to clearly split data, actions and user interface Explain the use of JUnit test  Sources and info Please check the README of the sources of the project for a full description of the setup process of the Raspberry Pi and to fully understand the example applications and the MVC-model. This page is only intended to give you a quick overview.\nExample applications HelloFX A simple application to test if the JavaFX libraries are installed correctly. Should not be used as a template for one\u0026rsquo;s own JavaFX applications.\nWiring The two other example applications use an LED and a button. These must be wired as is shown in the following diagram:\nMinimalPi4J The MinimalPi4j application is a Pi4j only application without a GUI. This application is also only used to test the setup and can be deleted after testing.\nPressing the button should generate a message in the console.\nOnce the Pi4J setup has been tested, MinimalPi4J can be deleted.\nTemplateApp This application shows the interaction between a JavaFX based Graphical User Interface (GUI) and the Raspberry Pi connected sensors and actuators, the Physical User Interface (PUI).\nThis application is to be used as a template for one\u0026rsquo;s own applications. This includes the existing test cases.\nYou should first get to know and understand the example. For your own applications you should then copy the the TemplateApp and modify it for your project, however without violating the rules of the MVC concept.\nTemplatePUIApp The MVC concept should also be used for applications without a GUI.\nWhen developing PUI only applications, or when adding the GUI later, then one should use the TemplatePUIApp as template.\nThe MVC concept The classic Model-View-Controller concept contains in addition to the starter class at least 3 more classes. The interaction is clearly defined:\nThis way the GUI and PUI are completely separated from each other, i.e a GUI button to turn an LED on has no direct access to the LED component of the PUI. Instead the GUI button triggers a corresponding action in the controller which then sets the on state property in the model. The PUI listening on this state then turns the actual LED on or off.\nGUI and PUI work with the same identical controller and thus also the same identical model.\nIn the MVC concept, every user interaction traverses the exact same cycle:\nConclusion You can use the same architecture (MVC) to implement a JavaFX-based GUI, a PUI attached to a Raspberry Pi, and integrate both in a clean, modular way.\n"},{"uri":"https://pi4j.com/documentation/build-io/","title":"Building an I/O Instance","tags":[],"description":"","content":"A GPIO can be configured like in the following example:\nvar ledConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;my-dout\u0026#34;) .name(\u0026#34;My Digital Output\u0026#34;) .address(GPIO_PIN) .shutdown(DigitalState.LOW) .initial(DigitalState.HIGH) .provider(\u0026#34;linuxfs-digital-output\u0026#34;); newConfigBuilder parameters id The id field is used internally inside the Pi4J context/runtime to keep track of the instances. If you don\u0026rsquo;t assign an id, Pi4J will create a unique ID string for the instance \u0026ndash; so its optional and only needed if you want to specify your own unique ID string.\nAdditionally, you can retrieve the I/O instance from the Pi4J context anywhere else in your program if needed by the id. This can help in some cases where you only need to pass around the single Pi4J context, and you can still gain access to the I/O instances without having to track and pass around your own variable references. So even if your variable reference to an I/O instance goes out of scope, Pi4J will maintain a reference to the I/O instance internally until it is shutdown().\n// Three ways to get existing LED output instance DigitalOutput led = pi4j.io(\u0026#34;my-led\u0026#34;); var led = (DigitalOutput)pi4j.io(\u0026#34;my-led\u0026#34;); var led = pi4j.io(\u0026#34;my-led\u0026#34;, DigitalOutput.class); Internally the I/O instances are maintained by the Registry. You can gain access to the Registry via the context. There are additional methods in registry to interrogate/discover/enumerate the created I/O instances at runtime.\n// Get the Pi4J I/O registry Registry registry = pi4j.registry(); // Check to see if the LED output already exists (by id) boolean myLedAlreadyExists = registry.exists(\u0026#34;my-led\u0026#34;); // Get all digital output instances from the Pi4J I/O registry var outputs = registry.allByIoType(IOType.DIGITAL_OUTPUT); name and description Fields like name and description are entirely optional and not used by Pi4J internally except to print if performing a describe() or toString() operation on Pi4J objects.\n// Create digital output I/O configuration var config = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;my-dout\u0026#34;) .name(\u0026#34;My Digital Output\u0026#34;) .address(GPIO_PIN) .shutdown(DigitalState.LOW) .initial(DigitalState.HIGH) .provider(\u0026#34;linuxfs-digital-output\u0026#34;); // Create digital output I/O instance using configuration var output = pi4j.create(config); // Print digital output object to system out output.describe().print(System.out); ---- // ... CONSOLE OUTPUT // \u0026gt; IO: \u0026#34;My Digital Output\u0026#34; {my-dout} \u0026lt;com.pi4j.plugin.linuxfs.provider.gpio.digital.LinuxFsDigitalOutput\u0026gt; {DOUT-26} Reuse the config The config object can be reused to create multiple GPIOs by overriding the address (and id if used) for each I/O instance:\nvar config = DigitalOutput.newConfigBuilder(pi4j) .provider(\u0026#34;linuxfs-digital-output\u0026#34;) .shutdown(DigitalState.LOW) .initial(DigitalState.LOW); var pin0 = pi4j.create(config.address(0).id(\u0026#34;my-led\u0026#34;)); var pin1 = pi4j.create(config.address(1).id(\u0026#34;my-relay\u0026#34;)); var pin2 = pi4j.create(config.address(2).id(\u0026#34;my-lock\u0026#34;)); var pin3 = pi4j.create(config.address(3).id(\u0026#34;my-pump\u0026#34;)); "},{"uri":"https://pi4j.com/examples/communityimplementation/","title":"Community Implementations","tags":[],"description":"","content":"On this page we want to keep a list of projects which contain implementation code for specific devices using the Pi4J V.2 core library. Please let us know via Pi4J V.2 Discussions if you want to have your project added to this list.\nCurrent available device support projects    Device(s) Developed by Link     1602A LCD HD44780U Thomas Aarts github.com/Pi4J/pi4j-example-devices   1602A_LCD_PCF8574A I2C Controller Thomas Aarts github.com/Pi4J/pi4j-example-devices   1602A LCD MCP23017 I2C Controller Thomas Aarts github.com/Pi4J/pi4j-example-devices   ADS1256 24bit A-to-D Thomas Aarts github.com/Pi4J/pi4j-example-devices   BMP280 Temperature and Pressure Sensor Thomas Aarts github.com/Pi4J/pi4j-example-devices   DAC8552 16bit DAC SPI connected Thomas Aarts github.com/Pi4J/pi4j-example-devices   DHT22 Temp/Humidity sensor Thomas Aarts github.com/Pi4J/pi4j-example-devices   IS31FL3731 matrix controller Thomas Aarts github.com/Pi4J/pi4j-example-devices   MCP23008 drive and read chip GPIOs Thomas Aarts github.com/Pi4J/pi4j-example-devices   MCP23008 and MCP23017 Pin monitoring Thomas Aarts github.com/Pi4J/pi4j-example-devices   MCP23017 drive and read chip GPIOs Thomas Aarts github.com/Pi4J/pi4j-example-devices   MCP3008 A/D 10bit converter Thomas Aarts github.com/Pi4J/pi4j-example-devices   MCP4725 12 bit DAC Thomas Aarts github.com/Pi4J/pi4j-example-devices   SN74HC595 8 Bit shift register Thomas Aarts github.com/Pi4J/pi4j-example-devices   TCA9548 (1x8 I2C switch) Thomas Aarts github.com/Pi4J/pi4j-example-devices   VL53L0X TimeOfFlight device Thomas Aarts github.com/Pi4J/pi4j-example-devices    "},{"uri":"https://pi4j.com/getting-started/learn-more/","title":"Learn more...","tags":[],"description":"","content":"Pi4J is used in a lot of projects, and you can find a lot of examples online. On this page we want to keep an up-to-date list. Do you want to add something? Please hit \u0026ldquo;Edit this page\u0026rdquo; on the top and create a pull request!\nTwitter Please share your personal or professional projects where you combine Java and the Raspberry Pi on Twitter with the hashtag #JavaOnRaspberryPi.\nOnline articles  Foojay.io is a place for friends of OpenJDK, providing articles, updated analyses, selected highlights, and categorized lists on all things Java. There is also a category of posts dedicated to Java on the Raspberry Pi..  Books Getting Started with Java on the Raspberry Pi This book by Frank Delporte includes a lot of info and history about Java itself and how to install it on the Raspberry Pi. Also, a lot of tips and tricks to become or be a better developer. And above all many simple examples on these and even more other topics:\n The magic of Bits and Bytes and solving the confusion of Java signed values with the help of a led number display. Beautiful user interfaces made with JavaFX so you can interact with the hardware. Pi4J applications to be able to control different types of hardware like LEDs, buttons, displays, led strips, relay boards, and many more. Spring applications to interact with your Pi via web interfaces. How to set up a queue to send and receive messages to and from Arduino boards or other Pi’s. Interviews with Karen Mouws (STEM and diversity), Trisha Gee (IntelliJ IDEA), Xiaokai He (Visual Studio Code), Alexander Belokrylov (BellSoft Liberica JDK), Jakob Jenkov (Java and tutorials.jenkov.com), Johan Vos (OpenJFX, JavaFX and GluonHQ), Gerrit Grunwald (Java, JavaFX, TilesFX), Mark Heckler (Spring), Vlad Mihalcea (JPA, Hibernate)  The ebook is available on Leanpub and the paper book on Elektor.\n"},{"uri":"https://pi4j.com/examples/communityimplementation/prototype-board/","title":"Prototype Board","tags":["Prototype"],"description":"","content":"A Versatile Prototype Board Experimenting with various ICs \u0026lsquo;chips\u0026rsquo; may require different methods to connect the chip to the Pi. As shown in the BMP280 usage a chip maybe available mounted on a small circuit board where connection to the Pi requires only jumpers. But even this simple means has limits as connecting several chips when using a Pi case and maybe a cooling fan creates problems. In addition some chips are only available as a socket device where a 4-28 pin socket is required. This next section demonstrates \u0026lsquo;a\u0026rsquo; way these limits can be overcome.\nConnecting to the Pi The use of breadboards adds flexibility in the ways to install and jumper to various chips. After soldering the pins to the chip breadboards you can use female-female jumpers to connect directly to the Pi Gpio pins from more than one chip breadboard.\nAlso, the jumper connections to the Pi are simplified by extending the Pi gpios to an external Gpio breadboard.\nPower off the Pi with sudo shutdown prior to making connections.\n Component and wiring Ribbon Cable Connecting directly to the Pi 40 pin connector becomes difficult as the number of terminations increase and the use of a case and fan require minor disassembly. The 40 pin connector can be extended to a Gpio breadboard. This extension is possible with a ribbon cable.\n    Ribbon cable and breadboards\n                               Once the ribbon cable is attached to the Pi 40 pin connector the Pi case can be secured.\n   Prototyope power\n    Ribbon cable termination Using a 40 pin connector labeled for a Pi facilitates installing jumpers. The Gpio breadboard terminates the ribbon cable. The Gpio breadboard is wired to supply 3.3v 5v and ground through multiple pins to facilitate use of multiple chip breadboards.\n   Prototype pi_40_pin_extension\n    The use of a 28 pin socket will accommodate many different chips.\n   Prototype pi_28_pin_socket\n    Soldering the 28 pin socket and pins associated with each of the 28 pins provides jumper connections to all pins of the inserted chip.\nThe chip breadboard also provides sets of pins for 3.3v 5v and ground. Single jumpers from the Gpio breadboard to this chip breadboard provides these multiple pins.\n   Prototype board\n    Complete At this point a chip can be plugged into the 28 pin connector. If you insert the chip with its pin 1 at the pin 1 of the chip breadboard it simplifies pin identification between the chips datasheet and its breadboard connection. Using the chips Datasheet jumpers connect between pins of the chip to the Pi GPIOs on Gpio breadboard connector or 5v/3.3v and ground on the chip breadboard.\n   Prototype complete\n    "},{"uri":"https://pi4j.com/examples/communityimplementation/bmp280/","title":"BMP280 Sensor","tags":["BMP280"],"description":"","content":"Description The BMP280 is a Pressure and temperature sensor accessed via I2C or SPI. The BMP280 is a simple device that requires the connection of few wires to operate. Because of this simplicity the device can serve as a very easy project for initial Pi and Pi4j usage. This document will explain the more simple means to connect the sensor and access the device with existing software requiring no coding. The document will also explain minimal coding required to allow greater flexibility.\nA later section explains creating a more robust proto-type environment to better support using variuos integrated circuits, see Prototype board.\nConnecting Adafruit BMP280 After soldering the pins to the PCB you can use female-female jumpers to connect directly to the Pi GPIO pins.\nPower off the Pi with sudo shutdown prior to making connections. Or if you complete these connections with power applied, connect CS to 3.3v before connecting Vin. This is required to ensure the I2C interface is enabled, else the chip enables SPI communication protocol.\n Component and wiring BMP280 module The following shot is the Adafruit BMP280 module. The BMP280 chip is mounted on a small circuit board with pins to solder in for connections.\n    BMP280 module\n                               40 pin identification This shot is the Pi with an easy to read card that identifies the 40 pin connector.\n   BMP280 pi_canca_card\n    40 pin connection This is the BMP280 module connected to the Pi 40 pin connector.\n   BMP280 wire_cmpl\n    Header Pin/Colors – Pi 40 pin connector    Pin Color Description     Vin Red to Pi 3.3 pin 1   3v N/C    Gnd Brown to Pi pin 6   SCK Green to Pi pin 5   SDO N/C    SDI Blue to Pi pin 3   CS Orange to Pi pin 17    Validate Connections Power on the Pi. Log in as usual. Run the command i2cdetect -y 1. This command will display all I2C devices connected to I2C bus 1. In this case only the BMP280 is connected so the table should include a device 77, 0x77 being the device address of the BMP280.\n   BMP280 i2cdetect\n    Build via Maven The Pi4j project uses git via github for the source code repository. The main Pi4J documentation provides details of the repository and maven build process.\nThe project Example Devices uses the prescribed Maven build process. It is easiest to git clone the Example Devices directory and use these steps to build. Note: each device within this directory contains a README.md that explains the expected Hardware connections, build process, and how to use the device via these modules.\n$ mvn clean package $ cd target/distribution $ sudo ./runBMP280.sh Program output [main] INFO com.pi4j.util.Console - I2C detail : com.pi4j.plugin.linuxfs.provider.i2c.LinuxFsI2C@45018215 bus : 1 address : 119 [main] INFO com.pi4j.util.Console - Temperatue C = 32.37366343149915 [main] INFO com.pi4j.util.Console - Temperatue F = 90.27259417669848 [main] INFO com.pi4j.util.Console - Pressure Pa = 97930.29684231618 [main] INFO com.pi4j.util.Console - Pressure InHg = 28.91894505802476 [main] INFO com.pi4j.util.Console - Pressure mb = 979.2223518169782 Supporting BMP280 Source Code BMP280 source files\nThis is part of a larger project Example Devices\nCode A simple example on how to use the BMP280 sensor. This requires Example Devices was built.\npackage com.pi4j.test.devices.bmp280; import com.pi4j.Pi4J; import com.pi4j.devices.bmp280.BMP280Device; import com.pi4j.plugin.linuxfs.provider.i2c.LinuxFsI2CProvider; import com.pi4j.util.Console; public class BMP280 { public static void main(String[] args) throws Exception { // ------------------------------------------------------------  // Initialize the Pi4J Runtime Context  // ------------------------------------------------------------  // Before you can use Pi4J you must initialize a new runtime  // context.  //  // The \u0026#39;Pi4J\u0026#39; static class includes a few helper context  // creators for the most common use cases. The \u0026#39;newAutoContext()\u0026#39;  // method will automatically load all available Pi4J  // extensions found in the application\u0026#39;s classpath which  // may include \u0026#39;Platforms\u0026#39; and \u0026#39;I/O Providers\u0026#39;  var pi4j = Pi4J.newContextBuilder().add( LinuxFsI2CProvider.newInstance()).build(); // print installed providers  System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); System.out.println(\u0026#34;PI4J PROVIDERS\u0026#34;); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); pi4j.providers().describe().print(System.out); System.out.println(\u0026#34;----------------------------------------------------------\u0026#34;); final Console console = new Console(); console.print(\u0026#34;==============================================================\u0026#34;); console.print(\u0026#34;startup BMP280 \u0026#34;); console.print(\u0026#34;==============================================================\u0026#34;); var bmpDev = new BMP280Device(pi4j, console, 1, 0x77, \u0026#34;info\u0026#34;); bmpDev.initSensor(); console.println(\u0026#34; Dev I2C detail \u0026#34; + bmpDev.i2cDetail()); console.println(\u0026#34; Setup ----------------------------------------------------------\u0026#34;); console.println(\u0026#34; I2C detail : \u0026#34; + bmpDev.i2cDetail()); double reading1 = bmpDev.temperatureC(); console.println(\u0026#34; Temperatue C = \u0026#34; + reading1); double reading2 = bmpDev.temperatureF(); console.println(\u0026#34; Temperatue F = \u0026#34; + reading2); double press1 = bmpDev.pressurePa(); console.println(\u0026#34; Pressure Pa = \u0026#34; + press1); double press2 = bmpDev.pressureIn(); console.println(\u0026#34; Pressure InHg = \u0026#34; + press2); double press3 = bmpDev.pressureMb(); console.println(\u0026#34; Pressure mb = \u0026#34; + press3); // Shutdown Pi4J  pi4j.shutdown(); } } "},{"uri":"https://pi4j.com/documentation/io-examples/","title":"I/O Examples","tags":[],"description":"","content":"Here you can find detailed examples for the different functionalities of Pi4J per I/O type.\n Digital Output (GPIO)   Digital Input (GPIO)   Pulse Width Modulation (PWM)   Inter-Integrated Circuit (I²C)   Serial Peripheral Interface (SPI)   Serial (UART/RS232)   The supported low-level I/O interface types are defined in the core library as an enumerated list.\nANALOG_INPUT(AnalogInputProvider.class, AnalogInput.class, AnalogInputConfig.class, AnalogInputConfigBuilder.class), ANALOG_OUTPUT(AnalogOutputProvider.class, AnalogOutput.class, AnalogOutputConfig.class, AnalogOutputConfigBuilder.class), DIGITAL_INPUT(DigitalInputProvider.class, DigitalInput.class, DigitalInputConfig.class, DigitalInputConfigBuilder.class), DIGITAL_OUTPUT(DigitalOutputProvider.class, DigitalOutput.class, DigitalOutputConfig.class, DigitalOutputConfigBuilder.class), PWM(PwmProvider.class, Pwm.class, PwmConfig.class, PwmConfigBuilder.class), I2C(I2CProvider.class, com.pi4j.io.i2c.I2C.class, I2CConfig.class, I2CConfigBuilder.class), SPI(SpiProvider.class, Spi.class, I2CConfig.class, I2CConfigBuilder.class), SERIAL(SerialProvider.class, Serial.class, SerialConfig.class, SerialConfigBuilder.class); "},{"uri":"https://pi4j.com/documentation/registry/","title":"I/O Registry","tags":[],"description":"","content":"An additional V.2 feature is an I/O registry where all I/O instances that have been created can be maintained, managed, re-accessed, etc. As the library keeps track of all the created I/O instances, they become publicly accessible through a registry where users can interrogate, iterate, identify and access all created I/O instances that Pi4J is managing.\nThis is very useful for add-ons/plugins that want to provide runtime information about the state of all I/O, for example a web app illustrating the current state of I/O.\nThe registry is responsible for managing I/O instance lifecycles and provides a means for your program to easily access any I/O instance using its unique identifier.\n"},{"uri":"https://pi4j.com/examples/jbang/","title":"JBang Examples","tags":["JBang"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-jbang\n Want to get started with Java programming on the Raspberry Pi?\nJBang is a great way to create your first program to control electronic components connected to the GPIO pins. What is JBang?\nWhat is JBang? As described on their website:\nJBang lets Students, Educators and Professional Developers create, edit and run self-contained source-only Java programs with unprecedented ease.\n Want to learn, explore or use Java instantly without setup? Do you like Java but use python, groovy, kotlin or similar languages for scripts, experimentation and exploration? Ever wanted to just be able to run Java from anywhere without any or very minimal setup? Ever tried out Java 11+ support for running .java files directly in your shell but felt it was a bit too cumbersome?  JBang lets you do all this!\nGet Started with JBang on Raspberry Pi Prerequisites  A Raspberry Pi with recent Raspberry Pi OS. Install JBang as described on jbang.dev/download. JBang will install Java if it\u0026rsquo;s not installed yet.  # Install JBang $ curl -Ls https://sh.jbang.dev | bash -s - app setup # Check JBang by requesting its version $ jbang --version 0.109.0  OPTIONAL: Use Visual Studio Code, the free IDE.  # Install Visual Studio Code $ sudo apt install code  OPTIONAL: Install the following extensions in Visual Studio Code:  Language Support for Java(TM) by Red Hat JBang    Example scripts The Pi4J JBang project on GitHub contains several examples to demonstrate both JBang and Pi4J. Each java-file is a full-containing runnable JBang application. This means you don\u0026rsquo;t need Maven, Gradle, or other Java build tool.\nTo tell JBang that it must handle the file as a Java application and do some upfront preparation work, the first line in each file is: ///usr/bin/env jbang \u0026quot;$0\u0026quot; \u0026quot;$@\u0026quot; ; exit $?.\nWhen an application needs dependencies, they are defined inside the file itself in a line starting with //DEPS. For instance, to use the Pi4J Core library: //DEPS com.pi4j:pi4j-core:2.3.0.\nEach of the provided examples contains more information about the wiring inside the file itself and are also explained here on the Pi4J website.\nGet the Examples from GitHub You can clone the project with the examples to your Raspberry Pi in the terminal with the following commands:\n$ git clone https://github.com/Pi4J/pi4j-jbang $ cd pi4j-jbang Video Demo This approach to demonstrate Pi4J with JBang has been explained and demonstrated on Voxxed Days Brussels on May 23th, 2023.\n  "},{"uri":"https://pi4j.com/documentation/shutdown/","title":"Shutting down the Pi4J Context","tags":[],"description":"","content":"At the end of our application, the context needs to be shutdown to release the I/O and clean up the used resources.\n# Start of program var pi4j = Pi4J.newAutoContext(); # YOUR CODE GOES HERE # End of program pi4j.shutdown(); "},{"uri":"https://pi4j.com/examples/jbang/jbang_minimal_example/","title":"Minimal Example","tags":["JBang","DigitalInput","DigitalOuput","LED","Button"],"description":"","content":"Minimal Pi4J with JBang example GITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; Pi4JMinimalExample.java\n Intro Before proceeding with this example, make sure that you have a Raspberry Pi prepared to execute Java code with JBang as explained here.\n The following example is based on the \u0026ldquo;Minimal example application\u0026rdquo;, and uses the same wiring with a button and LED. By using JBang we can run this project with a single file without the need of a full Maven or Gradle project, or compiling the Java code.\nCreate a new file JBangPi4JExample.java with the following content:\nApplication ///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $?  //DEPS org.slf4j:slf4j-api:1.7.35 //DEPS org.slf4j:slf4j-simple:1.7.35 //DEPS com.pi4j:pi4j-core:2.3.0 //DEPS com.pi4j:pi4j-plugin-raspberrypi:2.3.0 //DEPS com.pi4j:pi4j-plugin-pigpio:2.3.0  import com.pi4j.Pi4J; import com.pi4j.io.gpio.digital.DigitalInput; import com.pi4j.io.gpio.digital.DigitalOutput; import com.pi4j.io.gpio.digital.DigitalState; import com.pi4j.io.gpio.digital.PullResistance; import com.pi4j.util.Console; public class Pi4JMinimalExample { // Connect a button to PIN 18 = BCM 24  private static final int PIN_BUTTON = 24; // Connect a LED to PIN 15 = BCM 22  private static final int PIN_LED = 22; private static int pressCount = 0; public static void main(String[] args) throws Exception { final var console = new Console(); var pi4j = Pi4J.newAutoContext(); var ledConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;led\u0026#34;) .name(\u0026#34;LED Flasher\u0026#34;) .address(PIN_LED) .shutdown(DigitalState.LOW) .initial(DigitalState.LOW) .provider(\u0026#34;pigpio-digital-output\u0026#34;); var led = pi4j.create(ledConfig); var buttonConfig = DigitalInput.newConfigBuilder(pi4j) .id(\u0026#34;button\u0026#34;) .name(\u0026#34;Press button\u0026#34;) .address(PIN_BUTTON) .pull(PullResistance.PULL_DOWN) .debounce(3000L) .provider(\u0026#34;pigpio-digital-input\u0026#34;); var button = pi4j.create(buttonConfig); button.addListener(e -\u0026gt; { if (e.state() == DigitalState.LOW) { pressCount++; console.println(\u0026#34;Button was pressed for the \u0026#34; + pressCount + \u0026#34;th time\u0026#34;); } }); while (pressCount \u0026lt; 5) { if (led.equals(DigitalState.HIGH)) { console.println(\u0026#34;LED low\u0026#34;); led.low(); } else { console.println(\u0026#34;LED high\u0026#34;); led.high(); } Thread.sleep(500 / (pressCount + 1)); } pi4j.shutdown(); } } Running the Application Because this example uses the PiGpio plugin, we need to execute it with sudo:\nWithout the need of any further configuration, installation, dependency download, or compiling, we should now be able to run this code with:\n$ sudo `which jbang` JBangPi4JExample.java Downloading JDK 11. Be patient, this can take several minutes... [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED low [Thread-0] INFO com.pi4j.util.Console - Button was pressed for the 1th time [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high [Thread-2] INFO com.pi4j.util.Console - Button was pressed for the 2th time [main] INFO com.pi4j.util.Console - LED low [main] INFO com.pi4j.util.Console - LED high ... [main] INFO com.pi4j.util.Console - LED high [main] INFO com.pi4j.util.Console - LED low [Thread-8] INFO com.pi4j.util.Console - Button was pressed for the 5th time Conclusion With JBang we can have a single-source Java file that can be executed without the need for a full Maven or Gradle project. And we don\u0026rsquo;t even need to compile anything!\nJBang is a great way to simply run Java-files, helps you to quickly get started with Pi4J on the Raspberry Pi, and can be the ideal getting-started method to experiment with electronics and Java.\n"},{"uri":"https://pi4j.com/examples/jbang/bme280_temperature_humidity_pressure/","title":"BME280 Sensor","tags":["JBang","BME280","BMP208"],"description":"","content":"BME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang GITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; Pi4JTempHumPressI2C.java and github.com/Pi4J/pi4j-jbang \u0026gt; Pi4JTempHumPressSpi.java\n Intro This is an example project to demonstrate how to read the temperature, humidity and pressure from a BME280 sensor, installed on an Adafruit board that can be controlled via I2C and SPI. Such a sensor itself is a very tiny component that can be integrated in phones and many other types of devices.\nTypically, when you want to integrate such a device in a project, you\u0026rsquo;ll need to dive into the Data Sheet to find out how it needs to be controlled. If you want to better understand the code from this example, you can check the Data Sheet as the register read-outs and calculations are based on the example code you can find in that document.\n    BME280 on an Adafruit board\n      BME280 on an Adafruit board\n      BME280 is very small\n                               Video This tutorial is also explained in this video:\n  Enable I2C and SPI We will be using both I2C and SPI for this experiment, so we need to make sure they are enabled:\n Open a terminal Execute sudo raspi-config Go to \u0026ldquo;Interface Options\u0026rdquo; Go to \u0026ldquo;I2C\u0026rdquo; and select \u0026ldquo;Yes\u0026rdquo; Go to \u0026ldquo;SPI\u0026rdquo; and select \u0026ldquo;Yes\u0026rdquo;  Wiring Wiring for I2C As this board can be controlled with both I2C and SPI, there are more available connections than we need for I2C. Make the following connections between the BME280 and a Raspberry Pi:\n Vin to 3.3V GND to GND SCK to I2C clock SCL (pin 5) SDI to I2C data SDA (pin 3) CS to 3.3V  The connection order is documented in the datasheet, and mentions that a connection between the CS pin and 3.3V is required to enable the I2C interface, before the VCC pin is connected to 3.3V. Failure to do this could lead to frustrating debugging\u0026hellip;\n In the wiring diagram, another brand of board (Sparkfun) is used, which has the I2C and SPI connections on different sides, but to align it with the pictures, the same connections are used as are available on the Adafruit board.\n   BME280 I2C wiring\n      BME280 I2C wiring\n      BME280 I2C wiring\n    Check the I2C Wiring After the wiring has been completed, you can check if the device is connected correctly by checking if the I2C device is detected. Make sure I2C is enabled on the Raspberry Pi, as mentioned before. When everything went OK, you should now see that a device is detected on I2C address 0x77:\n$ i2cdetect -y 1 0 1 2 3 4 5 6 7 8 9 a b c d e f 00: -- -- -- -- -- -- -- -- 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- 77 On modern Raspberry Pi OS releases, you can run this command without sudo. The -y disables interactive mode, so it just goes ahead and scans. The 1 specifies the I2C bus.\nWiring for SPI Make the following connections between the BME280 and a Raspberry Pi:\n Vin to 3.3V GND to GND SDI to MOSI (BCM10, pin 19) SDO to MISO (BCM9, pin 21) SCK to SCLK (BCM11, pin 23) CS to BCM21 (pin 40)  In the wiring diagram, another brand of board (Sparkfun) is used, which has the I2C and SPI connections on different sides, but to align it with the pictures, the same connections are used as are available on the Adafruit board.\n    BME280 SPI wiring\n      BME280 SPI wiring\n      BME280 SPI wiring\n      BME280 SPI wiring\n    Application Before proceeding with this example, make sure that you have a Raspberry Pi prepared to execute Java code with JBang as explained here.\n Because I2C and SPI require different dependencies, imports and settings, two separate example files are provided:\n Pi4JTempHumPressI2C.java Pi4JTempHumPressSpi.java  Each of these two files contain all settings and code to be compiled and executed with JBang.\nDependencies and Imports First we need to start with an extra line to instruct JBang to handle it as a Java application, and download the dependencies.\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? Then we can define the dependencies and imports.\nDependencies and Imports for I2C //DEPS org.slf4j:slf4j-api:1.7.35 //DEPS org.slf4j:slf4j-simple:1.7.35 //DEPS com.pi4j:pi4j-core:2.3.0 //DEPS com.pi4j:pi4j-plugin-raspberrypi:2.3.0 //DEPS com.pi4j:pi4j-plugin-linuxfs:2.3.0 Then we can define the imports as we would do in any Java file:\nimport com.pi4j.Pi4J; import com.pi4j.util.Console; import com.pi4j.io.i2c.I2C; import com.pi4j.io.i2c.I2CConfig; import com.pi4j.io.i2c.I2CProvider; import java.text.DecimalFormat; Dependencies and Imports for SPI ///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $?  //DEPS org.slf4j:slf4j-api:1.7.35 //DEPS org.slf4j:slf4j-simple:1.7.35 //DEPS com.pi4j:pi4j-core:2.3.0 //DEPS com.pi4j:pi4j-plugin-raspberrypi:2.3.0 //DEPS com.pi4j:pi4j-plugin-linuxfs:2.3.0 //DEPS com.pi4j:pi4j-plugin-pigpio:2.3.0 Then we can define the imports as we would do in any Java file:\nimport com.pi4j.Pi4J; import com.pi4j.io.gpio.digital.DigitalOutput; import com.pi4j.io.gpio.digital.DigitalState; import com.pi4j.io.spi.*; import com.pi4j.util.Console; import java.text.DecimalFormat; Main Method The main method initializes the sensor, and loops 10 times to the process of resetting the sensor, reading the values, and pauzing.\nMain Method for I2C private static final Console console = new Console(); // Pi4J Logger helper  private static final int I2C_BUS = 0x01; private static final int I2C_ADDRESS = 0x77; // When connecting SDO to GND = 0x76  public static void main(String[] args) throws Exception { var pi4j = Pi4J.newAutoContext(); // Initialize I2C  console.println(\u0026#34;Initializing the sensor via I2C\u0026#34;); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j) .id(\u0026#34;BME280\u0026#34;) .bus(I2C_BUS) .device(I2C_ADDRESS) .build(); // Read values 10 times  try (I2C bme280 = i2CProvider.create(i2cConfig)) { for (int counter = 0; counter \u0026lt; 10; counter++) { console.println(\u0026#34;**************************************\u0026#34;); console.println(\u0026#34;Reading values, loop \u0026#34; + (counter + 1)); resetSensor(bme280); // The sensor needs some time to make the measurement  Thread.sleep(300); getMeasurements(bme280); Thread.sleep(5000); } } pi4j.shutdown(); console.println(\u0026#34;**************************************\u0026#34;); console.println(\u0026#34;Finished\u0026#34;); } Main Method for SPI private static final Console console = new Console(); // Pi4J Logger helper  private static final String SPI_PROVIDER_NAME = \u0026#34;BME280 SPI Provider\u0026#34;; private static final String SPI_PROVIDER_ID = \u0026#34;BME280-spi\u0026#34;; private static final SpiChipSelect chipSelect = SpiChipSelect.CS_0; private static final SpiBus spiBus = SpiBus.BUS_0; private static final int csPin = 21; // BCM 21 = physical pin 40  private static DigitalOutput csGpio; private static Spi spi; public static void main(String[] args) throws Exception { var pi4j = Pi4J.newAutoContext(); // Initialize SPI  console.println(\u0026#34;Initializing the sensor via SPI\u0026#34;); var csGpioConfig = DigitalOutput.newConfigBuilder(pi4j) .id(\u0026#34;CS_pin\u0026#34;) .name(\u0026#34;CS\u0026#34;) .address(csPin) .shutdown(DigitalState.HIGH) .initial(DigitalState.HIGH) .provider(\u0026#34;pigpio-digital-output\u0026#34;); csGpio = pi4j.create(csGpioConfig); var spiConfig = Spi.newConfigBuilder(pi4j) .id(SPI_PROVIDER_ID) .name(SPI_PROVIDER_NAME) .bus(spiBus) .chipSelect(chipSelect) .baud(Spi.DEFAULT_BAUD) .mode(SpiMode.MODE_0) .provider(\u0026#34;pigpio-spi\u0026#34;) .build(); spi = pi4j.create(spiConfig); // Read values 10 times  for (int counter = 0; counter \u0026lt; 10; counter++) { console.println(\u0026#34;**************************************\u0026#34;); console.println(\u0026#34;Reading values, loop \u0026#34; + (counter + 1)); resetSensor(); // The sensor needs some time to make the measurement  Thread.sleep(300); getMeasurements(); Thread.sleep(5000); } pi4j.shutdown(); console.println(\u0026#34;**************************************\u0026#34;); console.println(\u0026#34;Finished\u0026#34;); } Reset and Readout of the Values The reset and value readout is inspired by the Adafruit CircuitPython library and is fully available in the sources on GitHub. It\u0026rsquo;s a combination of setting and reading registers, with different calculations. For example, for the temperature:\nbyte[] buff = new byte[6]; device.readRegister(BMP280Declares.press_msb, buff); long adc_T = (long) ((buff[3] \u0026amp; 0xFF) \u0026lt;\u0026lt; 12) | (long) ((buff[4] \u0026amp; 0xFF) \u0026lt;\u0026lt; 4) | (long) ((buff[5] \u0026amp; 0x0F) \u0026gt;\u0026gt; 4); ... DecimalFormat df = new DecimalFormat(\u0026#34;0.###\u0026#34;); // Temperature device.readRegister(readReg, compVal); long dig_t1 = castOffSignInt(compVal); device.readRegister(BMP280Declares.reg_dig_t2, compVal); int dig_t2 = signedInt(compVal); device.readRegister(BMP280Declares.reg_dig_t3, compVal); int dig_t3 = signedInt(compVal); double var1 = (((double) adc_T) / 16384.0 - ((double) dig_t1) / 1024.0) * ((double) dig_t2); double var2 = ((((double) adc_T) / 131072.0 - ((double) dig_t1) / 8192.0) * (((double) adc_T) / 131072.0 - ((double) dig_t1) / 8192.0)) * ((double) dig_t3); double t_fine = (int) (var1 + var2); double temperature = (var1 + var2) / 5120.0; console.println(\u0026#34;Temperature: \u0026#34; + df.format(temperature) + \u0026#34; °C\u0026#34;); console.println(\u0026#34;Temperature: \u0026#34; + df.format(temperature* 1.8 + 32) + \u0026#34; °F \u0026#34;); Running the Application Because JBang can download the dependencies and compile the code, we just need the Java-file to execute it.\nA side note regarding the humidity value: it turned out its value was lower compared to another device, while the temperature and pressure seemed to be close to expected. This appears to be a known issue. The manufacturer was involved in some hits and admits the chip can fall out of calibration depending storage and soldering conditions. They have a documented multistep process where you store the chip at different temperatures to potentially get it back to the correct humidity readout.\n Running the I2C Application The I2C example uses the LinuxFS plugin of Pi4J. This means it can be executed without the need to use sudo:\n$ jbang Pi4JTempHumPressI2C.java [jbang] Resolving dependencies... [jbang] org.slf4j:slf4j-api:1.7.35 [jbang] org.slf4j:slf4j-simple:1.7.35 [jbang] com.pi4j:pi4j-core:2.3.0 [jbang] com.pi4j:pi4j-plugin-raspberrypi:2.3.0 [jbang] com.pi4j:pi4j-plugin-pigpio:2.3.0 [jbang] com.pi4j:pi4j-plugin-linuxfs:2.3.0 [jbang] Dependencies resolved [jbang] Building jar... [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - Initializing the sensor via I2C [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Temperature: 21.287 °C [main] INFO com.pi4j.util.Console - Temperature: 70.316 °F [main] INFO com.pi4j.util.Console - Pressure: 100412.769 Pa [main] INFO com.pi4j.util.Console - Pressure: 1.004 bar [main] INFO com.pi4j.util.Console - Pressure: 0.991 atm [main] INFO com.pi4j.util.Console - Humidity: 52.7 % [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Reading values, loop 2 ... [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Finished Running the SPI Application As the PiGpio plugin is used, this example application must be executed with sudo:\n$ sudo `which jbang` Pi4JTempHumPressSpi.java [jbang] Resolving dependencies... [jbang] org.slf4j:slf4j-api:1.7.35 [jbang] org.slf4j:slf4j-simple:1.7.35 [jbang] com.pi4j:pi4j-core:2.3.0 [jbang] com.pi4j:pi4j-plugin-raspberrypi:2.3.0 [jbang] com.pi4j:pi4j-plugin-pigpio:2.3.0 [jbang] com.pi4j:pi4j-plugin-linuxfs:2.3.0 [jbang] com.pi4j:pi4j-plugin-pigpio:2.3.0 [jbang] Dependencies resolved [jbang] Building jar... [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - Initializing the sensor via SPI [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Reading values, loop 1 [main] INFO com.pi4j.util.Console - Temperature: 21.865 °C [main] INFO com.pi4j.util.Console - Temperature: 71.356 °F [main] INFO com.pi4j.util.Console - Pressure: 100419.804 Pa [main] INFO com.pi4j.util.Console - Pressure: 1.004 bar [main] INFO com.pi4j.util.Console - Pressure: 0.991 atm [main] INFO com.pi4j.util.Console - Humidity: 49.74 % [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Reading values, loop 2 ... [main] INFO com.pi4j.util.Console - ************************************** [main] INFO com.pi4j.util.Console - Finished Conclusion Once again, JBang proves to be the perfect companion to experiment with Pi4J and an electronics component!\nRead More The following sources have been used for this example:\n Pi4J_V2-TemperatureSensor example code by Tom Aarts Bosch BMP280 Data Sheet Bosch BME280 Data Sheet Bosch example code on GitHub Product page: \u0026ldquo;Adafruit BME280 I2C or SPI Temperature Humidity Pressure Sensor - STEMMA QT\u0026rdquo; Tutorial with Arduino code: \u0026ldquo;Adafruit BME280 Humidity + Barometric Pressure + Temperature Sensor Breakout\u0026rdquo; Adafruit_CircuitPython_BME280 library source code  "},{"uri":"https://pi4j.com/documentation/building/","title":"Building and running","tags":[],"description":"","content":"When you create your application with and IDE on the Raspberry Pi itself (e.g. with Visual Studio Code), you can simply run the application. But ofcourse, you want to build and package your project to easily deploy it on one or more Raspberry Pi\u0026rsquo;s.\nThere are different possibilities:\n Building with javac   Build as a FAT JAR with Maven   Build Java modules with Maven   Build Java modules with Gradle   Running Pi4J with JBang   "},{"uri":"https://pi4j.com/documentation/building/javac/","title":"Building with javac","tags":["Javac"],"description":"","content":"You can build a Pi4J project using only java and javac.\nWiring No wiring is needed for this minimal example as it only demonstrates how to create a minimal application which initializes Pi4J.\nJava release Any Java release over 11 is enough, check it with this command:\n$ java -version java 17.0.1 2021-10-19 LTS Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39) Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing) PI4J jar files You will need to download the Pi4J distribution from the Maven repository:\npi4j-distribution-2.1.1.zip\nExpand the file:\nunzip pi4j-distribution-2.1.1.zip\nAdd the lib directory to CLASSPATH by added this line to your .bashrc file:\nexport CLASSPATH=$CLASSPATH:~/pi4j-2.1.1/lib/*\nMinimal Java example file Use your preferred editor to create this GettingStartedExample.java file:\nimport com.pi4j.Pi4J; import com.pi4j.io.gpio.digital.DigitalOutput; import com.pi4j.platform.Platform; import com.pi4j.platform.Platforms; import com.pi4j.provider.Providers; import com.pi4j.registry.Registry; import com.pi4j.util.Console; public class GettingStartedExample { public static void main(String[] args) throws Exception { final var console = new Console(); console.title(\u0026#34;\u0026lt;-- The Pi4J Project --\u0026gt;\u0026#34;, \u0026#34;Getting Started Example\u0026#34;); var pi4j = Pi4J.newAutoContext(); Platforms platforms = pi4j.platforms(); console.box(\u0026#34;Pi4J PLATFORMS\u0026#34;); platforms.describe().print(System.out); console.println(); Platform platform = pi4j.platform(); console.box(\u0026#34;Pi4J DEFAULT PLATFORM\u0026#34;); platform.describe().print(System.out); console.println(); Providers providers = pi4j.providers(); console.box(\u0026#34;Pi4J PROVIDERS\u0026#34;); providers.describe().print(System.out); console.println(); Registry registry = pi4j.registry(); DigitalOutput output = pi4j.dout().create(1, \u0026#34;my-digital-output-1\u0026#34;); console.box(\u0026#34;Pi4J REGISTRY\u0026#34;); registry.describe().print(System.out); console.println(); pi4j.shutdown(); } } Compile the example javac GettingStartedExample.java\nExecute the example java GettingStartedExample\nIf everything is OK the output must be something similar to this, depending on your configuration:\n[main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - \u0026lt;-- The Pi4J Project --\u0026gt; [main] INFO com.pi4j.util.Console - Getting Started Example [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PLATFORMS | [main] INFO com.pi4j.util.Console - -------------------- PLATFORMS: [1] \u0026#34;Pi4J Runtime Platforms\u0026#34; \u0026lt;com.pi4j.platform.impl.DefaultPlatforms\u0026gt; ??PLATFORM: \u0026#34;RaspberryPi Platform\u0026#34; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - | Pi4J DEFAULT PLATFORM | [main] INFO com.pi4j.util.Console - --------------------------- PLATFORM: \u0026#34;RaspberryPi Platform\u0026#34; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PROVIDERS | [main] INFO com.pi4j.util.Console - -------------------- PROVIDERS: [12] \u0026#34;I/O Providers\u0026#34; \u0026lt;com.pi4j.provider.impl.DefaultProviders\u0026gt; ??DIGITAL_INPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalInputProvider\u0026gt; ? ??PROVIDER: \u0026#34;RaspberryPi Digital Input (GPIO) Provider\u0026#34; {raspberrypi-digital-input} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl} ? ??PROVIDER: \u0026#34;PiGpio Digital Input (GPIO) Provider\u0026#34; {pigpio-digital-input} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl} ??SERIAL: [2] \u0026lt;com.pi4j.io.serial.SerialProvider\u0026gt; ? ??PROVIDER: \u0026#34;RaspberryPi Serial Provider\u0026#34; {raspberrypi-serial} \u0026lt;com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl} ? ??PROVIDER: \u0026#34;PiGpio Serial Provider\u0026#34; {pigpio-serial} \u0026lt;com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl} ??PWM: [2] \u0026lt;com.pi4j.io.pwm.PwmProvider\u0026gt; ? ??PROVIDER: \u0026#34;PiGpio PWM Provider\u0026#34; {pigpio-pwm} \u0026lt;com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl} ? ??PROVIDER: \u0026#34;RaspberryPi PWM Provider\u0026#34; {raspberrypi-pwm} \u0026lt;com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl} ??I2C: [2] \u0026lt;com.pi4j.io.i2c.I2CProvider\u0026gt; ? ??PROVIDER: \u0026#34;PiGpio I2C Provider\u0026#34; {pigpio-i2c} \u0026lt;com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl} ? ??PROVIDER: \u0026#34;RaspberryPi I2C Provider\u0026#34; {raspberrypi-i2c} \u0026lt;com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl} ??ANALOG_OUTPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogOutputProvider\u0026gt; ??SPI: [2] \u0026lt;com.pi4j.io.spi.SpiProvider\u0026gt; ? ??PROVIDER: \u0026#34;PiGpio SPI Provider\u0026#34; {pigpio-spi} \u0026lt;com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl} ? ??PROVIDER: \u0026#34;RaspberryPi SPI Provider\u0026#34; {raspberrypi-spi} \u0026lt;com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl} ??DIGITAL_OUTPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalOutputProvider\u0026gt; ? ??PROVIDER: \u0026#34;RaspberryPi Digital Output (GPIO) Provider\u0026#34; {raspberrypi-digital-output} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl} ? ??PROVIDER: \u0026#34;PiGpio Digital Output (GPIO) Provider\u0026#34; {pigpio-digital-output} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl} ??ANALOG_INPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogInputProvider\u0026gt; [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ------------------- [main] INFO com.pi4j.util.Console - | Pi4J REGISTRY | [main] INFO com.pi4j.util.Console - ------------------- REGISTRY: [1] \u0026#34;I/O Registered Instances\u0026#34; \u0026lt;com.pi4j.registry.impl.DefaultRegistry\u0026gt; ??IO: \u0026#34;DOUT-1\u0026#34; {my-digital-output-1} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutput\u0026gt; {DOUT-1} [main] INFO com.pi4j.util.Console -  Thanks to Manuel de Vega Barreiro for this contribution.\n"},{"uri":"https://pi4j.com/documentation/building/fat-jar/","title":"Build as a FAT JAR with Maven","tags":["FatJAR"],"description":"","content":" EXAMPLE PROJECT: https://github.com/Pi4J/pi4j-example-fatjar\n About FAT JARs With Pi4J V1 you can create a so-called FAT JAR, which packages all the dependencies into one jar-file. That way it is very easy to build your project on one computer and distribute your application as a single file to one or more clients.\nBecause of the modular approach and how Pi4J V.2 loads it dependencies at runtime, this approach can be achieved by using the maven-shade-plugin.\nExample FAT JAR project Check the example project (link on top of this page) for the full README, pom.xml and sources.\nMaven plugins Three plugins are used in pom.xml to create the FAT JAR:\n\u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;pi4j-example-fatjar\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- https://maven.apache.org/plugins/maven-compiler-plugin/ The Compiler Plugin is used to compile the sources of your project. --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-compiler-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;release\u0026gt;${java.version}\u0026lt;/release\u0026gt; \u0026lt;showDeprecation\u0026gt;true\u0026lt;/showDeprecation\u0026gt; \u0026lt;showWarnings\u0026gt;true\u0026lt;/showWarnings\u0026gt; \u0026lt;verbose\u0026gt;false\u0026lt;/verbose\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- https://maven.apache.org/plugins/maven-jar-plugin/ This plugin provides the capability to build (executable) jars and is used here to set the mainClass which will start the application. --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-jar-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;${main.class}\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- https://maven.apache.org/plugins/maven-shade-plugin/ This plugin provides the capability to package the artifact in an uber-jar, including its dependencies and to shade - i.e. rename - the packages of some of the dependencies. The transformer will combine the files in the META-INF.services directories of multiple Pi4J plugins with the same package name into one file. --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-shade-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${maven-shade-plugin.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;transformers\u0026gt; \u0026lt;transformer implementation=\u0026#34;org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\u0026#34;/\u0026gt; \u0026lt;/transformers\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;shade\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; By using maven-shade-plugin the correct META-INF.services files are generated.\nAs a jar-file is actually a zip-file, we can easily check the contents of the FAT JAR after it has been created with mvn package:\n directories  com lib META-INF org   files  LICENSE.txt NOTICE.txt README.md    Loading of the Pi4J modules Pi4J V.2 uses ServiceLoader to detect which modules are available to communicate with the GPIOs. This allows to very dynamically extend the possibilities of the framework.\nCode extract from pi4j-core/src/\u0026hellip;/runtime/impl/DefaultRuntime.java:\n// detect available Pi4J Plugins by scanning the classpath looking for plugin instances var plugins = ServiceLoader.load(Plugin.class); Thanks to the maven-shade-plugin, each Pi4J plugin that is part of the project, is included in META-INF/services/com.pi4j.extension.Plugin:\ncom.pi4j.plugin.raspberrypi.RaspberryPiPlugin com.pi4j.plugin.pigpio.PiGpioPlugin When running this application we can indeed see the loaded platform and provider plugins in the logs:\n[main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - | Pi4J DEFAULT PLATFORM | [main] INFO com.pi4j.util.Console - --------------------------- [main] INFO com.pi4j.util.Console - PLATFORM: \u0026quot;RaspberryPi Platform\u0026quot; {raspberrypi} \u0026lt;com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform\u0026gt; {Pi4J Platform for the RaspberryPi series of products.} [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - | Pi4J PROVIDERS | [main] INFO com.pi4j.util.Console - -------------------- [main] INFO com.pi4j.util.Console - PROVIDERS: [12] \u0026quot;I/O Providers\u0026quot; \u0026lt;com.pi4j.provider.impl.DefaultProviders\u0026gt; ├─SPI: [2] \u0026lt;com.pi4j.io.spi.SpiProvider\u0026gt; │ ├─PROVIDER: \u0026quot;PiGpio SPI Provider\u0026quot; {pigpio-spi} \u0026lt;com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.spi.PiGpioSpiProviderImpl} │ └─PROVIDER: \u0026quot;RaspberryPi SPI Provider\u0026quot; {raspberrypi-spi} \u0026lt;com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.spi.RpiSpiProviderImpl} ├─ANALOG_INPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogInputProvider\u0026gt; ├─SERIAL: [2] \u0026lt;com.pi4j.io.serial.SerialProvider\u0026gt; │ ├─PROVIDER: \u0026quot;PiGpio Serial Provider\u0026quot; {pigpio-serial} \u0026lt;com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.serial.PiGpioSerialProviderImpl} │ └─PROVIDER: \u0026quot;RaspberryPi Serial Provider\u0026quot; {raspberrypi-serial} \u0026lt;com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.serial.RpiSerialProviderImpl} ├─DIGITAL_INPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalInputProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi Digital Input (GPIO) Provider\u0026quot; {raspberrypi-digital-input} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalInputProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio Digital Input (GPIO) Provider\u0026quot; {pigpio-digital-input} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalInputProviderImpl} ├─I2C: [2] \u0026lt;com.pi4j.io.i2c.I2CProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi I2C Provider\u0026quot; {raspberrypi-i2c} \u0026lt;com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.i2c.RpiI2CProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio I2C Provider\u0026quot; {pigpio-i2c} \u0026lt;com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.i2c.PiGpioI2CProviderImpl} ├─ANALOG_OUTPUT: [0] \u0026lt;com.pi4j.io.gpio.analog.AnalogOutputProvider\u0026gt; ├─DIGITAL_OUTPUT: [2] \u0026lt;com.pi4j.io.gpio.digital.DigitalOutputProvider\u0026gt; │ ├─PROVIDER: \u0026quot;RaspberryPi Digital Output (GPIO) Provider\u0026quot; {raspberrypi-digital-output} \u0026lt;com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.gpio.digital.RpiDigitalOutputProviderImpl} │ └─PROVIDER: \u0026quot;PiGpio Digital Output (GPIO) Provider\u0026quot; {pigpio-digital-output} \u0026lt;com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.gpio.digital.PiGpioDigitalOutputProviderImpl} └─PWM: [2] \u0026lt;com.pi4j.io.pwm.PwmProvider\u0026gt; ├─PROVIDER: \u0026quot;RaspberryPi PWM Provider\u0026quot; {raspberrypi-pwm} \u0026lt;com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl\u0026gt; {com.pi4j.plugin.raspberrypi.provider.pwm.RpiPwmProviderImpl} └─PROVIDER: \u0026quot;PiGpio PWM Provider\u0026quot; {pigpio-pwm} \u0026lt;com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl\u0026gt; {com.pi4j.plugin.pigpio.provider.pwm.PiGpioPwmProviderImpl} [main] INFO com.pi4j.util.Console - "},{"uri":"https://pi4j.com/documentation/building/modules-maven/","title":"Build Java modules with Maven","tags":["Maven"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\n Because the Pi4J V.2 project follows the modular approach of Java, the functionality of the framework has been split into different modules, each with their own responsibility.\nThe easiest way to start a new project, is to copy one of the example projects which include a full Maven pom.xml-file with all the required steps and configurations to build the project with all its modules into the target/distribution directory.\nTake for instance a look at the \u0026ldquo;Minimal example application\u0026rdquo;.\nBuild your project with:\n$ mvn clean package When finished, you will find the generated package and required Java-modules and can start your application with the provided run.sh script:\n$ cd target/distribution $ ls -l total 644 -rw-r--r-- 1 pi pi 364456 Jun 19 10:04 pi4j-core-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 7243 Jun 19 10:04 pi4j-example-minimal-0.0.1.jar -rw-r--r-- 1 pi pi 142461 Jun 19 10:04 pi4j-library-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 37302 Jun 19 10:04 pi4j-plugin-pigpio-2.0-SNAPSHOT.jar -rw-r--r-- 1 pi pi 26917 Jun 19 10:04 pi4j-plugin-raspberrypi-2.0-SNAPSHOT.jar -rwxr-xr-x 1 pi pi 101 Jun 19 10:04 run.sh -rw-r--r-- 1 pi pi 52173 Jun 19 10:04 slf4j-api-2.0.0-alpha0.jar -rw-r--r-- 1 pi pi 15372 Jun 19 10:04 slf4j-simple-2.0.0-alpha0.jar $ sudo ./run.sh "},{"uri":"https://pi4j.com/documentation/building/modules-gradle/","title":"Build Java modules with Gradle","tags":["Gradle"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal\n The Pi4J V.2 project itself uses Maven and most example projects also use this build tool. But if you prefer to use Gradle, you can start with a copy of the \u0026ldquo;Minimal example application\u0026rdquo; which includes all the required files to build with Gradle.\nUse Gradle version 6.6 (or later) and Java 11 OpenJDK (or later). The Gradle wrapper is used as described on docs.gradle.org. The Gradle configuration file build.gradle-file is included in the sources.\nBuild with Gradle On Linux:\n./gradlew build\nOn Windows:\ngradlew.bat build\nBuild result Once the build is complete and was successful, you can find the compiled build (Gradle) folder. Specifically all dependency modules (JARs) and a simple run.sh bash script will be located in the build/distribution (Gradle) folder.\nThese are all the required files needed to distribute (copy) to your Raspberry Pi to run this project. If you are using the native bindings running locally on the Raspberry Pi, then you make have to run the program using sudo to gain the necessary access permissions to the hardware I/O.\nThis is the list of files created by the build process of this example application:\n pi4j-core pi4j-example-minimal pi4j-library-pigpio pi4j-plugin-pigpio pi4j-plugin-raspberrypi slf4j-api slf4j-simple run.sh \u0026ndash;\u0026gt; this is the actual start file which will run pi4j-example-minimal  Run on Raspberry Pi Make the run script executable and start it like this:\n$ chmod +x run.sh $ sudo ./run.sh "},{"uri":"https://pi4j.com/documentation/building/jbang/","title":"Running Pi4J with JBang","tags":["JBang"],"description":"","content":"JBang allows you to execute Java code with dependencies as a single file without the need for a full Maven or Gradle project. You also don\u0026rsquo;t need to compile your code. So it\u0026rsquo;s a very easy way to get started with Java and Pi4J.\nMultiple examples and more information is available in the section \u0026ldquo;Example Implementations \u0026gt; JBang Examples\u0026rdquo;.\n"},{"uri":"https://pi4j.com/examples/jbang/pixelblaze_output_expander/","title":"Pixelblaze Output Expander","tags":["JBang","Pixelblaze","LED Strip"],"description":"","content":" GITHUB PROJECT: github.com/Pi4J/pi4j-jbang \u0026gt; PixelblazeOutputExpander.java\n One of the most \u0026ldquo;fancy\u0026rdquo; electronic components is definitely a LED strip. It\u0026rsquo;s really cool to control a long strip of lights with only a few lines of code\u0026hellip; But, there is a problem. The timings of the signals is crucial to reliably control these strips. Both Python and Java on a Raspberry Pi can struggle with these timings as they are running on Linux, a non-real-time operating system. So pauzes in the garbage collection of the virtual machine of Java, or any hickup in the operation of the operating system can cause unexpected effects on the LED strips. That\u0026rsquo;s why in most projects a microcontroller (Arduino, Raspberry Pi Pico, ESP32,\u0026hellip;) is used to drive the LED strip.\nIntro This example is using such approach with the Pixelblaze Output Expander (PBOE). This product was initially intended to connect more LED strips to the Pixelblaze V3 Standard - WiFi LED Controller and Pixelblaze V3 Pico - Tiny WiFi LED Controller. But because the expander is controlled through a serial connection, we can also use it with a Raspberry Pi.\nThe LED strips contain LEDs of the WS2812B type, which means they have SMD 5050-LEDs with an integrated IC-driver, so they can be addressed separately. A few examples:\n LED strip on Amazon LED matrix on Amazon Many variants on ebay  Wiring To control the PBOE, we actually only need one wire to be connected to the Raspberry Pi (RPi) for the serial data to be sent from RPi to PBOE. But we must not forget one important fact: a LED strip with a lot of LEDs will require more power than the RPi can supply. So we need an external power supply that is dimensioned correctly to provide all the power needed for the strip when all LEDs are at maximum level. As a guideline, 0,1W ~ 0,3W/LED is required per LED. For a strip with 60 LEDs/meter, that means 18W/meter, or a total of 90W for a 5 meter strip. That\u0026rsquo;s almost 20A at 5V!\nUse an external power supply to power LED strips!!! The 5V of the Raspberry Pi is passed straight through from the USB and the current is therefore limited. This is a good question with clear answers about this topic on StackExchange.\n Connections between RPi, PBOE, and power supply:\n GND PBOE to GND power supply, common with GND of RPi 5V PBOE to external power supply DAT PBOE to BCM14 on Rpi (pin 8 = UART Tx)  Connections between PBOE and LED strip:\n Din to PBOE Channel 0, Data 5V to PBOE Channel 0, 5V GND to PBOE Channel 0, GND      Full setup of this project\n      LED strip with three connections for power, ground, and data\n      Pixelblaze Output Expander\n      Connections on the Raspberry Pi\n      Connections on the Pixelblaze Output Expander\n      Connections for the LED strip\n                               Enabling Serial To be able to control the serial link from software, the following steps must be followed:\n In terminal: sudo raspi-config Go to \u0026ldquo;Interface Options\u0026rdquo; Go to \u0026ldquo;Serial Port\u0026rdquo; Select \u0026ldquo;No\u0026rdquo; for \u0026ldquo;login shell\u0026rdquo; Select \u0026ldquo;Yes\u0026rdquo; for \u0026ldquo;hardware enabled\u0026rdquo;  Status of the Pixelblaze Output Expander LEDs  Fading / pulsing orange: Has not seen any valid looking data. Solid orange (for short time): Received expander data. Green LED (for short time): Received data for its channels and is drawing.  Application Before proceeding with this example, make sure that you have a Raspberry Pi prepared to execute Java code with JBang as explained here.\n Jeff Vyduna and Ben Hencke of ElectroMage, the creators of Pixelblaze, provided example Java code for this project. The serial data format is documented on GitHub. What the code is doing in short:\n Open serial communication to /dev/ttyS0. Use BaudRate 2000000, this is a hard requirement for the PBOE. Send a byte array of RGB values for each LED. Send a drawAll command to put the values on the LEDs. Send other byte array and drawAll. Before the application stops, close the serial port.  JBang configuration As with each JBang example, we need to define the first script line and the dependencies, one in this case:\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $?  //DEPS com.fazecast:jSerialComm:2.10.2 ExpanderDataWriteAdapter This example project doesn\u0026rsquo;t use the Pi4J serial communication (because it doesn\u0026rsquo;t support this baud rate - at this moment), but instead the com.fazecast:jSerialComm:2.10.2 library. An inner class is used to setup the serial communication and provide a write method.\nstatic class ExpanderDataWriteAdapter { private SerialPort port = null; private final String portPath; public ExpanderDataWriteAdapter (String portPath) { this.portPath = portPath; } private void openPort() { if (port != null) { System.out.println(\u0026#34;Closing \u0026#34; + portPath); port.closePort(); } port = null; //set to null in case getCommPort throws, port will remain null.  port = SerialPort.getCommPort(this.portPath); port.setBaudRate(2000000); port.setComPortTimeouts(SerialPort.TIMEOUT_NONBLOCKING, 0, 0); port.openPort(0, 8192, 8192); System.out.println(\u0026#34;Opening \u0026#34; + portPath); } public void closePort() { if (port != null) { System.out.println(\u0026#34;Closing \u0026#34; + portPath); port.closePort(); } } public void write(byte[] data) { int lastErrorCode = port != null ? port.getLastErrorCode() : 0; boolean isOpen = port != null \u0026amp;\u0026amp; port.isOpen(); if (port == null || !isOpen || lastErrorCode != 0) { System.out.println(\u0026#34;Port was open:\u0026#34; + isOpen + \u0026#34;, last error:\u0026#34; + lastErrorCode); openPort(); } port.writeBytes(data, data.length); } } Helper methods Check the sources of the example for the full code, this is an overview of the additional helper methods without the full implementation:\nprivate static void sendAllOff() { System.out.println(\u0026#34;All off\u0026#34;); sendWs2812(0, 3, 1, 0, 2, 0, new byte[NUMBER_OF_LEDS * 3]); sendDrawAll(); } private static void sendWs2812(int channel, int bytesPerPixel, int rIndex, int gIndex, int bIndex, int wIndex, byte[] pixelData) { ... } public static void sendDrawAll() { ... } private static void writeCrc(CRC32 crc) { ... } private static void packInt(byte[] outgoing, int index, int val) { ... } private static ByteBuffer initHeaderBuffer(int size, byte channel, byte command) { ... } Controlling the LEDs With all this code in place, we can start sending color data to the LED strip. The idea is to send a byte array containing a value for each color of the LEDs.\nFor instance, to send these colors to the first four LEDs, when using RGB-leds:\n1 Red 2 Green 3 Blue 4 White\nThe byte array will look like this:\nbyte[] pixeldata = new byte[12]; // 3 colors * 4 leds  // Red = 0xff0000 byte[0] = (byte) 0xff; byte[1] = (byte) 0x00; byte[2] = (byte) 0x00; // Green = 0x00ff00 byte[3] = (byte) 0x00; byte[4] = (byte) 0xff; byte[5] = (byte) 0x00; // blue = 0x0000ff byte[6] = (byte) 0x00; byte[7] = (byte) 0x00; byte[8] = (byte) 0xff; // White = 0xffffff byte[9] = (byte) 0xff; byte[10] = (byte) 0xff; byte[11] = (byte) 0xff; Number of colors per LED A LED on a strip can contain three inner LEDs for RGB, or four for RGBW. In case of RGBW, you need to adapt the script to define bytesPerPixel = 4, and your byte array with the color values need to include four values per LED.\n// 3 colors per LED, White = 0xffffff byte[0] = (byte) 0xff; byte[1] = (byte) 0xff; byte[2] = (byte) 0xff; // 4 colors per LED, White = 0x000000ff byte[0] = (byte) 0x00; byte[1] = (byte) 0x00; byte[2] = (byte) 0x00; byte[3] = (byte) 0xff; Order of the color values Test the red, green, and blue output to define how the RGB colors are ordered in the PBOE controller and/or LED strip. You can define the relationship between the colors in your byte array with the actual led strip in the sendWs2812 method, with the int rIndex, int gIndex, int bIndex, int wIndex parameters. If you are using RGB-leds and 3 bytes per pixel, the wIndex parameter is ignored.\nSending color values The example code uses multiple byte arrays to send various colors and effects to a strip with 11 LEDs, connected to the channel 0 pins of the PBOE.\nprivate static final byte CH_WS2812_DATA = 1; private static final byte CH_DRAW_ALL = 2; private static final byte CH_APA102_DATA = 3; private static final byte CH_APA102_CLOCK = 4; private static final int NUMBER_OF_LEDS = 11; private static ExpanderDataWriteAdapter adapter; public static void main(String[] args) throws InterruptedException { adapter = new ExpanderDataWriteAdapter(\u0026#34;/dev/ttyS0\u0026#34;); // All off  sendAllOff(); Thread.sleep(500); // One by one red  System.out.println(\u0026#34;One by one red\u0026#34;); for (int i = 0; i \u0026lt; NUMBER_OF_LEDS; i++) { byte[] oneRed = new byte[NUMBER_OF_LEDS * 3]; oneRed[i * 3] = (byte) 0xff; sendWs2812(0, 3, 1, 0, 2, 0, oneRed); sendDrawAll(); Thread.sleep(250); } // All same color red, green, blue  for (int color = 0; color \u0026lt; 3; color++) { System.out.println(\u0026#34;All \u0026#34; + (color == 0 ? \u0026#34;red\u0026#34; : (color == 1 ? \u0026#34;green\u0026#34; : \u0026#34;blue\u0026#34;))); byte[] allSame = new byte[NUMBER_OF_LEDS * 3]; for (int i = 0; i \u0026lt; NUMBER_OF_LEDS; i++) { allSame[(3 * i) + color] = (byte) 0xff; } sendWs2812(0, 3, 1, 0, 2, 0, allSame); sendDrawAll(); Thread.sleep(1000); } // Fill strip with random colors  Random rd = new Random(); for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;Random colors \u0026#34; + (i + 1)); byte[] random = new byte[NUMBER_OF_LEDS * 3]; rd.nextBytes(random); sendWs2812(0, 3, 1, 0, 2, 0, random); sendDrawAll(); Thread.sleep(1000); } // Red alert!  try { byte[] red = new byte[NUMBER_OF_LEDS * 3]; int i; for (i = 0; i \u0026lt; NUMBER_OF_LEDS; i++) { red[i*3]= (byte) 0xff; } for (i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;All red\u0026#34;); sendWs2812(0, 3, 1, 0, 2, 0, red); sendDrawAll(); Thread.sleep(100); sendAllOff(); Thread.sleep(100); } } catch (Exception e) { System.err.println(\u0026#34;Error during random color test: \u0026#34; + e.getMessage()); } adapter.closePort(); } Running the Application No sudo is needed for serial communication with the jSerialComm library, so the application can be started with:\n$ jbang PixelblazeOutputExpander.java All off 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Port was open:false, last error:0 Opening /dev/ttyS0 One by one red ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ... All red ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 All green 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 All blue 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff Random colors 1 1f 43 1b 3d b1 9c 46 81 ee 2f bb ba e2 a5 f5 9f af 06 27 d8 6c 04 64 68 a4 fa 31 57 14 c5 9e 7b b9 ... All red ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 ff 00 00 All off 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ... Closing /dev/ttyS0 Conclusion I\u0026rsquo;m still curious to see the reliability of this serial control of LED strips in combination with other loads on the Raspberry Pi, but the Pixelblaze Output Expander is a great way to easily control such strips!\n"},{"uri":"https://pi4j.com/documentation/io-examples/digital-output/","title":"Digital Output (GPIO)","tags":["Digital Output"],"description":"","content":"A digital output translates a false/true (or 0/1) to an output value of 0V or 3.3V. This means you can control any type of device which works with max 3.3V to off or on. The most basic example is a LED. Always check which is the correct input voltage for your device! For a LED you will need to put a resistor with the correct value between the GPIO and the LED, you can find a lot of examples and calculators online, for example on circuitdigest.com/calculators/led-resistor-calculator.\nThe following example shows the minimal code to configure the DIGITAL_OUTPUT_PIN pin number as an output pin and change the state with different methods which are provided by the Pi4J library. This implementation will operate with a Pi4j default Provider. The default Provider is not a concrete implementation and therefore running this program will not access the GPIO Hardware and the Hardware state will not be modified. To access the Hardware a concrete Provider is required. See Providers\nExamples of the various methods and approaches which can be used to provision the I/O needs are available in the examples project.\n// Initialize Pi4J with an auto context // An auto context includes AUTO-DETECT BINDINGS enabled // which will load all detected Pi4J extension libraries // (Platforms and Providers) in the class path var pi4j = Pi4J.newAutoContext(); // create a digital output instance using the default digital output provider var output = pi4j.dout().create(DIGITAL_OUTPUT_PIN); output.config().shutdownState(DigitalState.HIGH); // setup a digital output listener to listen for any state changes on the digital output output.addListener(System.out::println); // lets invoke some changes on the digital output output.state(DigitalState.HIGH) .state(DigitalState.LOW) .state(DigitalState.HIGH) .state(DigitalState.LOW); // lets toggle the digital output state a few times output.toggle() .toggle() .toggle(); // another friendly method of setting output state output.high() .low(); // lets read the digital output state System.out.print(\u0026#34;CURRENT DIGITAL OUTPUT [\u0026#34; + output + \u0026#34;] STATE IS [\u0026#34;); System.out.println(output.state() + \u0026#34;]\u0026#34;); // pulse to HIGH state for 3 seconds System.out.println(\u0026#34;PULSING OUTPUT STATE TO HIGH FOR 3 SECONDS\u0026#34;); output.pulse(3, TimeUnit.SECONDS, DigitalState.HIGH); System.out.println(\u0026#34;PULSING OUTPUT STATE COMPLETE\u0026#34;); // shutdown Pi4J pi4j.shutdown(); "},{"uri":"https://pi4j.com/examples/components/simplebutton/","title":"Simple Button","tags":["Simple Button"],"description":"","content":"Description The SimpleButton is a template class, that you can use in your own Java-project.\nThe Template Class gives you the option to check the state of the button, and to create simple events if the button is pressed, depressed or while it is being pressed.\nLayout     Simple Button Breadboard\n      Big Button\n                               Code A simple example on how to use the Button-Class from the Hardware-Catalog:\n// Initialize the button component final var button = new SimpleButton(pi4j, PIN.D26, Boolean.FALSE); // Register event handlers to print a message when pressed (onDown) and depressed (onUp) button.onDown (() -\u0026gt; logInfo(\u0026#34;Pressing the button\u0026#34;)); button.whilePressed(() -\u0026gt; logInfo(\u0026#34;Pressing\u0026#34;), 1000); button.onUp (() -\u0026gt; logInfo(\u0026#34;Stopped pressing.\u0026#34;)); // Wait for 15 seconds while handling events before exiting System.out.println(\u0026#34;Press the button to see it in action!\u0026#34;); delay(15_000); // Unregister all event handlers to exit this application in a clean way button.deRegisterAll(); /* if you want to deRegister only a single function, you can do so like this: button.onUp(null); */ Further application The class is implemented in the two sample projects Theremin and Photobooth.\nFurther project ideas  An application, which includes a button. if the button is pressed, the app will order you a crate of beer from your favorite store. An application, which includes a buzzer and a button. If the button is pressed, the buzzer beeps.  "},{"uri":"https://pi4j.com/examples/components/simpleled/","title":"Simple LED","tags":["Simple LED"],"description":"","content":"Description The SimpleLed is a template class, that you can use in your own Java-project.\nThe template Class gives you the option to switch off, switch on or toggle the state of the LED.\nLayout     Simple Led Breadboard\n                               Code A simple example on how to use the LED-Class from the Hardware-Catalog:\nSystem.out.println(\u0026#34;Simple LED app started ...\u0026#34;); // Create a new SimpleLED component SimpleLed led = new SimpleLed(pi4j, PIN.D26); // Turn on the LED to have a defined state System.out.println(\u0026#34;Turn on LED.\u0026#34;); led.on(); delay(1000); // Make a flashing light by toggling the LED every second for (int i = 0; i \u0026lt; 10; i++) { System.out.println(\u0026#34;Current LED state is \u0026#34; + led.toggleState() +\u0026#34;.\u0026#34;); delay(1000); } // That\u0026#39;s all so turn off the relay and quit led.off(); System.out.println(\u0026#34;Turn off LED.\u0026#34;); delay(2000); System.out.println(\u0026#34;Simple LED app done.\u0026#34;); Further application The class is implemented in the two sample projects Theremin and Photobooth.\nFurther project ideas  Use an infrared LED to establish communication with an infrared receiver. Use several red LEDs to recreate the running lights of KITT, the car from Knight Rider.  "},{"uri":"https://pi4j.com/examples/components/ads1115/","title":"AD Converter ADS1115","tags":["ADS1115"],"description":"","content":"Description The Analog Digital Converter Ads1115 is a template class, that you can use in your own Java-project. The ADS1115 device is a precision, low-power, 16-bit, I2C-compatible, analog-to-digital converter (ADCs). The ADS1115 device incorporates a low-drift voltage reference and an oscillator as well as a programmable gain amplifier (PGA) and a digital comparator. These features, along with a wide operating supply range, makes the ADS1115 well suited for power- and space-constrained, sensor measurement applications.\nThe ADS1115 performs conversions at data rates up to 860 samples per second (SPS). The PGA offers input ranges from ±256 mV to ±6.144 V, allowing precise large- and small-signal measurements. The ADS1115 features an input multiplexer (MUX) that allows two differential or four single-ended input measurements. Use the digital comparator for under- and overvoltage detection.\nThe ADS1115 operates in either continuous-conversion mode or single-shot mode. The device is automatically powered down after one conversion in single-shot mode. Therefore, power consumption is significantly reduced during idle periods.\nThe Template Class gives you the possibility of a single shot recording, or to measure it continuously.\nLayout     ADS1115 Breadboard\n      ADS1115-Front\n      ADS1115-Back\n                               Code A simple example on how to use the AD converter from the Hardware-Catalog :\nThe PI4J-Context must add the LinuxFsI2CProvider.newInstance() Provider, which is explained under LinuxFS\npi4j = Pi4J.newContextBuilder() .noAutoDetect() .add(new RaspberryPiPlatform() { @Override protected String[] getProviders() { return new String[]{}; } }) .add(PiGpioDigitalInputProvider.newInstance(piGpio), PiGpioDigitalOutputProvider.newInstance(piGpio), PiGpioPwmProvider.newInstance(piGpio), PiGpioSerialProvider.newInstance(piGpio), PiGpioSpiProvider.newInstance(piGpio), LinuxFsI2CProvider.newInstance() ) .build(); When the right context is loaded, you can use the ADS1115 like following:\nSystem.out.println(\u0026#34;Ads1115 test started ...\u0026#34;); System.out.println(\u0026#34;read all channels in continuous mode\u0026#34;); //initialize the component Ads1115 ads1115 = new Ads1115(pi4j, 0x1, Ads1115.GAIN.GAIN_4_096V, Ads1115.ADDRESS.GND, 4); // Register event handlers to print a message on value change ads1115.setConsumerSlowReadChannel0((value) -\u0026gt; { System.out.println(\u0026#34;The actual value from channel 0 is: \u0026#34; + String.format(\u0026#34;%.3f\u0026#34;, value) + \u0026#34;voltage.\u0026#34;); }); ads1115.setConsumerSlowReadChannel1((value) -\u0026gt; { System.out.println(\u0026#34;The actual value from channel 1 is: \u0026#34; + String.format(\u0026#34;%.3f\u0026#34;, value) + \u0026#34;voltage.\u0026#34;); }); ads1115.setConsumerSlowReadChannel2((value) -\u0026gt; { System.out.println(\u0026#34;The actual value from channel 2 is: \u0026#34; + String.format(\u0026#34;%.3f\u0026#34;, value) + \u0026#34;voltage.\u0026#34;); }); ads1115.setConsumerSlowReadChannel3((value) -\u0026gt; { System.out.println(\u0026#34;The actual value from channel 3 is: \u0026#34; + String.format(\u0026#34;%.3f\u0026#34;, value) + \u0026#34;voltage.\u0026#34;); }); //start continuous measuring ads1115.startSlowContinuousReadingAllChannels(0.1, 10); // Wait while handling events before exiting delay(30000); //stop continuous measuring ads1115.stopSlowReadContinuousReadingAllChannels(); //deregister all handlers ads1115.deregisterAll(); pi4j.shutdown(); //end test System.out.println(\u0026#34;ADS1115 test done\u0026#34;); Further application The class is implemented in the sample project Theremin.\nFurther project ideas  An application, which detects the deflection of an analog joystick. An application, that determines the current position of a potentiometer.  "},{"uri":"https://pi4j.com/examples/components/buzzer/","title":"Buzzer","tags":["Buzzer"],"description":"","content":"Description The Buzzer is a template class, that you can use in your own Java-project.\nThe Template Class gives you the option to play a note, and to create your own little melodies to play. The buzzer is controlled via a PWM output. The dutycycle is fixed at 50% and with the frequency the desired sound can be reproduced.\nLayout     Buzzer Acitve Breadboard\n      Buzzer Active\n                               Code A simple example on how to use the Buzzer-Class from the Hardware-Catalog:\n//initialising the buzzer Buzzer buzzer = new Buzzer(pi4j, PIN.PWM18); //playing a simple note System.out.println(\u0026#34;playing note b6 for 1 sec\u0026#34;); buzzer.playTone(Buzzer.Note.B6.getFrequency(), 1000); //shutting it down for 1 second buzzer.playSilence(1000); //Piano baseline of Seven Nation Army by the white Stripes Buzzer.Sound[] melody = new Buzzer.Sound[]{ new Buzzer.Sound(Buzzer.Note.E7, 11), new Buzzer.Sound(Buzzer.Note.PAUSE, 1), new Buzzer.Sound(Buzzer.Note.E7, 2), new Buzzer.Sound(Buzzer.Note.PAUSE, 2), new Buzzer.Sound(Buzzer.Note.G6, 2), new Buzzer.Sound(Buzzer.Note.PAUSE, 3), new Buzzer.Sound(Buzzer.Note.E7, 2), new Buzzer.Sound(Buzzer.Note.PAUSE, 4), new Buzzer.Sound(Buzzer.Note.D6, 2), new Buzzer.Sound(Buzzer.Note.PAUSE, 3), new Buzzer.Sound(Buzzer.Note.C7, 16), new Buzzer.Sound(Buzzer.Note.B5, 8), new Buzzer.Sound(Buzzer.Note.PAUSE, 8), }; //playing the melody once, then shutting down for a second System.out.println(\u0026#34;playing melody once\u0026#34;); buzzer.playMelody(60, melody); delay(1000); //playing the melody 5 times repeatedly System.out.println(\u0026#34;playing melody 5 times\u0026#34;); System.out.println(\u0026#34;playing in a different thread, so the app is moving on\u0026#34;); buzzer.playMelody(60, 5, melody); System.out.println(\u0026#34;waiting for melody to finish\u0026#34;); delay(3000); Further application The class is implemented in the sample project Theremin.\nFurther project ideas  An application, which triggers if you walk by and starts beeping, like an alarm. An application, where you use many of them to create a beautiful sounding melody.  "},{"uri":"https://pi4j.com/examples/components/camera/","title":"Camera","tags":["Camera"],"description":"","content":"Description The Camera is a template class, that you can use in your own Java-project. Currently, the code is only tested with a Raspberry-Camera and the crowpi-image. You can take pictures or videos, with or without a preview.\nTo connect the camera, use this video. The video is mentioned on the official website. The camera class is using the bash-commands \u0026ldquo;libcamera-hello\u0026rdquo;, \u0026ldquo;libcamera-still\u0026rdquo; and \u0026ldquo;libcamera-vid\u0026rdquo;. To use them, set up the raspberry with the following Introduction\n Layout     Raspberry Camera\n                               Code An example on how to use the Camera-Class from the Hardware-Catalog\nSystem.out.println(\u0026#34;Initializing the camera\u0026#34;); Camera camera = new Camera(); System.out.println(\u0026#34;Taking a default picture\u0026#34;); camera.takeStill(); System.out.println(\u0026#34;Taking a pic with different parameters\u0026#34;); var config = Camera.PicConfig.Builder.outputPath(\u0026#34;/home/pi/Pictures/\u0026#34;) .delay(3000) .disablePreview(true) .encoding(Camera.PicEncoding.PNG) .useDate(true) .quality(93) .width(1280) .height(800) .build(); camera.takeStill(config); System.out.println(\u0026#34;waiting for camera to take pic\u0026#34;); delay(4000); System.out.println(\u0026#34;Taking a video for 3 seconds\u0026#34;); var vidconfig = Camera.VidConfig.Builder.outputPath(\u0026#34;/home/pi/Videos/\u0026#34;) .recordTime(3000) .useDate(true) .build(); camera.takeVid(vidconfig); Further application The class is implemented in the sample project Photobooth.\nFurther project ideas  Use a camera and a motion-sensor to create a wildlife-camera Use a camera to monitor the entrance of a building, by publishing the preview of the camera to a webserver  "},{"uri":"https://pi4j.com/documentation/io-examples/digital-input/","title":"Digital Input (GPIO)","tags":["Digital Input"],"description":"","content":"Similar to a digital output pin, a digital input translates an input value of 0V or 3.3V to the value false/true. This means any type of device which can toggle between 3.3V and 0V, can generate an input value to the Raspberry Pi. Here the most basic example is a toggle button. If you use other components, always check which is the voltage provided by the device. Or if you use a power pin from the Raspberry Pi itself, to use a 3.3V pin and not a 5V pin.\nV.2 provides a declarative style of configuration for I/O provisioning instead of the hard-coded approach offered in V.1.\nThe following example shows the minimal code to configure the DIGITAL_INPUT_PIN\nas an input pin and monitor the pin state with by adding a Listener. The code uses methods which are provided by the Pi4J library. This implementation will operate with a Pi4j default Provider. The default Provider is not a concrete implementation and therefore running this program will not access the GPIO Hardware and the Hardware state will not be read/monitored. To access the Hardware a concrete Provider is required. See Providers\nExamples of the various methods and approaches which can be used to provision the I/O needs are available in the examples project.\nProperties properties = new Properties(); properties.put(\u0026#34;id\u0026#34;, \u0026#34;my_digital_input\u0026#34;); properties.put(\u0026#34;address\u0026#34;, DIGITAL_INPUT_PIN); properties.put(\u0026#34;pull\u0026#34;, \u0026#34;UP\u0026#34;); properties.put(\u0026#34;name\u0026#34;, \u0026#34;MY-DIGITAL-INPUT\u0026#34;); var config = DigitalInput.newConfigBuilder(pi4j) .load(properties) .build(); var input = pi4j.din().create(config); s Once an input has been initialized, a listener can be attached to execute code on state changes of the input.\ninput.addListener(e -\u0026gt; { if (e.state() == DigitalState.HIGH) { console.println(\u0026#34;Button is pressed\u0026#34;); } }); "},{"uri":"https://pi4j.com/examples/components/joystick/","title":"Joystick","tags":["Joystick"],"description":"","content":"Description The Joystick is a template class, that you can use in your own Java-project. The template is created for a digital joystick with 4 directions (up, right, down, left) and as an option additionally with a push button in direction down. A suitable hardware component is the arcade joystick in the picture bellow. But any joystick with switching contacts will meet the requirements.\nThe template class allows to query the individual joystick positions and can trigger a simple event when the joystick swings out in a direction or when it returns to the center position.\nLayout     Joystick Digital Breadboard\n      Joystick Digital Top View\n      Joystick Digital Back View All Axis\n      Joystick Digital Back View One Axis\n      Joystick Digital Wiring Back\n      Joystick Digital Wiring Back Corner\n                               Code A simple example on how to use the Joystick-Class from the Hardware-Catalog:\n//Initzalize the joystick component final var joystick = new Joystick(pi4j, PIN.D5, PIN.D6, PIN.PWM13, PIN.PWM19, PIN.D26); //Register event handlers to print a message when pressed (onDown) and (onUp) joystick.onNorth(() -\u0026gt; System.out.println(\u0026#34;Start Pressing joystick button North\u0026#34;)); joystick.whileNorth(1000, () -\u0026gt; System.out.println(\u0026#34;Pressing joystick button North\u0026#34;)); joystick.onWest(() -\u0026gt; System.out.println(\u0026#34;Start Pressing joystick button West\u0026#34;)); joystick.whileWest(1000, () -\u0026gt; System.out.println(\u0026#34;Pressing joystick button West\u0026#34;)); joystick.onSouth(() -\u0026gt; System.out.println(\u0026#34;Start Pressing joystick button South\u0026#34;)); joystick.whileSouth(1000, () -\u0026gt; System.out.println(\u0026#34;Pressing joystick button South\u0026#34;)); joystick.onEast(() -\u0026gt; System.out.println(\u0026#34; Start Pressing joystick button East\u0026#34;)); joystick.whileEast(1000, () -\u0026gt; System.out.println(\u0026#34;Pressing joystick button East\u0026#34;)); joystick.onPushDown(() -\u0026gt; System.out.println(\u0026#34;Start Pressing joystick button PUSH\u0026#34;)); joystick.onPushUp(() -\u0026gt; System.out.println(\u0026#34;Stop pressing joystick button PUSH\u0026#34;)); // Wait for 15 seconds while handling events before exiting System.out.println(\u0026#34;Press the button to see it in action!\u0026#34;); delay(15000); // Unregister all event handlers to exit this application in a clean way joystick.deRegisterAll(); Further application The class is not yet implemented in a project.\nFurther project ideas  Realize the popular arcade game Street Fighter on your own Raspberry Pi. Create a claw crane game machine, the hit at every party.  "},{"uri":"https://pi4j.com/examples/components/joystickanalog/","title":"Joystick Analog","tags":["Joystick analog"],"description":"","content":"Description The JoystickAnalog is a template class, that you can use in your own Java-project. The template class is created for an analog joystick, for example the KY-023, which consists of two potentiometers, one for the X-axis and one for the Y-axis. But any joystick with two potentiometers will meet the requirements.\nThe basic functions of the template class are:\n return of a normalized value, optionally between 0 and 1 or between -1 and 1, of the X-axis and the Y-axis creation of simple events at a value change of the X-axis or the Y-axis, simple event handlers for button pressed, button depressed, while button is pressed calibration of the center position of the joystick (center position 0.5 at a normalized value between 0 and 1, center position 0 at a normalized value between -1 and 1)  Layout     Joystick Analog Breadboard\n      Joystick Analog\n      ADS1115-Front\n      ADS1115-Back\n                               Code A simple example on how to use the JoystickAnalog-Class from the Hardware-Catalog:\nSystem.out.println(\u0026#34;Joystick test started ...\u0026#34;); Ads1115 ads1115 = new Ads1115(pi4j, 0x01, Ads1115.GAIN.GAIN_4_096V, Ads1115.ADDRESS.GND, 4); //joystick with normalized axis from 0 to 1 JoystickAnalog joystick = new JoystickAnalog(pi4j, ads1115, 0, 1, 3.3, true, PIN.D26); //joystick with normalized axis from -1 to 1 //JoystickAnalog joystick = new JoystickAnalog(pi4j, ads1115, 0, 1, 3.3, false, PIN.D26);  //register event handlers joystick.xOnMove((value) -\u0026gt; System.out.println(\u0026#34;Current value of joystick x axis is: \u0026#34; + String.format(\u0026#34;%.3f\u0026#34;, value))); joystick.yOnMove((value) -\u0026gt; System.out.println(\u0026#34;Current value of joystick y axis is: \u0026#34; + String.format(\u0026#34;%.3f\u0026#34;, value))); joystick.pushOnDown(() -\u0026gt; System.out.println(\u0026#34;Pressing the Button\u0026#34;)); joystick.pushOnUp(() -\u0026gt; System.out.println(\u0026#34;Stopped pressing.\u0026#34;)); joystick.pushWhilePressed(() -\u0026gt; System.out.println(\u0026#34;Button is still pressed.\u0026#34;), 1000); joystick.calibrateJoystick(); //start continuous reading with single shot in this mode you can connect up to 4 devices to the analog module joystick.start(0.05, 10); //wait while handling events before exiting System.out.println(\u0026#34;Move the joystick to see it in action!\u0026#34;); delay(30_000); //stop continuous reading joystick.stop(); delay(1000 ); //deregister all event handlers joystick.deregisterAll(); System.out.println(\u0026#34;Joystick test done\u0026#34;); Further application The class is implemented in the sample project Theremin.\nFurther project ideas  create your own PlayStation controller use the joystick to control the position of servo motors steplessly  "},{"uri":"https://pi4j.com/examples/components/lcddisplay/","title":"LCD Display","tags":["LCD Display"],"description":"","content":"Description The LcdDisplay is a template class, that you can use in your own Java-project. It is used to show Numbers, Text and Symbols on a small Display. The Class supports only LCD Displays with the PCF8574T I2C Backpack. Supported display-dimensions are 40x2, 20x4, 20x2, 16x2, 16x1.\nIF YOU CAN\u0026rsquo;T SEE ANYTHING WRITTEN ON THE DISPLAY, TRY TO SET THE CONTRAST BY TURNING THE CONTRAST-SCREW AT THE BACK WITH A SCREWDRIVER. Also, check if I2C is enabled in your raspberry-config.\n Layout     LCD Display 2 Rows Breadboard\n      LCD Display 2 Rows Front\n      LCD Display 2 Rows Back\n      LCD Display 4 Rows Front\n      LCD Display 4 Rows Back\n                               Code An example on how to use the LCD Display-Class from the Hardware-Catalog\nThe PI4J-Context must add the LinuxFsI2C Provider, which is explained under LinuxFS\npi4j = Pi4J.newContextBuilder() .noAutoDetect() .add(new RaspberryPiPlatform() { @Override protected String[] getProviders() { return new String[]{}; } }) .add(PiGpioDigitalInputProvider.newInstance(piGpio), PiGpioDigitalOutputProvider.newInstance(piGpio), PiGpioPwmProvider.newInstance(piGpio), PiGpioSerialProvider.newInstance(piGpio), PiGpioSpiProvider.newInstance(piGpio), LinuxFsI2CProvider.newInstance() ) .build(); When the right Context is loaded, you can use the Display like following:\n//Create a Component, with amount of ROWS and COLUMNS of the Device LcdDisplay lcd = new LcdDisplay(pi4j, 4, 20); System.out.println(\u0026#34;Here we go.. let\u0026#39;s have some fun with that LCD Display!\u0026#34;); // Turn on the backlight makes the display appear turned on lcd.setDisplayBacklight(true); // Write text to the lines separate lcd.displayText(\u0026#34;Hello\u0026#34;, 1); lcd.displayText(\u0026#34; World!\u0026#34;, 2); lcd.displayText(\u0026#34;Line 3\u0026#34;, 3); lcd.displayText(\u0026#34; Line 4\u0026#34;, 4); // Wait a little to have some time to read it sleep(3000); // Clear the display to start next parts lcd.clearDisplay(); // To write some text there are different methods. The simplest one is this one which automatically inserts // linebreaks if needed. lcd.displayText(\u0026#34;Boohoo that\u0026#39;s so simple to use!\u0026#34;); // Delay again sleep(3000); // Of course it is also possible to write with newLine Chars lcd.displayText(\u0026#34;Some Big Text \\n with some new Lines \\n just testing\u0026#34;); sleep(3000); // Of course it is also possible to write long text lcd.displayText(\u0026#34;Some Big Text with no new Lines, just to test how many lines will get filled\u0026#34;); sleep(3000); lcd.displayText(\u0026#34;Small Text with \\nnew\u0026#34;); sleep(3000); // Clear the display to start next parts lcd.clearDisplay(); // Let\u0026#39;s try to draw a house. To keep this method short and clean we create the characters in a separate // method below. createCharacters(lcd); // Now all characters are ready. Just draw them on the right place by moving the cursor and writing the // created characters to specific positions lcd.writeCharacter(\u0026#39;\\1\u0026#39;, 1, 1); lcd.writeCharacter(\u0026#39;\\2\u0026#39;, 2, 1); lcd.writeCharacter(\u0026#39;\\3\u0026#39;, 1, 2); lcd.writeCharacter(\u0026#39;\\4\u0026#39;, 2, 2); delay(3000); // Turn off the backlight makes the display appear turned off lcd.setDisplayBacklight(false); lcd.clearDisplay(); public void createCharacters(LCDDisplay lcd) { // Create upper left part of the house  lcd.createCharacter(1, new byte[]{ 0b00000, 0b00000, 0b00000, 0b00001, 0b00011, 0b00111, 0b01111, 0b11111 }); // Create upper right part of the house  lcd.createCharacter(2, new byte[]{ 0b00000, 0b00000, 0b00010, 0b10010, 0b11010, 0b11110, 0b11110, 0b11111 }); // Create lower left part of the house  lcd.createCharacter(3, new byte[]{ 0b11111, 0b11111, 0b11111, 0b11111, 0b10001, 0b10001, 0b10001, 0b10001 }); // Create lower right part of the house  lcd.createCharacter(4, new byte[]{ 0b11111, 0b11111, 0b11111, 0b10001, 0b10001, 0b10001, 0b11111, 0b11111 }); }  If you want to create an own character or symbol, then use the following tutorial. Right at the bottom, you can click on the bitmap to see the byte-code. Create an own Symbol\n Further application The class is implemented in the sample project Photobooth.\nFurther project ideas  A Temperature Sensor hooked to a display, where it constantly shows how warm it is A microphone, which listens what is said, and writing on the display what is said  "},{"uri":"https://pi4j.com/examples/components/ledbutton/","title":"LED Button","tags":["LEDButton"],"description":"","content":"Description The LedButton is a template class, that you can use in your own Java-project. You can take any Button with a LED you want to. Like for example the big button bellow in the picture gallery.\nThe Template Class gives you the option to check the state of the button, and to create simple events if the button is pressed or depressed, or the whole time is is being pressed. Also it lets you control the LED.\nLayout     Led Button Breadboard\n      Big Button\n                               Code A simple example on how to use the Button-Class from the Hardware-Catalog:\nSystem.out.println(\u0026#34;LED button app started ...\u0026#34;); // Initialize the button component final LedButton ledButton = new LedButton(pi4j, PIN.D26, Boolean.FALSE, PIN.PWM19); // Turn on the LED to have a defined state ledButton.ledOn(); //see the LED for a Second delay(1000); // Register event handlers to print a message when pressed (onDown) and depressed (onUp) ledButton.btnOnDown(() -\u0026gt; System.out.println(\u0026#34;Pressing the Button\u0026#34;)); ledButton.btnOnUp(() -\u0026gt; System.out.println(\u0026#34;Stopped pressing.\u0026#34;)); // Wait for 15 seconds while handling events before exiting System.out.println(\u0026#34;Press the button to see it in action!\u0026#34;); // Make a flashing light by toggling the LED every second // in the meantime, the Button can still be pressed, as we only freeze the main thread for (int i = 0; i \u0026lt; 15; i++) { System.out.println(ledButton.ledToggleState()); delay(1000); } // Unregister all event handlers to exit this application in a clean way ledButton.btnDeRegisterAll(); ledButton.ledOff(); System.out.println(\u0026#34;LED button app done.\u0026#34;); Further application The class is implemented in the two sample projects Theremin and Photobooth.\nFurther project ideas  An application, which includes a button. if the button is pressed, the app will order you a crate of beer from your favorite store. An application, where you can play \u0026ldquo;whack a mole\u0026rdquo;. If the LED is on and you hit the right button, you get points.  "},{"uri":"https://pi4j.com/examples/components/ledmatrix/","title":"LED Matrix","tags":["LEDMatrix"],"description":"","content":"Description The LedMatrix is a template class, that you can use in your own Java-project. It is an extension of the class LEDStrip. An LED matrix can be built from one LED strip. To do this, separate the LED strip at the desired point and place the individual strips under each other or next to each other. The individual ends can then be connected to each other with a wire. The constructor can be passed either as a rectangular matrix or a user-defined matrix with different numbers of LEDs in the individual strips. A software compatible LED strip is for example the WS28xx-chip set LED Strip.\nMake sure to check if SPI is enabled in your RaspberryPI. Check the SPI Address. Default is \u0026ldquo;SPI0 MOSI\u0026rdquo; Pin (#19).\n Layout     LED Matrix Breadboard\n      LED Matrix\n                               Code A simple example on how to use the LEDMatrix-Class from the Hardware-Catalog:\nSystem.out.println(\u0026#34;LED matrix app started ...\u0026#34;); int Rows = 3; int Columns = 4; double brightness = 0.5; System.out.println(\u0026#34;Initialising the matrix\u0026#34;); LedMatrix ledMatrix = new LedMatrix(pi4j, Rows, Columns, brightness); System.out.println(\u0026#34;Setting all LEDs to Red.\u0026#34;); ledMatrix.setMatrixColor(LedStrip.PixelColor.RED); ledMatrix.render(); delay(3000); System.out.println(\u0026#34;setting the second strip to green\u0026#34;); ledMatrix.setStripColor(1, LedStrip.PixelColor.GREEN); ledMatrix.render(); delay(3000); System.out.println(\u0026#34;Setting the third led of the third strip to Yellow\u0026#34;); ledMatrix.setPixelColor(2, 2, LedStrip.PixelColor.YELLOW); ledMatrix.render(); delay(3000); ledMatrix.close(); System.out.println(\u0026#34;LED matrix app done.\u0026#34;); Further application The class is not yet implemented in a project.\nFurther project ideas  A suit with a sewn-on LED matrix, which can be used to display images and animations. A LED-strip which can be used as a backlight of a screen. The color and brightness can change to the volume and mood of the displayed images.  "},{"uri":"https://pi4j.com/examples/components/ledstrip/","title":"LED Strip","tags":["LEDStrip"],"description":"","content":"Description The LedStrip is a template class, that you can use in your own Java-project. You can take a LED Strip with the WS28xx-chip set.\nThe Template Class gives you the option to set the LED\u0026rsquo;s of the strip to a desired RGB-Color. If you have many strips, you can use the LEDMatrix\nMake sure to check if SPI is enabled in your RaspberryPI. Check the SPI Address. Default is \u0026ldquo;SPI0 MOSI\u0026rdquo; Pin (#19).\n Layout     LED Strip 4 LED Breadboard\n      LED Strip 4 LED\n                               Code A simple example on how to use the LEDStrip-Class from the Hardware-Catalog:\nSystem.out.println(\u0026#34;LED strip app started ...\u0026#34;); // Initialize the RGB int pixels = 4; final LedStrip ledStrip = new LedStrip(pi4j, pixels, 0.5); //set them all off, so nothing is shining System.out.println(\u0026#34;Starting with setting all leds off\u0026#34;); ledStrip.allOff(); System.out.println(\u0026#34;setting the LEDs to RED\u0026#34;); ledStrip.setStripColor(LedStrip.PixelColor.RED); ledStrip.render(); delay(3000); System.out.println(\u0026#34;setting the LEDs to Light Blue\u0026#34;); ledStrip.setStripColor(LedStrip.PixelColor.LIGHT_BLUE); ledStrip.render(); delay(3000); System.out.println(\u0026#34;setting the first led to Purple\u0026#34;); ledStrip.setPixelColor(0, LedStrip.PixelColor.PURPLE); ledStrip.render(); delay(3000); System.out.println(\u0026#34;setting the brightness to full and just show the first led as White\u0026#34;); ledStrip.allOff(); ledStrip.setBrightness(1); ledStrip.setPixelColor(0, LedStrip.PixelColor.WHITE); ledStrip.render(); delay(3000); //finishing and closing ledStrip.close(); System.out.println(\u0026#34;closing the app\u0026#34;); System.out.println(\u0026#34;Color \u0026#34;+ ledStrip.getPixelColor(0)); System.out.println(\u0026#34;LED strip app done.\u0026#34;); Further application The class is implemented in the sample project Photobooth.\nFurther project ideas  A suit with LED-Strips sewn on, on which different animations can run. A LED-strip which can be used as a backlight of a screen. The color and brightness can change to the volume and mood of the displayed images.  "},{"uri":"https://pi4j.com/examples/components/potentiometer/","title":"Potentiometer","tags":["Potentiometer"],"description":"","content":"Description The Potentiometer is a template class, that you can use in your own Java-project. The constructor of the class requires an ADS1115 object. In addition, the channel, with which the AD converter evaluates the current position of the sliding contact must be defined. For normalization, the maximum voltage that can drop across the sliding contact must also be specified. Any commercially available potentiometer with three connections (fixed resistor and the slider) can be evaluated with this class.\nThe current position of the slider can be defined with a single shot. The return value is either in volts or as a normalized value between 0 and 1.\nFor continuous monitoring either a slow method can be selected or a fast one. In this case, individual measurements (single shots) are started and evaluated cyclically. With this method, up to 4 devices can be attached to the AD converter. The maximum sampling frequency of the signal depends on how many channels of the AD converter are used simultaneously and how high the sampling rate of the AD converter is set to.\nUsing the fast method, a continuous measurement is started in the AD converter. The maximum sampling frequency is now only dependent on the sampling rate of the AD converter. However, in this mode only one device can be attached to the AD converter simultaneously.\nIf continuous measurement is active, a customized event can be triggered when the position of the slider changes. The threshold can be used to set the sensitivity at which the event should be triggered.\nLayout     Potentiometer Breadboard\n      Potentiometer\n      ADS1115-Front\n      ADS1115-Back\n                               Code A simple example on how to use the potentiometer from the Hardware-Catalog:\nSystem.out.println(\u0026#34;Potentiometer test started ...\u0026#34;); Ads1115 ads1115 = new Ads1115(pi4j, 0x01, Ads1115.GAIN.GAIN_4_096V, Ads1115.ADDRESS.GND, 4); Potentiometer poti = new Potentiometer(ads1115, 0, 3.3); //read current value from poti one time System.out.println(\u0026#34;Current value of the poti is \u0026#34; + String.format(\u0026#34;%.3f\u0026#34;, poti.singleShotGetVoltage()) + \u0026#34; voltage.\u0026#34;); //read current value from the poti in percent one time System.out.println(\u0026#34;The potentiometer slider is currently at \u0026#34; + String.format(\u0026#34;%.3f\u0026#34;, poti.singleShotGetNormalizedValue()) + \u0026#34; % of its full travel.\u0026#34;); // Register event handlers to print a message when potentiometer is moved poti.setConsumerSlowReadChan((value) -\u0026gt; System.out.println(\u0026#34;The potentiometer slider is currently at \u0026#34; + String.format(\u0026#34;%.3f\u0026#34;, value) + \u0026#34; % of its full travel.\u0026#34;)); //start continuous reading with single shot in this mode you can connect up to 4 devices to the analog module poti.startSlowContinuousReading(0.05, 10); // Wait while handling events before exiting System.out.println(\u0026#34;Move the potentiometer to see it in action!\u0026#34;); delay(30_000); //stop continuous reading poti.stopSlowContinuousReading(); System.out.println(\u0026#34;Potentiometer test done\u0026#34;); Further application The class is implemented in the sample project Theremin.\nFurther project ideas  An application, to control the brightness of some lights. The speed and direction of a drone can be controlled with a potentiometer.  "},{"uri":"https://pi4j.com/examples/components/servo/","title":"ServoMotor","tags":["ServoMotor"],"description":"","content":"Description The ServoMotor is a template class, that you can use in your own Java-project. You can set the servo to a specific location, likewise to 110 degrees of it\u0026rsquo;s range.\nYou can use a wide variety of analog servo motors such as the SG92R or the SG-5010 (for a little more torque).\nLayout     Servo Breadboard\n      Servo SG-5010 Top View\n      Servo SG-5010 Side View\n      Servo SG92R Side View\n      Mini Power Supply Module\n      Mini Power Supply Module Front Back\n                               Code An example how to use the Servo-Class from the Hardware-Catalog:\n// Initialize servo motor component final var servoMotor = new ServoMotor(pi4j, PIN.PWM18.getPin()); // Demonstrate the percentage mapping on the servo System.out.println(\u0026#34;In 2 seconds, the servo motor will move to the left-most position which is 0%\u0026#34;); delay(2000); servoMotor.setPercent(10); System.out.println(\u0026#34;In another 2 seconds, the servo motor will show 100% by moving to the right-most position\u0026#34;); delay(2000); servoMotor.setPercent(90); System.out.println(\u0026#34;Last but not least, in 2 more seconds the servo will be centered to display 50%\u0026#34;); delay(2000); servoMotor.setPercent(50); // Sweep once from left to right using the setAngle function System.out.println(\u0026#34;We will sweep once to the left in 2 seconds...\u0026#34;); delay(2000); servoMotor.setAngle(-80); System.out.println(\u0026#34;... and now to the right in 2 more seconds!\u0026#34;); delay(2000); servoMotor.setAngle(80); // Use a custom range for displaying the data System.out.println(\u0026#34;Imagine a pointer on the servo positioned above a label between -20ºC and +40ºC\u0026#34;); System.out.println(\u0026#34;By using the setRange() method, we can automatically map our temperature range to the servo range!\u0026#34;); System.out.println(\u0026#34;As an example, in five seconds the servo will show -10º which should be on the far left of the servo.\u0026#34;); delay(2000); servoMotor.setRange(-20, +40); // This will define our range as values between -20 and +40 servoMotor.moveOnRange(-10); // This will map -10 based on the previously defined range  delay(2000); //back to middle position System.out.println(\u0026#34;To finish the servo will be centered to display 50%\u0026#34;); servoMotor.setPercent(50); // And this demo is over, sleep for a second to give the servo some time to position itself delay(1000); Further application The class is implemented in the two sample projects Theremin and Photobooth.\nFurther project ideas  As a Servo can cover up to 180 degrees, it could be used as a steering-wheel hooked to a potentiometer As a pointer, to show how much time is left in a timer  "},{"uri":"https://pi4j.com/documentation/io-examples/pwm/","title":"Pulse Width Modulation (PWM)","tags":["PWM"],"description":"","content":"What is it? The abbreviation PWM stands for \u0026ldquo;Pulse Width Modulation\u0026rdquo; and is also often referred to in German as pulse width modulation or pulse width modulation. This technology is used, among other things, to control servomotors and is also used, for example, for the fans of a regular computer.\nWith PWM, it is possible to control a component such as a motor no longer purely binary, i.e. off (0% power) or on (100% power), but to control them almost at will. The functionality of PWM works in such a way that the component is switched off and on again and again within a certain period of time.\nSoftware vs. Hardware Two different types of PWM are available on the Raspberry Pi, specifically a software and a hardware implementation. Both basically offer the same options, but the software version cannot achieve precise or particularly fast frequencies.\nThe reason for this is that in the software implementation for each individual cycle (on / off) a new control command must be transmitted from the JVM (Java Virtual Machine) to the corresponding component, while in the hardware implementation of the Raspberry Pi notices the desired frequency and regulates it independently directly on the board.\nThe Raspberry Pi supports 2 hardware based PWM channels. You can access these two channels via 2 separate sets of 4 GPIO header pins, but still limited to only 2 channels (2 unique PWM timing configurations).\nThe same PWM channel is available on multiple GPIO. The latest frequency and dutycycle setting will be used by all GPIO which share a PWM channel. The GPIO must be one of the following: 12 PWM channel 0 All models but A and B 13 PWM channel 1 All models but A and B 18 PWM channel 0 All models 19 PWM channel 1 All models but A and B 40 PWM channel 0 Compute module only 41 PWM channel 1 Compute module only 45 PWM channel 1 Compute module only 52 PWM channel 0 Compute module only 53 PWM channel 1 Compute module only As Pi4J is using PiGPIO \u0026ldquo;under the hood\u0026rdquo;, you can take advantage of the additional PWM functionalities of it. PiGPIO is providing additional (soft) PWM support to any of the GPIO pins (0-31) and its using some hardware timing technique to optimize performance \u0026mdash; but its not the same as the actual hardware PWM pins natively on the RaspberryPi. In the Pi4J API, we call this \u0026ldquo;Software\u0026rdquo; PWM and you would need to set .pwmType(PwmType.SOFTWARE). We consider this software-based PWM because its being provided at a software layer, in this case by the PIGPIO library.\nIf you need more than 2 PWM pins, use the software PWM functionality, it may be perfectly fine for your application. If they are not good enough, then you will probably need a PWM expander board/chip (controlled by I2C/SPI) to provide additional PWM support.\nTechnical implementation For the technical control of a component with PWM, two values must be defined:\n Pulse-pause ratio (English: Duty Cycle): This value defines the ratio between the switched-on and switched-off status and is represented by a number between 0% and 100%. A value of 50% means that within one cycle the component is switched on exactly half the time and then switched off. A value of 25%, on the other hand, would mean that the component is switched on only a quarter of the time and the component remains switched off for the remaining three quarters of the cycle. Frequency: This value defines how often per second a cycle (on / off) takes place for this component and is usually specified in the unit Hertz (Hz). With a value of 10Hz, the component would alternate 10 times between being switched on and switched off in one second.  These two values can be controlled via the Pi4J library and are also used internally by this project.\nAdditional Information  Wikipedia on PWM Wikipedia with audio frequencies  Code example The following example is an extract of the CrowPi example project which includes a component to control a buzzer with PWM.\npublic class BuzzerComponent extends Component { protected final Pwm pwm; /** * Creates a new buzzer component with a custom BCM pin. * * @param pi4j Pi4J context * @param address Custom BCM pin address */ public BuzzerComponent(Context pi4j, int address) { this.pwm = pi4j.create(buildPwmConfig(pi4j, address)); } /** * Plays a tone with the given frequency in Hz indefinitely. * This method is non-blocking and returns immediately. * A frequency of zero causes the buzzer to play silence. * * @param frequency Frequency in Hz */ public void playTone(int frequency) { playTone(frequency, 0); } /** * Plays a tone with the given frequency in Hz for a specific duration. * This method is blocking and will sleep until the specified duration has passed. * A frequency of zero causes the buzzer to play silence. * A duration of zero to play the tone indefinitely and return immediately. * * @param frequency Frequency in Hz * @param duration Duration in milliseconds */ public void playTone(int frequency, int duration) { if (frequency \u0026gt; 0) { // Activate the PWM with a duty cycle of 50% and the given frequency in Hz.  // This causes the buzzer to be on for half of the time during each cycle, resulting in the desired frequency.  pwm.on(50, frequency); // If the duration is larger than zero, the tone should be automatically stopped after the given duration.  if (duration \u0026gt; 0) { sleep(duration); this.playSilence(); } } else { this.playSilence(duration); } } /** * Silences the buzzer and returns immediately. */ public void playSilence() { pwm.off(); } /** * Silences the buzzer and waits for the given duration. * This method is blocking and will sleep until the specified duration has passed. * * @param duration Duration in milliseconds */ public void playSilence(int duration) { this.playSilence(); sleep(duration); } /** * Returns the created PWM instance for the buzzer * * @return PWM instance */ protected Pwm getPwm() { return this.pwm; } /** * Builds a new PWM configuration for the buzzer * * @param pi4j Pi4J context * @param address BCM pin address * @return PWM configuration */ protected static PwmConfig buildPwmConfig(Context pi4j, int address) { return Pwm.newConfigBuilder(pi4j) .id(\u0026#34;BCM\u0026#34; + address) .name(\u0026#34;Buzzer\u0026#34;) .address(address) .pwmType(PwmType.HARDWARE) .provider(\u0026#34;pigpio-pwm\u0026#34;) .initial(0) .shutdown(0) .build(); } } "},{"uri":"https://pi4j.com/documentation/io-examples/i2c/","title":"Inter-Integrated Circuit (I²C)","tags":["I2C"],"description":"","content":"What is it? I²C (spoken as I-Squared-C) is a bus originally invented by Philips. It is designed as a classic master-slave bus. A data transfer is always i nitiated by a master. It can also be set up in a multi-master system. I²C is connected via two signal lines (data line and clock line). The transmission rate of the bus can be between 0.1 Mbit/s up to 3.4 Mbit/s depending on the clock rate. If only a unidirectional connection is required, even 5.0 Mbit/s would be possible. It should be noted: the higher the clock rate, the more susceptible to failure the overall system becomes. The low operating voltage of only 3.3V does not contribute to interference resistance either.\nUses I²C is mainly used for communication between microcontrollers. The advantage that a whole series of microcontrollers can be controlled via just 2 lines is of course very interesting for the circuit board layout. The main advantages of I²C are its simplicity. There are certainly newer bus systems with better transmission rates. Hardly any bus system is as easy to use as I²C. Even “hot plugging”, ie plugging in and unplugging the devices during operation, is possible with I²C.\nAddressing I²C uses an address space of 7 bits. This allows up to 112 nodes on one bus. The remaining 16 addresses are reserved for special applications. Usually the address of a device is defined directly by the manufacturer. It can therefore be found in the relevant data sheets. Due to the shortage of addresses, there is also a variant with a 10-bit address space. Up to 1136 nodes are possible, and the protocol is compatible with the smaller 7-bit address space.\nTransfer rates    Mode Max. transfer rate Direction     Standard Mode 0.1 Mbit/s bidirektional   Fast Mode 0.4 Mbit/s bidirektional   Fast Mode Plus 1.0 Mbit/s bidirektional   High Speed Mode 3.4 Mbit/s bidirektional   Ultra Fast-mode 5.0 Mbit/s unidirektional    Additional information  Wikipedia I²C I²C Bus  Code example Feel free to check the Kotlin DSL for I²C\n The following code shows setting the pins on a TCA 9534 which can be found on \u0026ldquo;Sequent Microsystems\u0026rdquo;\nTo use the LinuxFS provider, which provides I2C, add the proper dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-linuxfs\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Now we can use the following example:\nimport com.pi4j.Pi4J; import com.pi4j.context.Context; import com.pi4j.io.i2c.I2C; import com.pi4j.io.i2c.I2CConfig; import com.pi4j.io.i2c.I2CProvider; public class SimpleTca9534I2cTest { private static final byte TCA9534_REG_ADDR_OUT_PORT = 0x01; private static final byte TCA9534_REG_ADDR_CFG = 0x03; public static void main(String[] args) throws Exception { Context pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j).id(\u0026#34;TCA9534\u0026#34;).bus(1).device(0x3f).build(); try (I2C tca9534Dev = i2CProvider.create(i2cConfig)) { int config = tca9534Dev.readRegister(TCA9534_REG_ADDR_CFG); if (config \u0026lt; 0) throw new IllegalStateException( \u0026#34;Failed to read configuration from address 0x\u0026#34; + String.format(\u0026#34;%02x\u0026#34;, TCA9534_REG_ADDR_CFG)); byte currentState = (byte) tca9534Dev.readRegister(TCA9534_REG_ADDR_OUT_PORT); if (config != 0x00) { System.out.println(\u0026#34;TCA9534 is not configured as OUTPUT, setting register 0x\u0026#34; + String .format(\u0026#34;%02x\u0026#34;, TCA9534_REG_ADDR_CFG) + \u0026#34; to 0x00\u0026#34;); currentState = 0x00; tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, currentState); tca9534Dev.writeRegister(TCA9534_REG_ADDR_CFG, (byte) 0x00); } // bit 8, is pin 1 on the board itself, so set pins in reverse: \tcurrentState = setPin(currentState, 8, tca9534Dev, true); Thread.sleep(500L); currentState = setPin(currentState, 8, tca9534Dev, false); Thread.sleep(500L); currentState = setPin(currentState, 7, tca9534Dev, true); Thread.sleep(500L); currentState = setPin(currentState, 7, tca9534Dev, false); Thread.sleep(500L); } } public static byte setPin(byte currentState, int pin, I2C tca9534Dev, boolean high) { byte newState; if (high) newState = (byte) (currentState | (1 \u0026lt;\u0026lt; pin)); else newState = (byte) (currentState \u0026amp; ~(1 \u0026lt;\u0026lt; pin)); System.out.println(\u0026#34;Setting TCA9534 to new state \u0026#34; + asBinary(newState)); tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, newState); return newState; } public static String asBinary(byte b) { StringBuilder sb = new StringBuilder(); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 7) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 6) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 5) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 4) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 3) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 2) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 1) \u0026amp; 1)); sb.append(((b \u0026gt;\u0026gt;\u0026gt; 0) \u0026amp; 1)); return sb.toString(); } } "},{"uri":"https://pi4j.com/documentation/io-examples/i2c/clock-stretching/","title":"I²C Clock Stretching","tags":["I2C"],"description":"","content":"Clock Stretching Please be aware there are some hardware issues when using the Raspberry Pi with devices that expect to be able to use clock stretching, for more info see \u0026ldquo;Adventures in I2C: clock stretching on the Raspberry Pi\u0026rdquo; and \u0026ldquo;I2C stretch bug. Been fixed or not?\u0026quot;.\n Clock stretching in I2C allows a slave device to halt the master before a more data is sent. This is often the case when the slave device writes to an EEPROM etc. which takes longer than a usual read or write to a register.\nOn the Raspberry Pi clock stretching can be configured by using a higher timeout while waiting for a slave to respond. This is something that can not be done by the pi4j, as it requires root privileges.\nThere are two ways to change the clkt_tout value. This repository path has two files, a i2c1_get_clkt_tout.c and i2c1_set_clkt_tout.c. Build them as follows:\nPrepare:\n# install gcc to compile the c files apt install build-essential mkdir clkt_tout cd clkt_tout/ wget wget https://raw.githubusercontent.com/raspihats/raspihats/master/clk_stretch/i2c1_get_clkt_tout.c wget wget https://raw.githubusercontent.com/raspihats/raspihats/master/clk_stretch/i2c1_set_clkt_tout.c Makefile\nSave as Makefile\nCC=gcc CFLAGS=-Wall .PHONY: all install uninstall clean all: i2c1_set_clkt_tout i2c1_get_clkt_tout i2c_get_clkt_tout: i2c1_get_clkt_tout.c $(CC) -o i2c1_get_clkt_tout i2c1_get_clkt_tout.c i2c_set_clkt_tout: i2c1_set_clkt_tout.c $(CC) -o i2c1_set_clkt_tout i2c1_set_clkt_tout.c install: cp i2c1_get_clkt_tout /usr/local/bin/i2c1_get_clkt_tout cp i2c1_set_clkt_tout /usr/local/bin/i2c1_set_clkt_tout uninstall: rm -f /usr/local/bin/i2c1_get_clkt_tout rm -f /usr/local/bin/i2c1_set_clkt_tout clean: rm -f i2c1_set_clkt_tout i2c1_get_clkt_tout Build and install\nmake sudo make install Usage\n# read current clkt_tout: $ sudo i2c1_get_clkt_tout i2c1_get_clkt_tout: CLKT.TOUT = 1000 # set timeout to 1 second: i2c_set_clkt_tout 1000 "},{"uri":"https://pi4j.com/documentation/io-examples/spi/","title":"Serial Peripheral Interface (SPI)","tags":["SPI"],"description":"","content":"What is it? The Serial Peripheral Interface, abbreviated to SPI, is a bus system which enables communication between a main device (called “master”) and one or more secondary devices (called “slave”). A direct communication between all participants is not possible here, much more the master can choose at any time with which slave he would like to exchange data.\nIn order to address only one slave, a total of 3 signal lines are required, two of which are used for bidirectional data transmission and one as a clock generator for serial transmission. If further slaves are to be addressed, additional signal lines are required depending on the desired topology.\nUses In addition to communication between microcontrollers, SPI is also used to address numerous sensors and actuators. Similar to I²C, a large number of control commands and data can be transmitted in both directions with a relatively high clock rate over 3 lines. A particular advantage here is the support for “full duplex”, ie the simultaneous transmission of data in both directions.\nThe technical implementation is very simple and is also used, for example, to communicate with SD cards. The Nintendo Game Boy already used this protocol to connect several game consoles via the Game Boy Link Cable.\nAddressing As already mentioned in the first section, multiple slaves can also be connected to SPI. The number available depends on the hardware used. On the Raspberry Pi, the standard SPI0 with two different slaves use what is called Chip Select Pins is controlled.\nAdditional Information  Wikipedia SPI SPI pinout for Raspberry Pi  Code example Initialize the Pi4J Context with a provider which supports SPI fully, e.g. the PiGpioSpiProvider. The minimal example would be:\nvar piGpio = PiGpio.newNativeInstance(); var pi4j = Pi4J.newContextBuilder() .noAutoDetect() .add( PiGpioSpiProvider.newInstance(piGpio) ) .build(); Depending on the type of GPIOs you need in your project this could be further extended to e.g.:\nvar piGpio = PiGpio.newNativeInstance(); var pi4j = Pi4J.newContextBuilder() .noAutoDetect() .add( PiGpioDigitalInputProvider.newInstance(piGpio), PiGpioDigitalOutputProvider.newInstance(piGpio), PiGpioPwmProvider.newInstance(piGpio), PiGpioI2CProvider.newInstance(piGpio), PiGpioSerialProvider.newInstance(piGpio), PiGpioSpiProvider.newInstance(piGpio) ) .build(); The following example is an extract of the CrowPi example project which includes a component to control an 8x8 LED matrix display with an MAX7219 driver chip which is controlled via SPI.\npublic class MAX7219 extends Component { // MAX7219: Internal Commands  private static final byte CMD_SET_FIRST_ROW = 0x01; private static final byte CMD_DECODE_MODE = 0x09; private static final byte CMD_INTENSITY = 0x0A; private static final byte CMD_SCAN_LIMIT = 0x0B; private static final byte CMD_SHUTDOWN = 0x0C; private static final byte CMD_DISPLAY_TEST = 0x0F; /** * Width of MAX7219 LED matrix */ public static final int WIDTH = 8; /** * Height of MAX7219 LED matrix */ public static final int HEIGHT = 8; /** * Internal buffer to store the 8x8 matrix * A byte[] array is used as each of the 8 bits is used to represent a column */ protected final byte[] buffer = new byte[HEIGHT]; /** * Pi4J SPI instance */ protected final Spi spi; /** * Creates a new MAX7219 instance using the given SPI instance from Pi4J. * * @param spi SPI instance */ public MAX7219(Spi spi) { this.spi = spi; } /** * Clears the internal buffer without refreshing the display. * This means that the current contents of the displays are still being shown until {@link #refresh()} is called. */ public void clear() { Arrays.fill(buffer, (byte) 0); } /** * Flushes the internal buffer for all rows to the chip, causing it to be displayed. * The contents of the buffer will be preserved by this command. */ public void refresh() { for (int row = 0; row \u0026lt; HEIGHT; row++) { refreshRow(row); } } /** * Flushes the internal buffer for a single row to the chip, causing it to be displayed. * The contents of the buffer will be preserved by this command. * * @param row Row to be flushed */ protected void refreshRow(int row) { if (row \u0026lt; 0 || row \u0026gt;= HEIGHT) { throw new IllegalArgumentException(\u0026#34;Row must be an integer in the range 0-\u0026#34; + HEIGHT); } execute((byte) (CMD_SET_FIRST_ROW + row), buffer[row]); } /** * Specifies if the LED matrix should be enabled or disabled. * This will also setup the proper decoding mode and scan limit when enabling the chip. * * @param enabled LED matrix state (true = ON, false = OFF) */ public void setEnabled(boolean enabled) { if (enabled) { execute(CMD_SHUTDOWN, (byte) 0x01); execute(CMD_DECODE_MODE, (byte) 0x00); execute(CMD_SCAN_LIMIT, (byte) 0x07); } else { execute(CMD_SHUTDOWN, (byte) 0x00); } } /** * Enables or disables the testing mode of the LED matrix. * When enabled, all other options (including {@link #setEnabled(boolean)} are ignored and all LEDs are turned on. * To actually control the chip, the test mode MUST be disabled. * * @param enabled Test mode state (true = ON, false = OFF) */ public void setTestMode(boolean enabled) { execute(CMD_DISPLAY_TEST, (byte) (enabled ? 0x01 : 0x00)); } /** * Changes the desired brightness for the LED matrix. * This method expects an integer value within the range 0-15, with 0 being the dimmest and 15 the brightest possible value. * The whole display is affected by this command which gets immediately applied. * * @param brightness Desired brightness from 0-15 */ public void setBrightness(int brightness) { if (brightness \u0026lt; 0 || brightness \u0026gt; 15) { throw new IllegalArgumentException(\u0026#34;Brightness must be an integer in the range 0-15\u0026#34;); } execute(CMD_INTENSITY, (byte) brightness); } /** * Enables or disables the pixel at the given X/Y position within the internal buffer. * This change will not be visible until {@link #refresh()} or {@link #refreshRow(int)} gets called. * * @param x X position to change * @param y Y position to change * @param enabled Desired pixel state (true = ON, false = OFF) */ public void setPixel(int x, int y, boolean enabled) { // Ensure coordinates are within boundaries  checkPixelBounds(x, y); // Generate bitmask and set/unset specific bit  final byte mask = (byte) (1 \u0026lt;\u0026lt; (WIDTH - 1 - x)); if (enabled) { buffer[y] |= mask; } else { buffer[y] \u0026amp;= ~mask; } } /** * Retrieves the pixel at the given X/Y position within the internal buffer. * * @param x X position to change * @param y Y position to change * @return Current state of specified pixel (true = ON, false = OFF) */ public boolean getPixel(int x, int y) { // Ensure coordinates are within boundaries  checkPixelBounds(x, y); // Generate bitmask and retrieve specific bit  final byte mask = (byte) (1 \u0026lt;\u0026lt; (WIDTH - 1 - x)); return (buffer[y] \u0026amp; mask) != 0; } /** * Ensures the given X and Y coordinates are within the boundaries of this LED matrix. * An {@link IllegalArgumentException} will be thrown if outside. * * @param x X coordinate to check * @param y Y coordinate to check */ private void checkPixelBounds(int x, int y) { if (x \u0026lt; 0 || x \u0026gt;= WIDTH) { throw new IllegalArgumentException(\u0026#34;X must be an integer in the range 0-\u0026#34; + WIDTH); } if (y \u0026lt; 0 || y \u0026gt;= WIDTH) { throw new IllegalArgumentException(\u0026#34;Y must be an integer in the range 0-\u0026#34; + HEIGHT); } } /** * Helper method for sending a command to the MAX7219 chip with data. Communication happens over SPI by simply sending two pieces of * data, more specifically the desired command as a byte value, followed by the data as another byte value. * * @param command Command to be executed * @param data Data for the given command */ private void execute(byte command, byte data) { spi.write(command, data); } } "},{"uri":"https://pi4j.com/documentation/io-examples/serial/","title":"Serial (UART/RS232)","tags":["Serial"],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-components/blob/main/src/main/java/com/pi4j/catalog/applications/SerialGps_App.java\n What is it? Serial communication can be used to transfer data between different boards, devices, etc. Data is transfered bit-by-bit in a sequence, through a single wire from a transmitter (= TX) to a receiver (= RX). On the receiver side the bits are combined to bytes.\nWhen you need two-way communication, two wires are needed between RX and TX from both sides:\nThe communication between these two devices can happen in different ways:\n simplex: one direction only without a message back to confirm the receiving half-duplex: devices can only send or receive at once full-duplex: both devices can send and receive at the same time  Serial communication is done at a predefined speed which needs to be known on both sides, as both the sender and receiver need to handle the data at the same speed. This speed is called the \u0026ldquo;baud rate\u0026rdquo; with a value indicating the number of bits per second (bps). The most used speed is 9600 bps, but you can use lower (1200, 2400, 4800) or higher (19200, 38400, 57600, 115200) speeds, depending on the speed which can be handled reliably by the device.\nThe Pi has two built-in connections to GPIOs BCM number 14 (TX) and 15 (RX). Identical to the other GPIOs, they use 3.3V so make sure, when you connect other devices, the same voltage is used.\nFeel free to check the Kotlin DSL for Serial\n Uart Types The following details are located in the Pi4 BCM2711-peripherals document. The BCM2711 device has six UARTs. One mini UART (UART1) and five PL011 UARTs (UART0, UART2, UART3, UART4, and UART5).\nMini UART Raspberry Pi GPIO14 and GPIO15 support operation as a mini UART.\n 7-bit or 8-bit operation 1 start and 1 stop bit No parities Break generation 8 symbols deep FIFOs for receive and transmit SW controlled RTS, SW readable CTS Auto flow control with programmable FIFO level 16550 like registers Baudrate derived from system clock  PL011 The fuller function PL011 uarts are available via GPIO Alternative Function Assignments. See Pi command raspi-gpio funcs.\nLimitations At the present time the PiGpio library supports only Parity None on any/all uarts. Any future additional UART functionality within the PiGpio library will require changes within the Pi4J code base.\nCode example The following example demonstrates how you can connect to a GPS module to read the data. This example is based on an example from the book \u0026ldquo;The Definitive Guide to Modern Java Clients with JavaFX\u0026rdquo; by Stephen Chin, Johan Vos and James Weaver. That example uses V1 of Pi4J with a listener provided by the library. In V.2 this listener is no longer provided but can easily be achieved with a Thread to handle the incoming data.\nThis example has been used by Mark Baird to create an application to record GPS tracks with the ArcGIS Maps SDK for Java. He has written a full explanation in a very nice post on the Esri ArcGIS blog.\n Wiring The GPS module used in this example: NEO-7M.\n   NEO-7M Raspberry Pi     VCC Power 5V (e.g. pin 2)   GND Ground (e.g. pin 6)   RX UART TX, GPIO 15   TX UART RX, GPIO 16    In the readme of the coding example, you can find the description how you can test the GPS module in the terminal with gpsd.socket.\nInitialize the serial port First Pi4J needs to be initialized. Within this context we can then configure and open the serial port. As long as the serial port is open, we run a thread to handle the incoming data.\nvar console = new Console(); var pi4j = Pi4J.newAutoContext(); var serial = pi4j.create(Serial.newConfigBuilder(pi4j) .use_9600_N81() .dataBits_8() .parity(Parity.NONE) .stopBits(StopBits._1) .flowControl(FlowControl.NONE) .id(\u0026#34;my-serial\u0026#34;) .device(SERIAL_ADDRESS) .provider(\u0026#34;pigpio-serial\u0026#34;) .build()); serial.open(); // Wait till the serial port is open console.print(\u0026#34;Waiting till serial port is open\u0026#34;); while (!serial.isOpen()) { Thread.sleep(250); } // Start a thread to handle the incoming data from the serial port SerialReader serialReader = new SerialReader(console, serial); Thread serialReaderThread = new Thread(serialReader, \u0026#34;SerialReader\u0026#34;); serialReaderThread.setDaemon(true); serialReaderThread.start(); while (serial.isOpen()) { Thread.sleep(500); } serialReader.stopReading(); Serial reader The reader itself implements a Runnable and waits till data is available from the serial port. As the GPS module sends its data as readable String lines seperated by a line separator, we only need to handle the bytes which are higher than 32 (see the ASCII code table). All lower values are handled as line separators.\npublic class SerialReader implements Runnable { private final Console console; private final Serial serial; private boolean continueReading = true; public SerialReader(Console console, Serial serial) { this.console = console; this.serial = serial; } public void stopReading() { continueReading = false; } @Override public void run() { // We use a buffered reader to handle the data received from the serial port  BufferedReader br = new BufferedReader(new InputStreamReader(serial.getInputStream())); try { // Data from the GPS is recieved in lines  String line = \u0026#34;\u0026#34;; // Read data until the flag is false  while (continueReading) { // First we need to check if there is data available to read.  // The read() command for pigio-serial is a NON-BLOCKING call,  // in contrast to typical java input streams.  var available = serial.available(); if (available \u0026gt; 0) { for (int i = 0; i \u0026lt; available; i++) { byte b = (byte) br.read(); if (b \u0026lt; 32) { // All non-string bytes are handled as line breaks  if (!line.isEmpty()) { // Here we should add code to parse the data to a GPS data object  console.println(\u0026#34;Data: \u0026#39;\u0026#34; + line + \u0026#34;\u0026#39;\u0026#34;); line = \u0026#34;\u0026#34;; } } else { line += (char) b; } } } else { Thread.sleep(10); } } } catch (Exception e) { console.println(\u0026#34;Error reading data from serial: \u0026#34; + e.getMessage()); System.out.println(e.getStackTrace()); } } } Running the application on Raspberry Pi You can get the full working example from GitHub and run on a Raspberry Pi after you correctly connected a GPS module. As you can see in the output, each data line (starting with $GP...) is logged.\n[main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - \u0026lt;-- The Pi4J Project --\u0026gt; [main] INFO com.pi4j.util.Console - Serial Example project [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - ************************************************************ [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.Pi4J - New auto context [main] INFO com.pi4j.Pi4J - New context builder [main] INFO com.pi4j.platform.impl.DefaultRuntimePlatforms - adding platform to managed platform map [id=raspberrypi; name=RaspberryPi Platform; priority=5; class=com.pi4j.plugin.raspberrypi.platform.RaspberryPiPlatform] ... [main] INFO com.pi4j.util.Console - Waiting till serial port is open [main] INFO com.pi4j.util.Console - [main] INFO com.pi4j.util.Console - Serial port is open ... [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPVTG,,T,,M,2.349,N,4.351,K,A*2C\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGGA,143723.00,5054.02265,N,00301.10531,E,1,04,10.46,86.2,M,45.9,M,,*5C\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGSA,A,3,09,16,05,07,,,,,,,,,17.19,10.46,13.64*33\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGSV,2,1,06,05,33,304,20,07,67,101,21,09,39,079,29,11,38,228,20*7E\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGSV,2,2,06,16,11,030,24,20,63,283,*73\u0026#39; [SerialReader] INFO com.pi4j.util.Console - Data: \u0026#39;$GPGLL,5054.02265,N,00301.10531,E,143723.00,A,A*6A\u0026#39; "},{"uri":"https://pi4j.com/architecture/pi4j-logo/","title":"The Pi4J Logo","tags":[],"description":"","content":" GITHUB PROJECT: https://github.com/Pi4J/pi4j-logo\n The Pi4J logo has been designed by Gerrit Grunwald and is nicely combines a raspberry pie with Duke, the Java Masqot.\n"},{"uri":"https://pi4j.com/tags/javafx/","title":"JavaFX","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/blog/2023/20230731_pi4j_os/","title":"Pi4J Operating System","tags":["JavaFX","Pi4J OS"],"description":"","content":"2023-07-31, by Frank Delporte and Dieter Holz\nYes, the Raspberry Pi Operating System is awesome! But the Pi4J project made it if even more awesome by adding \u0026ldquo;goodies\u0026rdquo; for Java developers! Pi4J OS is not yet another OS, but the official Raspberry Pi OS, with additional tools and preconfigurations to make it the ideal OS for any Java and JavaFX developer who wants to use a Raspberry Pi.\nThe project is shared on GitHub and documented on the Pi4J website. The zip-compressed archives of released versions can be downloaded from pi4j-download.com.\nWhy Pi4J OS? By using these images, you will get a lot of preconfigurations (locale, keyboard, wireless,\u0026hellip;), pre-installations (Java, JavaFX, starter scripts), and a very useful desktop background showing the ethernet and/or WLAN address and hostname.\nAs the FHNW University uses this OS in different courses, and the Pi4J project provides examples for various use-cases, different \u0026ldquo;flavors\u0026rdquo; of the OS are available:\n Pi4J-Basic-OS Pi4J-CrowPi-OS (= Pi4J-Basic-OS + support for CrowPi Pi4J-Picade-OS (= Pi4J-Basic-OS + support for Picade Console and Picade X HAT USB-C  For all the info about what’s included in each version, check the overview on pi4j.com/pi4j-os.\n    Desktop background showing the IP info\n      Pure JavaFX example\n      Pure JavaFX example running in kiosk mode\n                               History of the project This project was originally started by Pascal Mathis as a student at the FHNW University in Switzerland, while working on a project to control all the electronic components in an Elecrow CrowPi with Java code.\nDieter Holz, Lecturer for Object-Oriented-Programming and UI Engineering at FHNW, further expanded the Pi4J OS in the different \u0026ldquo;flavors\u0026rdquo; to offer the ideal setup for his students.\nOur students (1st and 2nd semester) should be able to focus on learning programming, especially in Java). Without the Pi4J OS images, they would have to learn a lot about Linux configuration, installation utilities, remote deployment, Maven, etc before they could start with their projects. All of these topics they need to learn later during their studies, but it’s overwhelming if you need to know it from the very first day.\nSetting up a complete image is really time consuming, even if you know the bits and pieces already. At FHNW we start with CrowPi. The SD-card with Pi4J-CrowPi-Image is already plugged in. Students can start with their Pi4J-experiments “immediately”, even without typical hardware problems like connecting a LED.\nIn a second phase, we use the Pi4J-Basic-OS, and the first hardware-connection experiments are added.\nIn the third phase, using our JavaFX-template-project, they start with their \u0026ldquo;real\u0026rdquo; project. If they want to build a FXGL game, the Picade-Image is used. The main advantage here is, that ENTER-, cursor-, and ESC-keys are mapped on OS-Level. This is necessary to get the default FXGL-behaviour for the main-menu.\nConclusion Pi4J is an ideal way to introduce the Java language into experiments with electronic components. And Pi4J OS makes this even easier for students and everyone interested in #JavaOnRaspberryPi.\n"},{"uri":"https://pi4j.com/tags/pi4j-os/","title":"Pi4J OS","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/","title":"Welcome to Pi4J","tags":[],"description":"","content":"Welcome to Pi4J Latest release: V2.3.0 (2023-02-06, see Release Notes).\nThis project is intended to provide a friendly object-oriented I/O API and implementation libraries for Java Programmers to access the full I/O capabilities of the Raspberry Pi platform. This project abstracts the low-level native integration and interrupt monitoring to enable Java programmers to focus on implementing their application business logic.\nBrief History The Pi4J Project was started in 2012, the same year the Raspberry Pi was introduced as a tool to provide Java developers a simple and familiar object-oriented interface library to access the low-level I/O capabilities of the Raspberry Pi including GPIO, I2C, SPI, PWM and Serial communications.\nProject Mission/Goals The Pi4J Project\u0026rsquo;s mission is to provide a rich and powerful, yet simple to use, Java-friendly API library enabling programmatic access to the low-level hardware I/O capabilities of embedded platforms such as the Raspberry Pi.\nProject Status Summary The Pi4j project has evolved in all these years as the whole Java eco-system and Raspberry Pi systems have been evolving.\nThis resulted in two main versions.\nVersion 1 The original library which started in 2012 and got a last release in 2021. Up till version 1.3 the library targets Java 8, while version 1.4 relies on Java 11. More info is provided on \u0026ldquo;Previous versions (V.1)\u0026quot;.\nVersion 2 As of Version 2.0, Pi4J will no longer include support for peripheral devices and add-on chipsets/boards as part of the core project. A new plugin model has been introduced in version 2.0 that should help enable third-party development and support third-party add-ons which may be developed and maintained independently of the core Pi4J project.\nRead more on \u0026ldquo;What\u0026rsquo;s New (V.2)\u0026quot;.\n"},{"uri":"https://pi4j.com/blog/2022/20221128_led_strip_with_jbang/","title":"LED strip with Pi4J and JBang","tags":[],"description":"","content":"2022-11-28, by Robert von Burg\nIntro In an earlier post, JBang and Pi4J were used to control a LED and button connected to a Raspberry Pi.\nThis week Robert von Burg, one of the main contributors of the Pi4J project, shared on Mastodon another project where a LED strip is controlled via I2C.\nThis is the result, notice the Foojay.io startup artwork 😉\n  Wiring The Raspberry Pi in the video is attached to a custom PCB used by Robert in medical cabinets.\nThis PCB contains a few different connectors:\n An 8 port I2C multiplexer for connecting up to 8 additional I2C devices, thus nesting I2C buses. An 8 port 1-Wire over I2C bridge to connect 8 1-Wire buses over I2C. In the middle of the board is an extension of the Raspberry Pi\u0026rsquo;s I2C bus. The LED strip itself is connected to a custom PCB with a PIC16F18344 from Microchip. This chips firmware communicates with the LED, allowing to be configured over I2C.  For a simple Raspberry Pi-only setup, connect the wires of the LED strip to:\n 5V Ground GPIO 2, physical pin 3, I2C data (see https://pinout.xyz/pinout/i2c)  In this case, make sure to only use a short LED strip, as the board can not provide enough power for a large number of LEDs.\nCode As this is a JBang project, all the dependencies and code are combined into one single file.\nThe structure of this file is:\n. \u0026ldquo;Trick\u0026rdquo; the system to run this file with JBang using the comment in the first line . Tell JBang which dependencies are needed with the //DEPS \u0026hellip; comment lines . And the rest is just a normal Java class\n///usr/bin/env jbang \u0026#34;$0\u0026#34; \u0026#34;$@\u0026#34; ; exit $? //DEPS org.slf4j:slf4j-api:2.0.3 //DEPS org.slf4j:slf4j-simple:2.0.3 //DEPS com.github.lalyos:jfiglet:0.0.8 //DEPS com.pi4j:pi4j-core:2.2.1 //DEPS com.pi4j:pi4j-plugin-raspberrypi:2.2.1 //DEPS com.pi4j:pi4j-plugin-pigpio:2.2.1 //DEPS com.pi4j:pi4j-plugin-linuxfs:2.2.1 import com.github.lalyos.jfiglet.FigletFont; import com.pi4j.Pi4J; import com.pi4j.context.Context; import com.pi4j.io.i2c.I2C; import com.pi4j.io.i2c.I2CConfig; import com.pi4j.io.i2c.I2CProvider; class LedStrip { static final byte ADDR_LED_STRIP = 0x48; static final byte CMD_COLOR = 0x01; static final byte CMD_CONTRAST = 0x02; static final byte CMD_PATTERN = 0x03; static final byte CMD_PTR_GRB_LED_1 = 0x10; static final byte CMD_PTR_GRB_LED_2 = 0x13; static final byte CMD_PTR_GRB_LED_3 = 0x16; static final byte CMD_PTR_GRB_LED_4 = 0x19; static final byte PATTERN_ON = (byte) 0xFF; static final byte PATTERN_OFF = 0x00; static final byte PATTERN_BLINK_1S = (byte) 0xAA; static final byte PATTERN_BLINK_2S = (byte) 0xCC; static final byte PATTERN_BLINK_4S = (byte) 0xF0; static final byte COL_A_AZURE = 0x41; static final byte COL_B_BLUE = 0x42; static final byte COL_C_CYAN = 0x43; static final byte COL_D_DARK = 0x44; static final byte COL_F_FUSCHIA = 0x46; static final byte COL_G_GREEN = 0x47; static final byte COL_L_LIME = 0x4C; static final byte COL_M_MAGENTA = 0x4D; static final byte COL_O_ORANGE = 0x4F; static final byte COL_R_RED = 0x52; static final byte COL_S_SPRING = 0x53; static final byte COL_V_VIOLET = 0x56; static final byte COL_W_WHITE = 0x57; static final byte COL_Y_YELLOW = 0x59; static final byte[] COLORS = new byte[] {COL_A_AZURE, COL_B_BLUE, COL_C_CYAN, COL_D_DARK, COL_F_FUSCHIA, COL_G_GREEN, COL_L_LIME, COL_M_MAGENTA, COL_O_ORANGE, COL_R_RED, COL_S_SPRING, COL_V_VIOLET, COL_W_WHITE, COL_Y_YELLOW}; public static void main(String... args) throws Exception { System.out.println(FigletFont.convertOneLine(\u0026#34;Hello foojay.io!\u0026#34;)); Context pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j).bus(1).device(0x48).build(); try (I2C ledStrip = i2CProvider.create(i2cConfig)) { ledStrip.writeRegister(CMD_COLOR, COL_W_WHITE); Thread.sleep(10); ledStrip.writeRegister(CMD_CONTRAST, 0x50); Thread.sleep(10); ledStrip.writeRegister(CMD_PATTERN, PATTERN_ON); Thread.sleep(10); // cycle all colors  int green = 0; int red = 0; int blue = 0; while(true) { if (red \u0026lt; 254) { red++; } else if (green \u0026lt; 254) { green++; } else if (blue \u0026lt; 254) { blue++; } else { break; } ledStrip.writeRegister(CMD_PTR_GRB_LED_2, new byte[] {(byte) green, (byte) red, (byte) blue}); Thread.sleep(10); } // turn all off  ledStrip.writeRegister(CMD_PATTERN, PATTERN_OFF); } } } Conclusion The Raspberry Pi, Pi4J and JBang are a perfect combination to experiment with electronics! Give it a try!!!\n"},{"uri":"https://pi4j.com/blog/2022/20221117_kotlin_on_raspberrypi/","title":"Kotlin on the Raspberry Pi","tags":[],"description":"","content":"2022-11-17, by Muhammad Hashim\nIntro Pi4J is considered the project that brought the JVM to the RaspberryPi.\nIt has been up for more than a decade allowing developers to write sophisticated, high-level, yet simple software on the RaspberryPi.\nAnd we’re glad to make it even more simpler and powerful!\nFor quite some years now Kotlin has been a most welcome language in the JVM ecosystem and the modern development toolchain.\nMany factors led to this great reality, most notable to me is Kotlin’s non-disruptive integration and seamless developer experience.\nEnough reasons for us to bring it over to the RaspberryPi Community!\nPi4J-Kotlin Our latest project, Pi4J-Kotlin, provides a Kotlin DSL for the already-mature \u0026amp; capable Pi4J V2 API. You can take full advantage of Kotlin on the RaspberryPi and write even more capable and concise code for your projects. Blink if you can hear me\nA blinking LED example is a benchmark for code simplicity (at least for me, just pretend). Here’s how to blink with Pi4J-Kotlin:\nfun blink() = digitalOutput(22).run { while (true) { toggle() sleep(500) } } We also have a minimal example to get you started with more components.\nDeclarative API All you have to do to access everything-RaspberryPi is to use the pi4j block:\npi4j { // beautiful code goes here } Here, you created a Pi4J Context that will take care of loading the right Platform and Providers. It will also automatically shutdown the Context after you finish the block. That’s right you no longer have to worry about opening or closing doors; you don’t have time for that!\nPlease never mind my bitter alter ego and let’s discover some other exciting APIs: Using the digitalInput function you can easily create and customise your “pin” using this intuitive DSL:\ndigitalInput(address = 24) { name(“Button”) pull(PULL_DOWN) debounce(3000L) } In the same fashion, Analog and PWM get their fair share of sweetness:\nanalogOutput(24).run { whenInRange(0..5) { // fires when value is in the supplied range  } whenOutOfRange(0..5) { // fires when value is not in the supplied range  } onMin(0..5) { // fires when value changes to the minimum of the range  } onMax(0..5) { // fires when value changes to the maximum of the range  } } And of course we would take full advantage of the intuitive \u0026amp; inlined lambdas of Kotlin to create APIs like these:\n listen { … } onLow { … } onHigh { … }  Be it Digital or Analog IO you’ll find a little API that makes life even more convenient for you (as if what you had wasn’t already enough). Confused as you are, you might want to check the full documentation on these new APIs and lots more.\nThe story doesn’t end There are still more DSLs on their way for communication protocols and standards like SPI, I²C and more!\nTell us what you think Try it out! Tell us what you think and give us some ideas! Here is the GitHub Repository.\n"},{"uri":"https://pi4j.com/blog/2022/20220113_javafx_pi4j_template/","title":"Getting Started Template","tags":[],"description":"","content":"2022-01-13, by Frank Delporte\nIntro The Pi4J project wants to be the starting point for everyone who wants to use Java on the Raspberry Pi, being it a headless, JavaFX-user interface and/or GPIO-controller project.\nPi4J is intended to provide a friendly object-oriented I/O API and implementation libraries for Java Programmers to access the full I/O capabilities of the Raspberry Pi platform. This project abstracts the low-level native integration and interrupt monitoring to enable Java programmers to focus on implementing their application business logic.\nDieter Holz (FHNW University) and Robert von Burg (strolch.li) created a template project which is now part of the Pi4J example repositories. This project makes it even easier to get started and aims to:\n Provide a clear step-by-step how to prepare your Raspberry Pi Provide multiple test and start applications Explain the use of a MVC-model (Model-View-Controller) to clearly split data, actions and user interface Explain the use of JUnit test  Sources and info Please check the README of the sources of the project for a full description of the setup process of the Raspberry Pi and to fully understand the example applications and the MVC-model. This page is only intended to give you a quick overview.\nExample applications HelloFX A simple application to test if the JavaFX libraries are installed correctly. Should not be used as a template for one\u0026rsquo;s own JavaFX applications.\nWiring The two other example applications use an LED and a button. These must be wired as is shown in the following diagram:\nMinimalPi4J The MinimalPi4j application is a Pi4j only application without a GUI. This application is also only used to test the setup and can be deleted after testing.\nPressing the button should generate a message in the console.\nOnce the Pi4J setup has been tested, MinimalPi4J can be deleted.\nTemplateApp This application shows the interaction between a JavaFX based Graphical User Interface (GUI) and the Raspberry Pi connected sensors and actuators, the Physical User Interface (PUI).\nThis application is to be used as a template for one\u0026rsquo;s own applications. This includes the existing test cases.\nYou should first get to know and understand the example. For your own applications you should then copy the TemplateApp and modify it for your project, however without violating the rules of the MVC concept.\nTemplatePUIApp The MVC concept should also be used for applications without a GUI.\nWhen developing PUI only applications, or when adding the GUI later, then one should use the TemplatePUIApp as template.\nThe MVC concept The classic Model-View-Controller concept contains in addition to the starter class at least 3 more classes. The interaction is clearly defined:\nThis way the GUI and PUI are completely separated from each other, i.e a GUI button to turn an LED on has no direct access to the LED component of the PUI. Instead the GUI button triggers a corresponding action in the controller which then sets the on state property in the model. The PUI listening on this state then turns the actual LED on or off.\nGUI and PUI work with the same identical controller and thus also the same identical model.\nIn the MVC concept, every user interaction traverses the exact same cycle:\nConclusion You can use the same architecture (MVC) to implement a JavaFX-based GUI, a PUI attached to a Raspberry Pi, and integrate both in a clean, modular way.\n"},{"uri":"https://pi4j.com/tags/ads1115/","title":"ADS1115","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/annotated-provisioning/","title":"Annotated provisioning","tags":[],"description":"","content":" To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations\n Next to the declarative approach, Java annotations are available for the configuration of I/O provisioning instead of the hard-coded approach offered in V.1.\nThis implementation still needs to be further fine-tuned and unified somehow to make things cleaner and more straightforward, but would provide a way to initialize a I/O for instance like this:\n@Register(0) @Address(\u0026#34;my.digital.input.pin.zero\u0026#34;) @Name(\u0026#34;My Digital Input Pin\u0026#34;) @Debounce(300000) // microseconds @WithProvider(type=PiGpioDigitalInputProvider.class) private DigitalInput input; "},{"uri":"https://pi4j.com/tags/bme280/","title":"BME280","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/bmp208/","title":"BMP208","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/bmp280/","title":"BMP280","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/button/","title":"Button","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/buzzer/","title":"Buzzer","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/camera/","title":"Camera","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/crowpi/","title":"CrowPi","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/dependency-injection/","title":"Dependency injection","tags":[],"description":"","content":" To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations\n Along with the annotated I/O configuration the ability to support I/O provisioning via dependency injection also makes a lot of sense. There is some basic brute-force stuff working but this needs more work to make this a compatible implementation for Spring or CDI.\n@Inject private Context pi4j; // register a digital input listener to listen for any value changes on the digital input pin @Register(DIGITAL_INPUT_PIN_ID) private DigitalStateChangeListener changeListener = event -\u0026gt; System.out.println(\u0026#34; (LISTENER #1) :: \u0026#34; + event); // setup a digital input event listener to listen for any value changes on the digital input // using a custom method with a single event parameter @OnEvent(DIGITAL_INPUT_PIN_ID) private void onDigitalInputChange(DigitalStateChangeEvent event){ System.out.println(\u0026#34; (LISTENER #2) :: \u0026#34; + event); } "},{"uri":"https://pi4j.com/tags/digital-input/","title":"Digital Input","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/digital-output/","title":"Digital Output","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/digitalinput/","title":"DigitalInput","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/digitalouput/","title":"DigitalOuput","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/fatjar/","title":"FatJAR","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/gradle/","title":"Gradle","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/i2c/","title":"I2C","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/intellij-idea/","title":"IntelliJ IDEA","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/javac/","title":"Javac","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/jbang/","title":"JBang","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/joystick/","title":"Joystick","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/joystick-analog/","title":"Joystick analog","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/lcd-display/","title":"LCD Display","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/led/","title":"LED","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/led-strip/","title":"LED Strip","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/ledbutton/","title":"LEDButton","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/ledmatrix/","title":"LEDMatrix","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/ledstrip/","title":"LEDStrip","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/documentation/providers/linuxfs/","title":"LinuxFS","tags":[],"description":"","content":"The current implementation of the LinuxFS plugin implements a file based I2C provider. The file based provider opens /dev/i2c-1 using a RandomAccessFile to perform I2C reads and writes.\nProviders in the LinuxFS plugin:\n linuxfs-i2c Under construction  linuxfs-digital-input linuxfs-digital-output linuxfs-pwm    To use the LinuxFS provider include the following dependencies:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-linuxfs\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; And then one can get access to the provider as follows:\nContext pi4j = Pi4J.newAutoContext(); I2CProvider i2CProvider = pi4j.provider(\u0026#34;linuxfs-i2c\u0026#34;); I2CConfig i2cConfig = I2C.newConfigBuilder(pi4j).id(\u0026#34;TCA9534\u0026#34;).bus(1).device(0x3f).build(); try (I2C tca9534Dev = i2CProvider.create(i2cConfig)) { int config = tca9534Dev.readRegister(TCA9534_REG_ADDR_CFG); tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, currentState); tca9534Dev.writeRegister(TCA9534_REG_ADDR_CFG, (byte) 0x00); tca9534Dev.writeRegister(TCA9534_REG_ADDR_OUT_PORT, newState); } pi4j.shutdown(); "},{"uri":"https://pi4j.com/tags/maven/","title":"Maven","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/library-path/","title":"Native Library Path","tags":[],"description":"","content":"Overview Some Pi4J plugins, such as the Pi4J PiGpio Provider plugin, depend on native JNI libraries to communicate with the underlying system. By default Pi4J embeds these native libraries as resources inside the plugin\u0026rsquo;s JAR file. At runtime Pi4J extracts the native library into a temporary directory so the JVM can load the library from the filesystem. Upon termination the temporary file is automatically removed.\nThis automatic extration behavior works well for most users; however, there are certain edge cases where this may fail. On failure, its common to see a UnsatisfiedLinkError on startup of your application or when you create a Pi4J context. Edge cases such as the following may require customization of the runtime to deal with native library loading.\n Systems that do not support a writable temporary directory (/tmp) may encounter the UnsatisfiedLinkError and fail to load the native library. Systems with very strict security policies may encounter the UnsatisfiedLinkError and fail to load the native library if unable to extract the resource from the JAR at runtime. Users attempting to use Pi4J under Android may also experience the UnsatisfiedLinkError and fail to load the native library.   Explicitly Define the Library Path In the event of a failure to extract and load the embedded native library from the JAR file at runtime, a user can override this default behavior by defining the system property: pi4j.library.path.\nUsage: pi4j.library.path=(system|/some/directory) Values:    Property Value Description     system The default system defined library path for the JVM (java.library.path) will be used to resolve the native libraries.   local Native libraries will be resolved in the same local directory as the plugin JAR file on the file system.   absolute file path(/some/directory) This user defined library path (absolute filesystem path) will be used to resolve the native libraries.    Examples: The pi4j.library.path system property can be assigned in the command line used to launch your Java application using the -D flag.\njava --Dpi4j.library.path=\u0026quot;system\u0026quot; ... -or- java --Dpi4j.library.path=\u0026quot;local\u0026quot; ... -or- java --Dpi4j.library.path=\u0026quot;/some/directory\u0026quot; ... The pi4j.library.path system property can be assigned in your code at startup and prior to creating a Pi4J Context.\nSystem.setProperty(\u0026quot;pi4j.library.path\u0026quot;, \u0026quot;/some/directory\u0026quot;); -or- System.setProperty(\u0026quot;pi4j.library.path\u0026quot;, \u0026quot;system\u0026quot;); -or- System.setProperty(\u0026quot;pi4j.library.path\u0026quot;, \u0026quot;local\u0026quot;);  For more details about the native library loading behavior, please see the NativeLibraryLoader.java class: https://github.com/Pi4J/pi4j-v2/blob/master/libraries/pi4j-library-pigpio/src/main/java/com/pi4j/library/pigpio/util/NativeLibraryLoader.java\n  Where To Get The Native Libraries The Pi4J native libraries can be obtained by extracting the architecture specific libpi4j-xxx.so file from the plugin JAR file\u0026rsquo;s resources.\nAdditionally, the Pi4J native libraries are published as independant artifacts in the Maven Repository: https://oss.sonatype.org/#nexus-search;quick~pi4j-library-pigpio\n"},{"uri":"https://pi4j.com/documentation/providers/pigpio/","title":"PiGpio","tags":[],"description":"","content":"The current implementation of the PiGpio exposes the GPIO functions available on the Raspberry Pi.\nProviders in the PiGpio plugin:\n pigpio-digital-input pigpio-digital-output pigpio-pwm pigpio-i2c pigpio-spi pigpio-serial  To use the PiGpio provider include the following dependencies:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-pigpio\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "},{"uri":"https://pi4j.com/tags/pixelblaze/","title":"Pixelblaze","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/architecture/advanced/plugins/","title":"Plug-ins","tags":[],"description":"","content":"The goal of Pi4J V.2 is to provide a solid base with all required \u0026ldquo;minimal functionality\u0026rdquo; while at the same time, promote third-party development and extensibility, thus enabling developers to build and maintain their extensions outside of the Pi4J core projects codebase.\nThis will enable us to deliver a stable, fully tested framework as the number of features inside of Pi4J can be limited and support for specific I/O hardware can be provided with an extension for Pi4J.\nMore info about how this extensibility is achieved:\n Extensible I/O hardware PROVIDERS: things like GPIO expanders, I2C bus expanders, GertBoard, add-on hardware shields, etc. Extensible SBC platforms PLATFORMS: the core project may only support Raspberry Pi, but the platform and libraries should be written to allow a third party to create plugins for alternate hardware platforms/boards. Extensible plugins.  Plugins are extensible service modules that interact with or augment the Pi4J infrastructure. The most common plugins are I/O Providers and Platforms. Other plugin examples could be a web app to view/control the Pi4J runtime state/status, some third-party observer to the Pi4J runtime state/status,\u0026hellip;\nPlugins are implemented as Java modules using Service Provider Interfaces (SPI).\nPlugins must declare their pluggable interface in their \u0026ldquo;module-info.java\u0026rdquo; config file. Example from the Raspberry plugin:\nmodule com.pi4j.plugin.raspberrypi { requires com.pi4j; exports com.pi4j.plugin.raspberrypi; exports com.pi4j.plugin.raspberrypi.platform; exports com.pi4j.plugin.raspberrypi.provider.gpio.digital; exports com.pi4j.plugin.raspberrypi.provider.pwm; exports com.pi4j.plugin.raspberrypi.provider.serial; exports com.pi4j.plugin.raspberrypi.provider.spi; exports com.pi4j.plugin.raspberrypi.provider.i2c; provides com.pi4j.extension.Plugin with RaspberryPiPlugin; } ServiceLoader overview by Piotr Mińkowski.\n"},{"uri":"https://pi4j.com/tags/potentiometer/","title":"Potentiometer","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/prototype/","title":"Prototype","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/pwm/","title":"PWM","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/documentation/platforms/raspberry-pi/","title":"Raspberry Pi","tags":[],"description":"","content":"Pi4J was designed for the Raspberry Pi, so this is the only supported platform (at this moment), although the architecture of the project allows other platforms to be added.\nAdd this dependency to include the Raspberry Pi Platform Plugin.\n \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.pi4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pi4j-plugin-raspberrypi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${pi4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; "},{"uri":"https://pi4j.com/architecture/advanced/remote-support/","title":"Remote support","tags":[],"description":"","content":"One of the big features on the wish-list for V.2: native support for remote I/O capability. Predominantly to support the ability for a user to perform development work on their desktop/laptop and be able to run their project with remote support slaving the I/O to a daemon running on the Raspberry Pi (or other supported SBC).\nTO BE DECIDED: the V.2 codebase does support this currently by using the PiGpio daemon.\nThis may be an OK place to start for the first release, but a separate Pi4J daemon may be ideal for a long term solution to capture some of the edge cases and provide remote I/O capability no matter which underlying I/O library is being used.\n "},{"uri":"https://pi4j.com/tags/serial/","title":"Serial","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/servomotor/","title":"ServoMotor","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/simple-button/","title":"Simple Button","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/simple-led/","title":"Simple LED","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/spi/","title":"SPI","tags":[],"description":"","content":""},{"uri":"https://pi4j.com/tags/visual-studio-code/","title":"Visual Studio Code","tags":[],"description":"","content":""}]