<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Documentation on Pi4J</title><link>https://pi4j.com/documentation/</link><description>Recent content in Documentation on Pi4J</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://pi4j.com/documentation/index.xml" rel="self" type="application/rss+xml"/><item><title>Pin numbering</title><link>https://pi4j.com/documentation/pin-numbering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/pin-numbering/</guid><description>Pi4J V.1 took a pretty opinionated approach to pin numbering as the scheme was based on the underlying WiringPi. This scheme was incompatibility with other pin diagrams and pin numbering used by other development platforms and libraries.
As Pi4J V.2 is build as a &amp;ldquo;pass thru library&amp;rdquo;, and uses PiGpio as the underlying framework, the more well-known BCM numbering is being used now.
This drawing shows the different numbers for WiringPi and BCM in a 40-pins Raspberry Pi header:</description></item><item><title>Java for ARMv6/7/8</title><link>https://pi4j.com/documentation/java-installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/java-installation/</guid><description>Raspberry Pi OS Full comes with Java 11 pre-installed. But this version only works on board-versions with an ARMv7 or ARMv8. In some cases you will need to do some additional steps to install a Java version which works on your board.
Board versions With ARMv6 processor Raspberry Pi 1 A and A+ Raspberry Pi 1 B and B+ Compute Module 1 Zero 1.2, 1.3 and W With ARMv7 or ARMv8 processor Model A+, version 3 Model B, version 2, 3 and 4 Compute Module, version 3 How to check and install Java Check the current version If you prepared a microSD card with the latest version of Raspbian OS (full version), Java is already installed!</description></item><item><title>Logging with SLF4J</title><link>https://pi4j.com/documentation/logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/logging/</guid><description>Pi4J uses SLF4J for logging. To include it in your project, add this Maven dependency:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-simple&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.0-alpha0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; There are different ways to configure the logging output, as described on the SLF4J website, but the shortest is probably with this property in your main-method:
public static void main(String[] args) throws Exception { // Configure default logging level, accept a log level as the first program argument System.setProperty(&amp;#34;org.slf4j.simpleLogger.defaultLogLevel&amp;#34;, &amp;#34;INFO&amp;#34;); // Your code comes here }</description></item><item><title>Creating a Pi4J Context</title><link>https://pi4j.com/documentation/create-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/create-context/</guid><description>The context is an immutable runtime object that holds the configured state and manages the lifecycle of a Pi4J instance. It includes all loaded plugins, providers, platforms, I/O instance registry, environmental configuration and runtime objects including executor thread pools, I/O event listeners, etc.
Terminating/destroying the context stops and releases all resources, threads, listeners, and provisioned I/O instances held by the context.
Version 1 was implemented using a static singleton, while version 2 uses a &amp;ldquo;Context&amp;rdquo; to avoid static singletons.</description></item><item><title>Building an I/O Instance</title><link>https://pi4j.com/documentation/build-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/build-io/</guid><description>A GPIO can be configured with Pi4J in different ways, either short for default behavior, a bit longer with additional settings, or with a full custom configuration using a building pattern.
Available I/O Before we can initialize an I/0, the Pi4J context must be initialized. The Pi4J static class includes a few helper context creators for the most common use cases. The newAutoContext() method will automatically load all available Pi4J extensions found in the application&amp;rsquo;s classpath which may include Platforms and I/O Providers.</description></item><item><title>I/O Registry</title><link>https://pi4j.com/documentation/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/registry/</guid><description>An additional V.2 feature is an I/O registry where all I/O instances that have been created can be maintained, managed, re-accessed, etc. As the library keeps track of all the created I/O instances, they become publicly accessible through a registry where users can interrogate, iterate, identify and access all created I/O instances that Pi4J is managing.
This is very useful for add-ons/plugins that want to provide runtime information about the state of all I/O, for example a web app illustrating the current state of I/O.</description></item><item><title>Shutting down the Pi4J Context</title><link>https://pi4j.com/documentation/shutdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/shutdown/</guid><description>At the end of our application, the context needs to be shutdown to release the I/O and clean up the used resources.
# Start of program var pi4j = Pi4J.newAutoContext(); # YOUR CODE GOES HERE # End of program pi4j.shutdown();</description></item></channel></rss>