<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome to Pi4J on Pi4J</title><link>https://pi4j.com/</link><description>Recent content in Welcome to Pi4J on Pi4J</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 25 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://pi4j.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Prepare SD with Pi4J OS</title><link>https://pi4j.com/pi4j-os/prepare-sd-with-pi4j-os/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/pi4j-os/prepare-sd-with-pi4j-os/</guid><description>To prepare an SD-card with one of these flavors, download the latest build from pi4j.com/download and follow the steps described in &amp;ldquo;Set up a new Raspberry Pi, but instead of selecting one of the OS&amp;rsquo;s predefined in the Imager tool, select &amp;ldquo;Choose OS &amp;gt; Use custom&amp;rdquo;, and selected the downloaded file.
Install the Raspberry Pi Imager The official Imager Tool can be downloaded directly from the Raspberry Pi website. This simple tool works on all common operating systems and can be installed very easily with just a few keystrokes.</description></item><item><title>Develop with Intellij IDEA</title><link>https://pi4j.com/examples/crowpi/develop-crowpi-with-intellij/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/crowpi/develop-crowpi-with-intellij/</guid><description>The CrowPi example project contains settings to make it easy to develop on a PC with IntelliJ IDEA and execute the application on the CrowPi. The articles, instructions and pictures are created accordingly. IntelliJ IDEA is from available Jetbrains in different versions. The community version has enough functionality for development with the CrowPi and is available for Windows, MacOS and Linux, but NOT for Raspberry Pi. The download can be found here.</description></item><item><title>Download/Install</title><link>https://pi4j.com/architecture/about-the-code/download-sources/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/download-sources/</guid><description>You can build the project from sources available on GitHub.
Pi4J V.2 Checkout the project pi4j-v2 Select JDK11, e.g. sdk use java 11.0.16.1-zulu In the root of pi4j-v2 run mvn clean install [INFO] Executed tasks [INFO] ------------------------------------------------------------------------ [INFO] Reactor Summary for Pi4J :: Parent POM 2.0-SNAPSHOT: [INFO] [INFO] Pi4J :: Parent POM ................................. SUCCESS [ 0.972 s] [INFO] Pi4J :: DOCKER :: Docker Parent POM .............. SUCCESS [ 0.290 s] [INFO] Pi4J :: TESTING :: Arduino Test Harness .</description></item><item><title>Previous versions (V.1)</title><link>https://pi4j.com/about/previous-version-v1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/previous-version-v1/</guid><description>Documentation of the 1.X versions Pi4J Version 1.4 Released 2021-03-03 Support for JDK/JRE 11 and 64-bit ARM platforms This release is the final release for the Pi4J Version 1.x codebase The Pi4J project is now prioritizing focus on providing Java programs access, control and communication with the core I/O capabilities of the Raspberry Pi platform Changed project to Apache License, Version 2.0 Removed pi4j-device and pi4j-gpio-extension library Removed platform support for Odroid, BananaPi, BPi, NanoPi, OrangePi Various improvements and bug fixes listed here: GitHub Issues (v1.</description></item><item><title>Build Instructions</title><link>https://pi4j.com/architecture/about-the-code/build-instructions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/build-instructions/</guid><description>Building the Pi4J Project is simple and requires minimal effort. Pi4J is primarily built using Apache Maven and Java 11. Pi4J can be built directly on your host computer or inside a Docker container where all toolchains and dependencies are already installed, configuired and cached.
If you wish to build using a Docker container, please skip ahead to the Building with Docker topic.
Prerequsites In order to build Pi4J, the host system must have the following toolchains pre-installed.</description></item><item><title>CrowPi examples</title><link>https://pi4j.com/examples/crowpi/crowpi-examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/crowpi/crowpi-examples/</guid><description> GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-crowpi
The CrowPi example code contains examples for the following components. The links in this table will bring you to the German documentation written by the students who created these examples.
Component Link 7-Segment Display seven-segment Button button Button Matrix button-matrix Buzzer buzzer Infrared Receiver ir-receiver LCD Display lcd-display LED Matrix led-matrix Light sensor light-sensor PIR Motion Sensor pir-motion-sensor Relais relay RFID rfid Step motor step-motor Servomotor servo-motor Sound Sensor sound-sensor Temperature and humidity sensor humi-temp-sens Tilt Sensor tilt-sensor Touch Sensor touch-sensor Ultrasonic distance sensor ultrasonic-sensor Vibration motor vibration-motor</description></item><item><title>Set up a new Raspberry Pi</title><link>https://pi4j.com/getting-started/set-up-a-new-raspberry-pi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/set-up-a-new-raspberry-pi/</guid><description>Introduction The Raspberry Pi is a powerful machine with many use-cases. A lot of this power is based on the operating system you use. For our &amp;ldquo;Getting Started&amp;rdquo; examples we will be using the &amp;ldquo;official Raspberry Pi OS&amp;rdquo; (formerly known as &amp;ldquo;Raspbian OS&amp;rdquo;) but there is a long list of other possibilities which is listed for example on the&amp;ldquo;Awesome Raspberry Pi&amp;rdquo; list on GitHub.
In this article we start with a brand new Raspberry Pi board.</description></item><item><title>Test Pi4J Basic OS</title><link>https://pi4j.com/pi4j-os/test-pi4j-basic-os/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/pi4j-os/test-pi4j-basic-os/</guid><description>The Pi4J Basic OS contains two simple applications in directory java-examples and a sample file to test the audio channel. As Pi4J CrowPi OS and Pi4J Picade OS are based on Pi4J Basic OS, they also contain these tests.
You can start the tests via ssh.
Audio Test cd /home/pi nvlc Music/StarTrekTheme.mp3 Pure JavaFX Application Compile the JavaFX application
cd /home/pi/java-examples/pure-javafx javac --module-path /opt/javafx-sdk/lib --add-modules=javafx.controls,javafx.media hellofx/HelloFX.java To start HelloFX in X11-Mode</description></item><item><title>What's New (V.2)</title><link>https://pi4j.com/about/new-in-v2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/new-in-v2/</guid><description>What&amp;rsquo;s New in 2.0? Pi4J version 2.0 brings with it many new features, and an entirely new architecture that focuses on extensibility, simplified integration and a modern Java API including the following:
Fluent APIs/Interfaces Immutable Runtime Context Extensible Provider/Platform/Plug-in Architecture Builder-patterns for creating new I/O instances Well-documented source code Hardware PWM Support Java 11 Future plans:
Dependency Injection via Pi4J Annotations Remote I/O Support (via TCP/IP) In addition to the features listed above, Pi4J version 2.</description></item><item><title>Understanding the GPIO pins</title><link>https://pi4j.com/getting-started/understanding-the-pins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/understanding-the-pins/</guid><description>Connecting electronic components to the Pi is done via one or more of the pins in the so-called header. The number of pins has &amp;ldquo;grown&amp;rdquo; between the different Raspberry Pi board versions, but all recent ones have a 40-pin header. It&amp;rsquo;s of course important to be aware of the correct numbering to not connect components the wrong way.
Type of pins The pins have different uses
Power and ground Both 5V and 3.</description></item><item><title>Electrical Engineering</title><link>https://pi4j.com/getting-started/electricalengeneering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/electricalengeneering/</guid><description>Resistor dimensioning Resistors can be used for different effects. One application is to improve the stability of the application with PullUp and PullDown resistors. Another application is to use resistors to protect the PI against voltage peaks or short circuit currents.
PullUp PullDown In electronic logic circuits, a pull-up resistor or pull-down resistor is a resistor used to ensure a known state for a signal. It is typically used in combination with components such as switches and transistors, which physically interrupt the connection of subsequent components to ground or to VCC.</description></item><item><title>Java development with VSC</title><link>https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/java-development-on-the-raspberry-pi-with-vsc/</guid><description>Java on the Raspberry Pi To use Pi4J V.2 you&amp;rsquo;ll need Java 11 or newer. Luckily this version is included in the current version of Raspberry Pi OS. In the release notes you can see that the version of 2019-06-20 includes OpenJDK Java 11:
2019-06-20: Based on Debian Buster Oracle Java 7 and 8 replaced with OpenJDK 11 But you will need to keep in mind this version is only compatible with ARMv7 or higher and doesn&amp;rsquo;t support all Raspberry Pi board versions.</description></item><item><title>Maven settings</title><link>https://pi4j.com/architecture/about-the-code/maven-settings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/maven-settings/</guid><description>To simplify development but not commit sensitive information, you can add personal or PC-specific settings in the Maven settings.xml file. This file is stored or needs to be created in the &amp;ldquo;.m2&amp;rdquo; directory in your home directory:
Windows: C:\Users\YOUR_NAME.m2 Linux: /home/YOUR_NAME/.m2 Mac: /Users/YOUR_NAME/.m2 For more info see this article on Baeldung.
This is an example settings file, including settings for compiling of Pi4J and credentials to upload the generated code to a Raspberry Pi.</description></item><item><title>Pin numbering</title><link>https://pi4j.com/documentation/pin-numbering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/pin-numbering/</guid><description>Pi4J V.1 took a pretty opinionated approach to pin numbering as the scheme was based on the underlying WiringPi. This scheme was incompatibility with other pin diagrams and pin numbering used by other development platforms and libraries.
As Pi4J V.2 is build as a &amp;ldquo;pass thru library&amp;rdquo;, and uses PiGpio as the underlying framework, the more well-known BCM numbering is being used now.
This drawing shows the different numbers for WiringPi and BCM in a 40-pins Raspberry Pi header:</description></item><item><title>Release Notes</title><link>https://pi4j.com/about/release-notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/release-notes/</guid><description>All releases of Pi4J V.2 are listed on github.com/Pi4J/pi4j-v2/releases.
2024-07-29 - V2.6.1 This is a minor bug fix release to allow a smoother integration in a Spring Boot Starter by allowing to run on PC for testing without initialization errors and with reduced logging of the I2C Mock plugin.
Issue #354: Gracefully handle UnsatisfiedLinkError on newAutoContext when not running on a Raspberry Pi, for instance, when testing on Windows or macOS.</description></item><item><title>Test Pi4J Picade OS</title><link>https://pi4j.com/pi4j-os/test-pi4j-picade-os/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/pi4j-os/test-pi4j-picade-os/</guid><description>Pi4J Picade OS contains an additional Test and the audio test should use the internal loudspeaker.
Compile the JavaFX application
cd /home/pi/java-examples/pure-picade javac --module-path /opt/javafx-sdk/lib --add-modules=javafx.controls,javafx.media hellopicade/HelloPicade.java To start HelloPicade in X11-Mode
DISPLAY=:0 XAUTHORITY=/home/pi/.Xauthority sudo -E java --module-path /opt/javafx-sdk/lib --add-modules javafx.controls,javafx.media -Dglass.platform=gtk hellopicade.HelloPicade To start HelloPicade in DRM
sudo java-kiosk hellopicade.HelloPicade Check the mapping of the Picade buttons to JavaFX KeyCodes:
Picade KeyCode Joystick up KeyCode.UP Joystick down KeyCode.DOWN Joystick left KeyCode.</description></item><item><title>Developing on a remote PC</title><link>https://pi4j.com/getting-started/developing-on-a-remote-pc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/developing-on-a-remote-pc/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-maven-archetype
Developing Java programs using a remote PC workstation Writing your Java program, compiling and running it directly on the Raspberry Pi board as shown in the previous chapter is perfectly fine, of course, but there is an alternative way to arrange your developing laboratory, using a normal desktop computer as Remote Developing Workstation (RDW).
This Maven Archetype will give you a tool to generate Pi4J V.2 skeleton Java projects.</description></item><item><title>Pi4J Downloads</title><link>https://pi4j.com/about/download/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/download/</guid><description>All downloads provided by the project can be found on pi4j.com/download.
The compiled artifacts (releases and snapshots) are available in the Sonatype Maven repository.</description></item><item><title>Minimal Kotlin Pi4J example</title><link>https://pi4j.com/kotlin/minimal-kotlin-example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/minimal-kotlin-example/</guid><description>Full Example on GitHub: https://github.com/Pi4J/pi4j-kotlin/blob/master/example/src/main/kotlin/MinimalExample.kt
For full documentation, visit the Kotlin Docs
This is a minimal working example, make sure to check it out from the link above for the full introduction and comments.
It does exactly the same functionality of the Minimal Example using the Java API:
The application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.</description></item><item><title>Kotlin API &amp; DSL Documentation</title><link>https://pi4j.com/kotlin/kotlin-api-docs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/kotlin-api-docs/</guid><description>Here you can find the provided APIs and the dead-simple DSLs of the Kotlin package.
Components Context To create a new Pi4J context, use the pi4j function. It creates a new auto Context object and uses it as a receiver for your lambda:
pi4j { // You have access to a newly created auto context describe() } You don&amp;rsquo;t need to call shutdown(), it&amp;rsquo;s called automatically at the end of the block.</description></item><item><title>Coroutines Support</title><link>https://pi4j.com/kotlin/coroutines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/coroutines/</guid><description>pi4jAsync Same with the pi4j DSL, you can create a pi4j block to execute within a CoroutineScope using the pi4jAsync DSL.
pi4jAsync { delay(100) // suspended call describe() } Inside pi4jAsync you have access to a newly created auto context and you can run your code in the provided CoroutineScope.
Custom CoroutineScope You can also use a custom CoroutineScope instance.
pi4jAsync(CoroutineScope(Dispatchers.Default)) { delay(100) // suspended call describe() } Minimal Example with Coroutines This is a the same as the minimal example, but leveraging Kotlin&amp;rsquo;s Coroutines</description></item><item><title>I²C Kotlin DSL</title><link>https://pi4j.com/kotlin/i2c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/i2c/</guid><description>Feel free to checkout the Pi4J docs on I²C
Installation Add LinuxFs dependency
dependencies { implementation(&amp;#34;com.pi4j:pi4j-plugin-linuxfs:2.3.0&amp;#34;) } I²C DSL i2c(1, 0x3f) { id(&amp;#34;TCA9534&amp;#34;) linuxFsI2CProvider() }.use { tca9534Dev -&amp;gt; // use here. Will auto close } Writing i2c(1, 0x3f) { id(&amp;#34;TCA9534&amp;#34;) linuxFsI2CProvider() }.use { tca9534Dev -&amp;gt; val newState = tca9534Dev.setPin(currentState, pin = 8, TCA9534_REG_ADDR_OUT_PORT) } Minimal I²C Example This is the Kotlin DSL version of the same I²C example here, but leveraging the Kotlin DSL</description></item><item><title>Code styling</title><link>https://pi4j.com/architecture/about-the-code/code-styling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/code-styling/</guid><description>To prevent unnecessary code (tabs versus spaces, number of characters per line&amp;hellip;) we have defined an editorconfig for IntelliJ IDEA. You can find more info here about its use.
Some tips to keep the code clean and readable:
Short methods with a clear name Use SonarLint to get improvement tips while code Use shortcuts CTRL+ALT+L: Reformat code CTRL+ALT+O: Optimize imports</description></item><item><title>Hardware testing</title><link>https://pi4j.com/architecture/about-the-code/hardware-testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/about-the-code/hardware-testing/</guid><description>This is an experimental project which will need a lot of love&amp;hellip; The new Raspberry Pi Pico with a lot of GPIOs for a very low price, seems even to be a better fit for this project compared to the Arduino Due&amp;hellip; To be further investigated!
To minimize the required time and efforts to test a new release, V.2 aims to include an automated test which performs I/O testing on each I/O interface on each model of RPi.</description></item><item><title>Java for ARMv6/7/8</title><link>https://pi4j.com/documentation/java-installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/java-installation/</guid><description>Raspberry Pi OS Full comes with Java 11 pre-installed. But this version only works on board-versions with an ARMv7 or ARMv8. In some cases you will need to do some additional steps to install a Java version which works on your board.
Board versions With ARMv6 processor Raspberry Pi 1 A and A+ Raspberry Pi 1 B and B+ Compute Module 1 Zero 1.2, 1.3 and W With ARMv7 or ARMv8 processor Model A+, version 3 Model B, version 2, 3 and 4 Compute Module, version 3 How to check and install Java Check the current version If you prepared a microSD card with the latest version of Raspbian OS (full version), Java is already installed!</description></item><item><title>License (Open Source)</title><link>https://pi4j.com/about/license/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/license/</guid><description>The Pi4J Version 2.0 project is distributed and licensed under the Apache License, Version 2.0 license (A business-friendly OSS license).
apache.org/licenses/LICENSE-2.0 github.com/Pi4J/pi4j-v2/blob/master/LICENSE.txt Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
Definitions.
&amp;ldquo;License&amp;rdquo; shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document.
&amp;ldquo;Licensor&amp;rdquo; shall mean the copyright owner or entity authorized by the copyright owner that is granting the License.</description></item><item><title>Minimal example application</title><link>https://pi4j.com/getting-started/minimal-example-application/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/minimal-example-application/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal
In the &amp;ldquo;pi4j-example-minimal&amp;rdquo; GitHub project you can find a project which contains the minimal code to control a digital input and output with Pi4J. The project is further described on this page. The application will toggle an LED on/off and each time you press the button, the toggling speed increases. When you have pushed the button 5 times, the application stops.
Wiring This minimal example application uses this wiring:</description></item><item><title>Minimal example as FAT JAR</title><link>https://pi4j.com/getting-started/minimal-example-application-fatjar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/minimal-example-application-fatjar/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fatjar
The &amp;ldquo;Minimal example application&amp;rdquo; uses one LED and button to demonstrate the basic use of Pi4J V.2. When building that project with Maven, all the required Java modules are copied to the target/distribution directory. But a lot of developers like to produce a single, executable JAR that contains all dependencies, also known as a &amp;ldquo;FAT JAR&amp;rdquo;.
The repository &amp;ldquo;pi4j-example-fatjar&amp;rdquo; GitHub project contains a Maven project with identical wiring, dependencies and build command to the &amp;ldquo;Minimal example application&amp;rdquo;, but results in such a FAT JAR instead of separate Java modules.</description></item><item><title>Serial Kotlin DSL</title><link>https://pi4j.com/kotlin/serial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/kotlin/serial/</guid><description>Feel free to checkout the Pi4J docs on Serial
Installation Add PiGPIO dependency
dependencies { implementation(&amp;#34;com.pi4j:pi4j-plugin-pigpio:2.3.0&amp;#34;) } Serial DSL serial(&amp;#34;/dev/ttyS0&amp;#34;) { use_9600_N81() dataBits_8() parity(Parity.NONE) stopBits(StopBits._1) flowControl(FlowControl.NONE) piGpioSerialProvider() }.open { // use here. } Minimal Serial Example This is the Kotlin DSL version of the same Serial example here, but leveraging the Kotlin DSL
serial(&amp;#34;/dev/ttyS0&amp;#34;) { // .. }.open { console { +&amp;#34;Waiting till serial port is open&amp;#34; while (!isOpen) { print(&amp;#34;.</description></item><item><title>Binary Clock</title><link>https://pi4j.com/featured-projects/binary-clock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/featured-projects/binary-clock/</guid><description>GITHUB PROJECT: github.com/taartspi/pi4j-binary-clock
This project by Tom Aarts (published on May 15, 2024), is a binary clock created with LEDs on a breadboard. In the video below you see it incrementing to the next minute and hour. What you see is the Hour Minute and Second displayed in BCD (Binary Coded Decimal):
Design document describing the LED PCF8575 connections, and the Java implementation that drives the clock LEDs. Note: there are two PCF8575 IC used in this design.</description></item><item><title>Soft real time PLC</title><link>https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/</guid><description>Strolch is a framework for developing Software which has a different approach compared to Spring and other similar types of Java frameworks, as the model is defined as an abstract model, where you always have the same three types of objects: Resources, Orders and Activities. The fields are mapped as Parameter objects, of which the important primitives are available.
Conveyors for containers filled by a dispensing robot
eSyBox using pi4j to communicate with the Raspberry Pi&amp;#39;s I2C bus</description></item><item><title>Logging with SLF4J</title><link>https://pi4j.com/documentation/logging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/logging/</guid><description>Pi4J uses SLF4J for logging. To include it in your project, add this Maven dependency:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;slf4j-simple&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.0-alpha0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; There are different ways to configure the logging output, as described on the SLF4J website, but the shortest is probably with this property in your main-method:
public static void main(String[] args) throws Exception { // Configure default logging level, accept a log level as the first program argument System.setProperty(&amp;#34;org.slf4j.simpleLogger.defaultLogLevel&amp;#34;, &amp;#34;INFO&amp;#34;); // Your code comes here }</description></item><item><title>PiJukeBox</title><link>https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/featured-projects/pijukebox-by-daniel-martensson/</guid><description>Daniel Mårtensson used Java and Pi4J to turn an old Centrum U68 from 1940 into a MP3 player. The reason is because short wave, middle wave and long wave is today obsolete and not being used or sended today in Sweden. Also the electronics inside was a mess and very dangerous because it runs on both AC/DC current and all the wires began to lose their isolators.
Features: autoplaying next song, 60 songs included, volume tuning, song select, low power consumption, works with old Raspberry Pi&amp;rsquo;s, terminal based.</description></item><item><title>The Team</title><link>https://pi4j.com/about/team/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/about/team/</guid><description>Robert Savage, Project Founder, Architect, Lead Developer.
Principal Software Architect/Engineer. Consultant, technology enthusiast, entrepreneur, open source contributor, technology blogger. Founder at shadeBlue, LLC and SavageSoftware, LLC. Robert has a more than 20 year career working in the professional audio visual and home/commercial automation industry and an extensive background in developing technology solutions with a special focus on home automation and hardware/firmware/software integration. In 2012, Robert created the Pi4J project which provides Java developers an easy to use Java library enabling access to low-level I/O functionality (GPIO, I2C, SPI, Serial, etc.</description></item><item><title>CocktailPi</title><link>https://pi4j.com/featured-projects/cocktail-maker-by-alex9849/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/featured-projects/cocktail-maker-by-alex9849/</guid><description>The CocktailPi is a cocktail mixing machine by Alexander Liggesmeyer. It can control as many pumps as the RaspberryPi provides GPIO pins. For every pump that gets added to the system, the user has to provide the amount of time that that pump needs to pump one centiliter in milliseconds. The machine uses peristaltic pumps. So that number is perfectly accurate. The flow rate won&amp;rsquo;t vary over time. It uses a relay board for closing the electronic circuit for all pumps.</description></item><item><title>Creating a Pi4J Context</title><link>https://pi4j.com/documentation/create-context/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/create-context/</guid><description>The context is an immutable runtime object that holds the configured state and manages the lifecycle of a Pi4J instance. It includes all loaded plugins, providers, platforms, I/O instance registry, environmental configuration and runtime objects including executor thread pools, I/O event listeners, etc.
Terminating/destroying the context stops and releases all resources, threads, listeners, and provisioned I/O instances held by the context.
Version 1 was implemented using a static singleton, while version 2 uses a &amp;ldquo;Context&amp;rdquo; to avoid static singletons.</description></item><item><title>Didier the street artist robot</title><link>https://pi4j.com/featured-projects/street-artist-robot/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/featured-projects/street-artist-robot/</guid><description>Meet &amp;ldquo;Didier&amp;rdquo; the street artist robot, a project by Duvam. The sources are shared on github.com/duvamduvam/didier-java.</description></item><item><title>User interface with JavaFX</title><link>https://pi4j.com/getting-started/user-interface-with-javafx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/user-interface-with-javafx/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-javafx
JavaFX is a framework to create user interfaces for desktop (Windows, Mac, Linux) and mobile phones. JavaFX is an opensource project which is documented on openjfx.io and the sources are available in this GitHub project.
The main goal of Java has always been to be able to create applications which are &amp;ldquo;write once, run everywhere&amp;rdquo;. JavaFX promises the same for Graphical User Interface applications.
Gluon is the main maintainer of the OpenJFX project and offers commercial support to companies who want to use JavaFX in critical applications.</description></item><item><title>JMonkeyEngine with Joystick</title><link>https://pi4j.com/featured-projects/joystick-game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/featured-projects/joystick-game/</guid><description>Pavl G. created a Java Gradle library to control a car in a JMonkeyEngine game with an arduino joystick module connected to a Raspberry Pi4 model B, using GPIO digital pins and SPI interfacing through MCP3008 ADC (Analog~Digital Converter).
Requirements Raspberry Pi with arm processor (pi3, pi4, piZero) with a working java8 (preferred). Female-to-male jumper wires. Breadboard. Arduino Joystick module. MCP3008 IC (ADC &amp;ndash; other adcs may work too, but we are covering only MCP3008 here).</description></item><item><title>Sensor drivers</title><link>https://pi4j.com/featured-projects/sensor-drivers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/featured-projects/sensor-drivers/</guid><description>In case you want to read the data from various I2C sensors connected to Raspberry Pi the difficult part is usually writing a piece of code which talks to the I2C sensor.
rpi-drivers is a Java library implementing simple APIs and communication code for some widely used I2C sensors. You can easily measure temperature, pressure and humidity, get ambient light intensity or measure voltage in your java Raspberry Pi projects.</description></item><item><title>FXGl to Picade</title><link>https://pi4j.com/getting-started/fxgl/fxgl-to-picade/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/fxgl/fxgl-to-picade/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-fxgl
In this section we demonstrate how to convert existing FXGL projects to work on a RaspberryPi
If you don&amp;rsquo;t have an existing FXGL project, go grab one from FXGLGames
Steps to get your app running on a RaspberryPi Add Maven support to your project In our project we use Maven to manage dependencies and build the application, other build tools such as gradle are also viable but not covered in this tutorial.</description></item><item><title>JavaFX kiosk mode</title><link>https://pi4j.com/getting-started/fxgl/kiosk-mode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/fxgl/kiosk-mode/</guid><description>Visit webtechie.be for the full blogpost
Kiosk Mode With Gluon&amp;rsquo;s JavaFX 17-ea, we are able to run applications in different modes: Desktop and Kiosk mode. In this post we focus on the Kiosk mode only.
With this approach, the application is the only thing you see on the screen. This prevents the user to open any other applications, or mess up your system. In this case, there is no need for a window manager, and the application directly uses the underlying (hardware) framebuffer.</description></item><item><title>JavaFX GUI and MVC template</title><link>https://pi4j.com/getting-started/javafx-mvc-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/javafx-mvc-template/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-template-javafx
The FHNW University created a template project which is now part of the Pi4J example repositories.
The goal of this project is to:
Provide a clear step-by-step how to prepare your Raspberry Pi Provide multiple test and start applications Explain the use of a MVC-model (Model-View-Controller) to clearly split data, actions and user interface Explain the use of JUnit test Sources and info Please check the README of the sources of the project for a full description of the setup process of the Raspberry Pi and to fully understand the example applications and the MVC-model.</description></item><item><title>GpioD Provider</title><link>https://pi4j.com/documentation/providers/gpiod/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/providers/gpiod/</guid><description>The GpioD plugin provider was added in Pi4J 2.5.0 to be able to support the Raspberry Pi 5 with the new GPIO chip RP1.
Providers in the GpioD plugin:
gpiod-digital-input gpiod-digital-output The GpioD provider requires minimum kernel Bullseye 6.1.21 and Bookworm 6.6.22 !
If you get an error at startup with the following content, your OS is outdated for the GpioD implementation used in Pi4J:
UNDERLYING EXCEPTION: [java.lang.UnsatisfiedLinkError]=/tmp/libgpiod368899536808039438.so: /lib/aarch64-linux-gnu/libc.so.6: version `GLIBC_2.</description></item><item><title>LinuxFS Provider</title><link>https://pi4j.com/documentation/providers/linuxfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/providers/linuxfs/</guid><description>The current implementation of the LinuxFS plugin implements a file based I2C and PWM provider. The file based I2C provider opens /dev/i2c-1 using a RandomAccessFile to perform I2C reads and writes. The file based PWM provider opens /sys/class/pwm/pwmchip? using a RandomAccessFile to perform PWM operations.
The Linuxfs provider linuxfs-pwm requires minimum kernel Bullseye 6.1.21 and Bookworm 6.6.22 !
Providers in the LinuxFS plugin:
linuxfs-i2c linuxfs-pwm Under construction linuxfs-digital-input linuxfs-digital-output To use the LinuxFS provider include the following dependencies:</description></item><item><title>PiGpio Provider</title><link>https://pi4j.com/documentation/providers/pigpio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/providers/pigpio/</guid><description>The current implementation of the PiGpio exposes the GPIO functions available on the Raspberry Pi (see Note Pi5 below). This implementation is developed/supported by a team separate of Pi4j. Pi4j is a consumer of that PiGpio work.
Pi5 At the present time the PiGpio implementation does not support the new Pi5 board. - This new Pi5 RP1 chip will require a large development effort. There is no known plan for this develoment.</description></item><item><title>Using Board Info</title><link>https://pi4j.com/documentation/board-info/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/board-info/</guid><description>GITHUB Sources of BoardInfoHelper.java and the data model: pi4j-v2/pi4j-core/src/main/java/com/pi4j/boardinfo/util/BoardInfoHelper.java
V2.6.0 provides a new class BoardInfoHelper that can provide the following info:
Type of Raspberry Pi board as a BoardInfo object. If the system uses a RP1 chip with usesRP1() (Raspberry Pi 5 only at this moment). If the system is 32-bit or 64-bit with is32bit() and is64bit(). The amount of memory available and used by the JVM as a JvmMemory object.</description></item><item><title>Building an I/O Instance</title><link>https://pi4j.com/documentation/build-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/build-io/</guid><description>A GPIO can be configured with Pi4J in different ways, either short for default behavior, a bit longer with additional settings, or with a full custom configuration using a building pattern.
I/O Initialization Examples Before we can initialize an I/0, the Pi4J context must be initialized. The Pi4J static class includes a few helper context creators for the most common use cases. The newAutoContext() method will automatically load all available Pi4J extensions found in the application&amp;rsquo;s classpath which may include Platforms and I/O Providers.</description></item><item><title>Learn more...</title><link>https://pi4j.com/getting-started/learn-more/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/getting-started/learn-more/</guid><description>Pi4J is used in a lot of projects, and you can find a lot of examples online. On this page we want to keep an up-to-date list. Do you want to add something? Please hit &amp;ldquo;Edit this page&amp;rdquo; on the top and create a pull request!
Twitter Please share your personal or professional projects where you combine Java and the Raspberry Pi on Twitter with the hashtag #JavaOnRaspberryPi.
Online articles Foojay.</description></item><item><title>Prototype Board</title><link>https://pi4j.com/examples/communityimplementation/prototype-board/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/communityimplementation/prototype-board/</guid><description>A Versatile Prototype Board Experimenting with various ICs &amp;lsquo;chips&amp;rsquo; may require different methods to connect the chip to the Pi. As shown in the BMP280 usage a chip maybe available mounted on a small circuit board where connection to the Pi requires only jumpers. But even this simple means has limits as connecting several chips when using a Pi case and maybe a cooling fan creates problems. In addition some chips are only available as a socket device where a 4-28 pin socket is required.</description></item><item><title>BMP280 Sensor</title><link>https://pi4j.com/examples/communityimplementation/bmp280/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/communityimplementation/bmp280/</guid><description>Description The BMP280 is a Pressure and temperature sensor accessed via I2C or SPI. The BMP280 is a simple device that requires the connection of few wires to operate. Because of this simplicity the device can serve as a very easy project for initial Pi and Pi4j usage. This document will explain the more simple means to connect the sensor and access the device with existing software requiring no coding. The document will also explain minimal coding required to allow greater flexibility.</description></item><item><title>I/O Registry</title><link>https://pi4j.com/documentation/registry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/registry/</guid><description>An additional V.2 feature is an I/O registry where all I/O instances that have been created can be maintained, managed, re-accessed, etc. As the library keeps track of all the created I/O instances, they become publicly accessible through a registry where users can interrogate, iterate, identify and access all created I/O instances that Pi4J is managing.
This is very useful for add-ons/plugins that want to provide runtime information about the state of all I/O, for example a web app illustrating the current state of I/O.</description></item><item><title>Shutting down the Pi4J Context</title><link>https://pi4j.com/documentation/shutdown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/shutdown/</guid><description>At the end of our application, the context needs to be shutdown to release the I/O and clean up the used resources.
# Start of program var pi4j = Pi4J.newAutoContext(); # YOUR CODE GOES HERE # End of program pi4j.shutdown();</description></item><item><title>Minimal Example</title><link>https://pi4j.com/examples/jbang/jbang_minimal_example/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/jbang/jbang_minimal_example/</guid><description>Minimal Pi4J with JBang example GITHUB PROJECT: github.com/Pi4J/pi4j-jbang &amp;gt; Pi4JMinimalExample.java
Intro Before proceeding with this example, make sure that you have a Raspberry Pi prepared to execute Java code with JBang as explained here.
The following example is based on the &amp;ldquo;Minimal example application&amp;rdquo;, and uses the same wiring with a button and LED. By using JBang we can run this project with a single file without the need of a full Maven or Gradle project, or compiling the Java code.</description></item><item><title>8x8 LED Matrix</title><link>https://pi4j.com/examples/jbang/jbang_pi4j_spi_led_matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/jbang/jbang_pi4j_spi_led_matrix/</guid><description>Controlling a 8x8 LED Matrix with MAX7219 via SPI GITHUB PROJECT: github.com/Pi4J/pi4j-jbang &amp;gt; Pi4JLedMatrixSpi.java
This example is explained in the following video:
Intro Before proceeding with this example, make sure that you have a Raspberry Pi prepared to execute Java code with JBang as explained here.
Wiring SPI requires four connections, but as we don&amp;rsquo;t read data back, we only connect three of them plus power and ground.
BCM 10 (MOSI) to DIN BCM 11 (SCLK) to CLK BCM 8 (CE0) to CS 5V to VCC Ground to ground Wiring between Raspberry Pi and matrix</description></item><item><title>BME280 Sensor</title><link>https://pi4j.com/examples/jbang/bme280_temperature_humidity_pressure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/jbang/bme280_temperature_humidity_pressure/</guid><description>BME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang GITHUB PROJECT: github.com/Pi4J/pi4j-jbang &amp;gt; Pi4JTempHumPressI2C.java and github.com/Pi4J/pi4j-jbang &amp;gt; Pi4JTempHumPressSpi.java
Intro This is an example project to demonstrate how to read the temperature, humidity and pressure from a BME280 sensor, installed on an Adafruit board that can be controlled via I2C and SPI. Such a sensor itself is a very tiny component that can be integrated in phones and many other types of devices.</description></item><item><title>Building with javac</title><link>https://pi4j.com/documentation/building/javac/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/building/javac/</guid><description>You can build a Pi4J project using only java and javac.
Wiring No wiring is needed for this minimal example as it only demonstrates how to create a minimal application which initializes Pi4J.
Java release Any Java release over 11 is enough, check it with this command:
$ java -version java 17.0.1 2021-10-19 LTS Java(TM) SE Runtime Environment (build 17.0.1+12-LTS-39) Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-LTS-39, mixed mode, sharing) PI4J jar files You will need to download the Pi4J distribution from the Maven repository:</description></item><item><title>Build as a FAT JAR with Maven</title><link>https://pi4j.com/documentation/building/fat-jar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/building/fat-jar/</guid><description>EXAMPLE PROJECT: https://github.com/Pi4J/pi4j-example-fatjar
About FAT JARs With Pi4J V1 you can create a so-called FAT JAR, which packages all the dependencies into one jar-file. That way it is very easy to build your project on one computer and distribute your application as a single file to one or more clients.
Because of the modular approach and how Pi4J V.2 loads it dependencies at runtime, this approach can be achieved by using the maven-shade-plugin.</description></item><item><title>Build Java modules with Maven</title><link>https://pi4j.com/documentation/building/modules-maven/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/building/modules-maven/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal
Because the Pi4J V.2 project follows the modular approach of Java, the functionality of the framework has been split into different modules, each with their own responsibility.
The easiest way to start a new project, is to copy one of the example projects which include a full Maven pom.xml-file with all the required steps and configurations to build the project with all its modules into the target/distribution directory.</description></item><item><title>Build Java modules with Gradle</title><link>https://pi4j.com/documentation/building/modules-gradle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/building/modules-gradle/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-minimal
The Pi4J V.2 project itself uses Maven and most example projects also use this build tool. But if you prefer to use Gradle, you can start with a copy of the &amp;ldquo;Minimal example application&amp;rdquo; which includes all the required files to build with Gradle.
Use Gradle version 6.6 (or later) and Java 11 OpenJDK (or later). The Gradle wrapper is used as described on docs.gradle.org. The Gradle configuration file build.</description></item><item><title>Running Pi4J with JBang</title><link>https://pi4j.com/documentation/building/jbang/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/building/jbang/</guid><description>JBang allows you to execute Java code with dependencies as a single file without the need for a full Maven or Gradle project. You also don&amp;rsquo;t need to compile your code. So it&amp;rsquo;s a very easy way to get started with Java and Pi4J.
Multiple examples and more information is available in the section &amp;ldquo;Example Implementations &amp;gt; JBang Examples&amp;rdquo;.</description></item><item><title>Pixelblaze Output Expander</title><link>https://pi4j.com/examples/jbang/pixelblaze_output_expander/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/jbang/pixelblaze_output_expander/</guid><description>GITHUB PROJECT: github.com/Pi4J/pi4j-jbang &amp;gt; PixelblazeOutputExpander.java
One of the most &amp;ldquo;fancy&amp;rdquo; electronic components is definitely a LED strip. It&amp;rsquo;s really cool to control a long strip of lights with only a few lines of code&amp;hellip; But, there is a problem. The timing of the signals is crucial to reliably control these strips. Both Python and Java on a Raspberry Pi can struggle with these timings as they are running on Linux, a non-real-time operating system.</description></item><item><title>Controlling a LED Matrix</title><link>https://pi4j.com/examples/jbang/pixelblaze_output_expander_image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/jbang/pixelblaze_output_expander_image/</guid><description>GITHUB PROJECT: github.com/Pi4J/pi4j-jbang &amp;gt; PixelblazeOutputExpanderImageMatrix8x32.java
A LED strip doesn&amp;rsquo;t only exist as a single strip, the same system is also used in a LED matrix. In this example, we will control such a 8*32 LED matrix.
Full LED strip code walkthrough, and additional info in this live session with Robert (aka Eitch) and Frank:
Intro This example is based on the Pixelblaze Output Expander (PBOE) JBang example. Make sure to check out the PBOE example, so you fully understand how to set up and use JBang, and connect and control a LED strip via a PBOE.</description></item><item><title>LED strip with a JavaFX UI</title><link>https://pi4j.com/examples/jbang/pixelblaze_output_expander_javafx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/jbang/pixelblaze_output_expander_javafx/</guid><description>GITHUB PROJECT: github.com/Pi4J/pi4j-jbang &amp;gt; PixelblazeOutputExpanderJavaFX.java
We already know how to control a LED strip, so let&amp;rsquo;s add a JavaFX User Interface to control the colors on each of the LEDs on the strip.
Demo of the JavaFX UI
Full LED strip code walkthrough, and additional info in this live session with Robert (aka Eitch) and Frank:
Intro This example is based on the Pixelblaze Output Expander (PBOE) JBang example. Make sure to check out the PBOE example, so you fully understand how to set up and use JBang, and connect and control a LED strip via a PBOE.</description></item><item><title>Digital Output (GPIO)</title><link>https://pi4j.com/documentation/io-examples/digital-output/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/digital-output/</guid><description>A digital output translates a false/true (or 0/1) to an output value of 0V or 3.3V. This means you can control any type of device which works with max 3.3V to off or on. The most basic example is a LED. Always check which is the correct input voltage for your device! For a LED you will need to put a resistor with the correct value between the GPIO and the LED, you can find a lot of examples and calculators online, for example on circuitdigest.</description></item><item><title>Simple Button</title><link>https://pi4j.com/examples/components/simplebutton/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/simplebutton/</guid><description>Description The SimpleButton is a template class, that you can use in your own Java-project.
The Template Class gives you the option to check the state of the button, and to create simple events if the button is pressed, depressed or while it is being pressed.
Layout Simple Button Breadboard
Big Button
Code A simple example on how to use the Button-Class from the Hardware-Catalog:
// Initialize the button component final var button = new SimpleButton(pi4j, PIN.</description></item><item><title>Simple LED</title><link>https://pi4j.com/examples/components/simpleled/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/simpleled/</guid><description>Description The SimpleLed is a template class, that you can use in your own Java-project.
The template Class gives you the option to switch off, switch on or toggle the state of the LED.
Layout Simple Led Breadboard
Code A simple example on how to use the LED-Class from the Hardware-Catalog:
System.out.println(&amp;#34;Simple LED demo started ...&amp;#34;); // Create a new SimpleLED component SimpleLed led = new SimpleLed(pi4j, PIN.D26); // Turn on the LED to have a defined state System.</description></item><item><title>AD Converter ADS1115</title><link>https://pi4j.com/examples/components/ads1115/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/ads1115/</guid><description>Description The Analog Digital Converter Ads1115 is a template class, that you can use in your own Java-project. The ADS1115 device is a precision, low-power, 16-bit, I2C-compatible, analog-to-digital converter (ADCs). The ADS1115 device incorporates a low-drift voltage reference and an oscillator as well as a programmable gain amplifier (PGA) and a digital comparator. These features, along with a wide operating supply range, makes the ADS1115 well suited for power- and space-constrained, sensor measurement applications.</description></item><item><title>Buzzer</title><link>https://pi4j.com/examples/components/buzzer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/buzzer/</guid><description>Description The Buzzer is a template class, that you can use in your own Java-project.
The Template Class gives you the option to play a note, and to create your own little melodies to play. The buzzer is controlled via a PWM output. The dutycycle is fixed at 50% and with the frequency the desired sound can be reproduced.
Layout Buzzer Acitve Breadboard
Buzzer Active
Code A simple example on how to use the Buzzer-Class from the Hardware-Catalog:</description></item><item><title>Camera</title><link>https://pi4j.com/examples/components/camera/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/camera/</guid><description>Description The Camera is a template class, that you can use in your own Java-project. Currently, the code is only tested with a Raspberry-Camera and the crowpi-image. You can take pictures or videos, with or without a preview.
To connect the camera, use this video. The video is mentioned on the official website. The camera class is using the bash-commands &amp;ldquo;libcamera-hello&amp;rdquo;, &amp;ldquo;libcamera-still&amp;rdquo; and &amp;ldquo;libcamera-vid&amp;rdquo;. To use them, set up the raspberry with the following Introduction</description></item><item><title>Digital Input (GPIO)</title><link>https://pi4j.com/documentation/io-examples/digital-input/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/digital-input/</guid><description>Similar to a digital output pin, a digital input translates an input value of 0V or 3.3V to the value false/true. This means any type of device which can toggle between 3.3V and 0V, can generate an input value to the Raspberry Pi. Here the most basic example is a toggle button. If you use other components, always check which is the voltage provided by the device. Or if you use a power pin from the Raspberry Pi itself, to use a 3.</description></item><item><title>Joystick</title><link>https://pi4j.com/examples/components/joystick/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/joystick/</guid><description>Description The Joystick is a template class, that you can use in your own Java-project. The template is created for a digital joystick with 4 directions (up, right, down, left) and as an option additionally with a push button in direction down. A suitable hardware component is the arcade joystick in the picture bellow. But any joystick with switching contacts will meet the requirements.
The template class allows to query the individual joystick positions and can trigger a simple event when the joystick swings out in a direction or when it returns to the center position.</description></item><item><title>Joystick Analog</title><link>https://pi4j.com/examples/components/joystickanalog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/joystickanalog/</guid><description>Description The JoystickAnalog is a template class, that you can use in your own Java-project. The template class is created for an analog joystick, for example the KY-023, which consists of two potentiometers, one for the X-axis and one for the Y-axis. But any joystick with two potentiometers will meet the requirements.
The basic functions of the template class are:
return of a normalized value, optionally between 0 and 1 or between -1 and 1, of the X-axis and the Y-axis creation of simple events at a value change of the X-axis or the Y-axis, simple event handlers for button pressed, button depressed, while button is pressed calibration of the center position of the joystick (center position 0.</description></item><item><title>LCD Display</title><link>https://pi4j.com/examples/components/lcddisplay/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/lcddisplay/</guid><description>Description The LcdDisplay is a template class, that you can use in your own Java-project. It is used to show Numbers, Text and Symbols on a small Display. The Class supports only LCD Displays with the PCF8574T I2C Backpack. Supported display-dimensions are 40x2, 20x4, 20x2, 16x2, 16x1.
IF YOU CAN&amp;rsquo;T SEE ANYTHING WRITTEN ON THE DISPLAY, TRY TO SET THE CONTRAST BY TURNING THE CONTRAST-SCREW AT THE BACK WITH A SCREWDRIVER.</description></item><item><title>LED Button</title><link>https://pi4j.com/examples/components/ledbutton/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/ledbutton/</guid><description>Description The LedButton is a template class, that you can use in your own Java-project. You can take any Button with a LED you want to. Like for example the big button bellow in the picture gallery.
The Template Class gives you the option to check the state of the button, and to create simple events if the button is pressed or depressed, or the whole time is is being pressed.</description></item><item><title>LED Matrix</title><link>https://pi4j.com/examples/components/ledmatrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/ledmatrix/</guid><description>Although this example is still valid, an easier approach for the control of an array of LEDs can be achieved with the PixelBlaze Output Expander as described here.
Description The LedMatrix is a template class, that you can use in your own Java-project. It is an extension of the class LEDStrip. An LED matrix can be built from one LED strip. To do this, separate the LED strip at the desired point and place the individual strips under each other or next to each other.</description></item><item><title>LED Strip</title><link>https://pi4j.com/examples/components/ledstrip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/ledstrip/</guid><description>Although this example is still valid, an easier approach for the control of an array of LEDs can be achieved with the PixelBlaze Output Expander as described here.
Description The LedStrip is a template class, that you can use in your own Java-project. You can take a LED Strip with the WS28xx-chip set.
The Template Class gives you the option to set the LED&amp;rsquo;s of the strip to a desired RGB-Color.</description></item><item><title>Potentiometer</title><link>https://pi4j.com/examples/components/potentiometer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/potentiometer/</guid><description>Description The Potentiometer is a template class, that you can use in your own Java-project. The constructor of the class requires an ADS1115 object. In addition, the channel, with which the AD converter evaluates the current position of the sliding contact must be defined. For normalization, the maximum voltage that can drop across the sliding contact must also be specified. Any commercially available potentiometer with three connections (fixed resistor and the slider) can be evaluated with this class.</description></item><item><title>ServoMotor</title><link>https://pi4j.com/examples/components/servo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/examples/components/servo/</guid><description>Description The ServoMotor is a template class, that you can use in your own Java-project. You can set the servo to a specific location, likewise to 110 degrees of it&amp;rsquo;s range.
You can use a wide variety of analog servo motors such as the SG92R or the SG-5010 (for a little more torque).
Layout Servo Breadboard
Servo SG-5010 Top View
Servo SG-5010 Side View
Servo SG92R Side View
Mini Power Supply Module</description></item><item><title>Pulse Width Modulation (PWM)</title><link>https://pi4j.com/documentation/io-examples/pwm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/pwm/</guid><description>What is it? The abbreviation PWM stands for &amp;ldquo;Pulse Width Modulation&amp;rdquo; and is also often referred to in German as pulse width modulation or pulse duration modulation. This technology is used, among other things, to control servomotors and is also used, for example, for the fans of a regular computer.
With PWM, it is possible to control a component such as a motor no longer purely binary, i.e. off (0% power) or on (100% power), but to control them almost at will.</description></item><item><title>I²C Clock Stretching</title><link>https://pi4j.com/documentation/io-examples/i2c/clock-stretching/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/i2c/clock-stretching/</guid><description>Clock Stretching Please be aware there are some hardware issues when using the Raspberry Pi with devices that expect to be able to use clock stretching, for more info see &amp;ldquo;Adventures in I2C: clock stretching on the Raspberry Pi&amp;rdquo; and &amp;ldquo;I2C stretch bug. Been fixed or not?&amp;rdquo;.
Clock stretching in I2C allows a slave device to halt the master before a more data is sent. This is often the case when the slave device writes to an EEPROM etc.</description></item><item><title>Serial Peripheral Interface (SPI)</title><link>https://pi4j.com/documentation/io-examples/spi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/spi/</guid><description>What is it? The Serial Peripheral Interface, abbreviated to SPI, is a bus system which enables communication between a main device (called “master”) and one or more secondary devices (called “slave”). A direct communication between all participants is not possible here, much more the master can choose at any time with which slave he would like to exchange data.
In order to address only one slave, a total of 3 signal lines are required, two of which are used for bidirectional data transmission and one as a clock generator for serial transmission.</description></item><item><title>Serial (UART/RS232)</title><link>https://pi4j.com/documentation/io-examples/serial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/io-examples/serial/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-example-components/blob/main/src/main/java/com/pi4j/catalog/applications/SerialGps_App.java
What is it? Serial communication can be used to transfer data between different boards, devices, etc. Data is transfered bit-by-bit in a sequence, through a single wire from a transmitter (= TX) to a receiver (= RX). On the receiver side the bits are combined to bytes.
When you need two-way communication, two wires are needed between RX and TX from both sides:
The communication between these two devices can happen in different ways:</description></item><item><title>The Pi4J Logo</title><link>https://pi4j.com/architecture/pi4j-logo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/pi4j-logo/</guid><description>GITHUB PROJECT: https://github.com/Pi4J/pi4j-logo
The Pi4J logo has been designed by Gerrit Grunwald and is nicely combines a raspberry pie with Duke, the Java Masqot.</description></item><item><title>Bosch sensor gas measurement</title><link>https://pi4j.com/blog/2024/20240517_bosch_sensor_gas_measurement/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240517_bosch_sensor_gas_measurement/</guid><description>2024-05-17, by Frank Delporte
Bosch has several sensors which are extremely small to measure temperature, humidity, pressure, and gas. We also have several example implementations documented on the Pi4J website:
BME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang. BMP280 Sensor, example implementation by Thomas Aarts. LED Matrix with SPI MAX7219, work-in-progress for a weather station. Sensor drivers, project by Juraj Veverka. You can find easy-to-use boards with such a sensor, for instance, on:</description></item><item><title>Interview Tom Aarts</title><link>https://pi4j.com/blog/2024/20240425_interview_tom_aarts/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240425_interview_tom_aarts/</guid><description>2024-04-25, by Frank Delporte
Tom Aarts started contributing to the Pi4J project when he did his first commit in the pi4j-example-devices repository. At this moment, you can find example implementations for a long list of devices (see screenshot below), using V2 of Pi4J. While creating these implementations he found and fixed some missing pieces and bugs in the core library. See, for instance, this blog post about the ongoing PWM improvements for the Raspberry Pi 5.</description></item><item><title>PWM Hardware Support on RPi5</title><link>https://pi4j.com/blog/2024/20240423_pwm_rpi5/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240423_pwm_rpi5/</guid><description>2024-04-23, by Tom Aarts
The next version of Pi4J (are now already in 2.5.2-SNAPSHOT) will add PWM support via a new provider linuxfs-pwm. The previous PWM PiGpio provider does not support the Raspberry Pi 5 RP1 chip. To use this new provider, changes are required in your pom.xml dependencies and Java code. The details of using this new provider are explained in the Pi4J documentation in Pulse Width Modulation. In this blog post, I want to provide extra details and an example implementation.</description></item><item><title>Interview Robert von Burg</title><link>https://pi4j.com/blog/2024/20240419_interview_robert_von_burg/</link><pubDate>Fri, 19 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240419_interview_robert_von_burg/</guid><description>2024-04-19, by Frank Delporte
The Pi4J project has two important Roberts. The first one is Robert Savage (living in the US), who started the Pi4J development. You can read more about him and the reason Pi4J was created in this interview on Foojay. He also created V2 of Pi4J, but hasn&amp;rsquo;t been involved a lot in the project since its release. Luckily, we have another Robert in the Pi4J team! Robert von Burg (living in Switzerland), also known as Eitch, is the main maintainer now of the Pi4J V2 sources and takes care of the releases.</description></item><item><title>Ongoing I2C Improvements</title><link>https://pi4j.com/blog/2024/20240418_i2c_improvements/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240418_i2c_improvements/</guid><description>2024-04-17, by Frank Delporte
Robert von Burg is working on improvements of the I2C implementation in Pi4J in preparation for the next release. The changes are in pull request #351. It&amp;rsquo;s still work-in-progress but will bring these improvements:
New I2C.execute(Callable) method to allow to atomically execute multiple I2C calls in a thread in a safe way. New I2C.writeRead(byte[], byte[]) method to atomically perform a write, immediately followed by a read on the I2C bus.</description></item><item><title>LED Matrix with SPI MAX7219</title><link>https://pi4j.com/blog/2024/20240417_led_matrix_max7219_spi_web/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240417_led_matrix_max7219_spi_web/</guid><description>2024-04-18, by Frank Delporte
Roberto Marquez shared a project with us that uses Java to interface with a MAX7219 SPI device to control an LED matrix. It&amp;rsquo;s inspired by the blog Raspberry Pi and SPI 8×8 LED matrix example with Java and Pi4j, but differs in that it is Web-enabled via Spring Boot. This project is the starting point to create a weather station in combination with the BMP280, see BME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang.</description></item><item><title>Alexander Liggesmeyer and RPi5</title><link>https://pi4j.com/blog/2024/20240318_interview_alexander_liggesmeyer/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240318_interview_alexander_liggesmeyer/</guid><description>2024-03-18, by Frank Delporte
Interview with Alexander Liggesmeyer about Pi4J for Raspberry Pi 5 Today, version 2.5.0 of Pi4J got released with many changes, fixes and improvements. The most important one being support for the Raspberry Pi 5. Short after the release of this new board, several issues were raised on GitHub as Pi4J was not compatible. The Raspberry Pi 5 uses a completely new way to interact with the GPIOs: the RP1 chip.</description></item><item><title>Pi4J Operating System</title><link>https://pi4j.com/blog/2023/20230731_pi4j_os/</link><pubDate>Mon, 31 Jul 2023 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2023/20230731_pi4j_os/</guid><description>2023-07-31, by Frank Delporte and Dieter Holz
Yes, the Raspberry Pi Operating System is awesome! But the Pi4J project made it if even more awesome by adding &amp;ldquo;goodies&amp;rdquo; for Java developers! Pi4J OS is not yet another OS, but the official Raspberry Pi OS, with additional tools and preconfigurations to make it the ideal OS for any Java and JavaFX developer who wants to use a Raspberry Pi.
The project is shared on GitHub and documented on the Pi4J website.</description></item><item><title>LED strip with Pi4J and JBang</title><link>https://pi4j.com/blog/2022/20221128_led_strip_with_jbang/</link><pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2022/20221128_led_strip_with_jbang/</guid><description>2022-11-28, by Robert von Burg
Intro In an earlier post, JBang and Pi4J were used to control a LED and button connected to a Raspberry Pi.
This week Robert von Burg, one of the main contributors of the Pi4J project, shared on Mastodon another project where a LED strip is controlled via I2C.
This is the result, notice the Foojay.io startup artwork 😉
Wiring The Raspberry Pi in the video is attached to a custom PCB used by Robert in medical cabinets.</description></item><item><title>Kotlin on the Raspberry Pi</title><link>https://pi4j.com/blog/2022/20221117_kotlin_on_raspberrypi/</link><pubDate>Thu, 17 Nov 2022 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2022/20221117_kotlin_on_raspberrypi/</guid><description>2022-11-17, by Muhammad Hashim
Intro Pi4J is considered the project that brought the JVM to the RaspberryPi.
It has been up for more than a decade allowing developers to write sophisticated, high-level, yet simple software on the RaspberryPi.
And we’re glad to make it even more simpler and powerful!
For quite some years now Kotlin has been a most welcome language in the JVM ecosystem and the modern development toolchain.</description></item><item><title>Getting Started Template</title><link>https://pi4j.com/blog/2022/20220113_javafx_pi4j_template/</link><pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2022/20220113_javafx_pi4j_template/</guid><description>2022-01-13, by Frank Delporte
Intro The Pi4J project wants to be the starting point for everyone who wants to use Java on the Raspberry Pi, being it a headless, JavaFX-user interface and/or GPIO-controller project.
Pi4J is intended to provide a friendly object-oriented I/O API and implementation libraries for Java Programmers to access the full I/O capabilities of the Raspberry Pi platform. This project abstracts the low-level native integration and interrupt monitoring to enable Java programmers to focus on implementing their application business logic.</description></item><item><title>Annotated provisioning</title><link>https://pi4j.com/architecture/advanced/annotated-provisioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/annotated-provisioning/</guid><description>To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations
Next to the declarative approach, Java annotations are available for the configuration of I/O provisioning instead of the hard-coded approach offered in V.1.
This implementation still needs to be further fine-tuned and unified somehow to make things cleaner and more straightforward, but would provide a way to initialize a I/O for instance like this:</description></item><item><title>Dependency injection</title><link>https://pi4j.com/architecture/advanced/dependency-injection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/dependency-injection/</guid><description>To simplify the initial V.2 version, the DI implementation has be removed so it could be refactored and extended later. It is still available in the branch #22-annotations
Along with the annotated I/O configuration the ability to support I/O provisioning via dependency injection also makes a lot of sense. There is some basic brute-force stuff working but this needs more work to make this a compatible implementation for Spring or CDI.</description></item><item><title>Native Library Path</title><link>https://pi4j.com/architecture/advanced/library-path/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/library-path/</guid><description>Overview Some Pi4J plugins, such as the Pi4J PiGpio Provider plugin, depend on native JNI libraries to communicate with the underlying system. By default Pi4J embeds these native libraries as resources inside the plugin&amp;rsquo;s JAR file. At runtime Pi4J extracts the native library into a temporary directory so the JVM can load the library from the filesystem. Upon termination the temporary file is automatically removed.
This automatic extration behavior works well for most users; however, there are certain edge cases where this may fail.</description></item><item><title>Plug-ins</title><link>https://pi4j.com/architecture/advanced/plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/plugins/</guid><description>The goal of Pi4J V.2 is to provide a solid base with all required &amp;ldquo;minimal functionality&amp;rdquo; while at the same time, promote third-party development and extensibility, thus enabling developers to build and maintain their extensions outside of the Pi4J core projects codebase.
This will enable us to deliver a stable, fully tested framework as the number of features inside of Pi4J can be limited and support for specific I/O hardware can be provided with an extension for Pi4J.</description></item><item><title>Raspberry Pi</title><link>https://pi4j.com/documentation/platforms/raspberry-pi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/documentation/platforms/raspberry-pi/</guid><description>Pi4J was designed for the Raspberry Pi, so this is the only supported platform (at this moment), although the architecture of the project allows other platforms to be added.
Add this dependency to include the Raspberry Pi Platform Plugin.
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.pi4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;pi4j-plugin-raspberrypi&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;${pi4j.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;</description></item><item><title>Remote support</title><link>https://pi4j.com/architecture/advanced/remote-support/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pi4j.com/architecture/advanced/remote-support/</guid><description>One of the big features on the wish-list for V.2: native support for remote I/O capability. Predominantly to support the ability for a user to perform development work on their desktop/laptop and be able to run their project with remote support slaving the I/O to a daemon running on the Raspberry Pi (or other supported SBC).
TO BE DECIDED: the V.2 codebase does support this currently by using the PiGpio daemon.</description></item></channel></rss>