<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on Pi4J</title><link>https://pi4j.com/blog/</link><description>Recent content in Blogs on Pi4J</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 25 Jun 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://pi4j.com/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Java 21+ Not Working on Zero 2</title><link>https://pi4j.com/blog/2025/20250625-java-21-not-working-on-zero-2/</link><pubDate>Wed, 25 Jun 2025 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2025/20250625-java-21-not-working-on-zero-2/</guid><description>&lt;p>2025-06-25 by Frank Delporte&lt;/p>
&lt;p>&lt;strong>Dieter Holz&lt;/strong> was experimenting with Pi4J V3 on a Raspberry Pi Zero 2. Because this version requires Java 21 or newer, he upgraded his OS to a newer Java version and found out that no Java code could be executed. He tried with both Java 21 and 24 and none of these worked correctly, although Java 17 runs without problems.&lt;/p>
&lt;p>The same SD card with Java 24, which didn&amp;rsquo;t work on the Zero 2, worked perfectly on a Raspberry Pi 4. So what is happening under the hoods? What is the difference between these two boards causing this problem? Let&amp;rsquo;s dive in&amp;hellip;&lt;/p></description></item><item><title>Starting with a Desktop Icon</title><link>https://pi4j.com/blog/2025/20250507-start-program-with-desktop-icon/</link><pubDate>Wed, 07 May 2025 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2025/20250507-start-program-with-desktop-icon/</guid><description>&lt;p>2025-05-07 by Frank Delporte&lt;/p>
&lt;p>&lt;strong>Richard Norrie&lt;/strong> created an oscilloscope with Pi4J and was looking for a way to start his application with a desktop icon. Unfortunately, he ran into a few issues as the icon led to &amp;ldquo;Java not found&amp;rdquo; error. This was likely due to environment variables not being properly set in the desktop launcher context.&lt;/p>
&lt;p>Here are the steps how this got fixed as you can see in this screenshot:&lt;/p></description></item><item><title>Pi4J welcomes Java 21</title><link>https://pi4j.com/blog/2025/20250211-welcome-java-21/</link><pubDate>Wed, 05 Feb 2025 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2025/20250211-welcome-java-21/</guid><description>&lt;p>2025-02-11 by Frank Delporte&lt;/p>
&lt;p>&lt;strong>The development of the Pi4J library faced a decision point&amp;hellip;: &amp;ldquo;&lt;em>Should we stick to Java 11 for existing projects and old Raspberry Pi&amp;rsquo;s (&lt;a href="https://pi4j.com/documentation/java-for-arm/">with ARMv6&lt;/a>), versus moving on and making use of better and more performant Java code with the latest Long Term Support (LTS) version?&lt;/em>&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>We actually wanted to move on to Java 22, as it brings a new way of interacting with C-code, thanks to &lt;a href="https://openjdk.org/jeps/454" target="_blank" rel="noopener">JEP 454: Foreign Function &amp;amp; Memory API&lt;/a>. As this is the core behavior of Pi4J to interact with the GPIOs, it would make it much easier to implement new ways to control electronics, as confirmed &lt;a href="https://github.com/eitch/pi4j-test/blob/develop/src/main/java/ch/eitchnet/pi4j/test/LibGPIODController.java" target="_blank" rel="noopener">with a first test by Robert &amp;ldquo;Eitch&amp;rdquo;&lt;/a>. But as Java 22 is not an LTS release, we won&amp;rsquo;t make this move yet.&lt;/p></description></item><item><title>Pi4J presentation for Miami JUG</title><link>https://pi4j.com/blog/2025/20250115-miami-jug/</link><pubDate>Wed, 15 Jan 2025 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2025/20250115-miami-jug/</guid><description>&lt;p>2025-01-15 by Frank Delporte&lt;/p>
&lt;p>Frank Delporte was invited by the Miami JVM Group to present his journey into Java development on the Raspberry Pi. This video contains the part of the presentation that introduces Pi4J, some of its history, and its current state. We also look at a basic and more extended example, with a demo of a Vaadin and Spring Boot application controlling several electronic components.&lt;/p>
&lt;p>This is the 30&amp;rsquo; version about Pi4J:&lt;/p></description></item><item><title>Pi4J in Floss Weekly</title><link>https://pi4j.com/blog/2024/20241114-floss-weekly-podcast/</link><pubDate>Thu, 14 Nov 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20241114-floss-weekly-podcast/</guid><description>&lt;p>2024-11-14 by Frank Delporte&lt;/p>
&lt;p>Frank Delporte was a guest on the Floss Weekly podcast. He talked with Jonathan Bennett and David Ruggles about the Pi4J Project, the friendly Java libraries for the Raspberry Pi that expose GPIO, SPI, I2C, and other IO interfaces. Why would anyone want to use Java for the Pi? And whatâ€™s changed since the project started? You can find it in your favorite podcast app or watch the video below.&lt;/p></description></item><item><title>Maven Downloads</title><link>https://pi4j.com/blog/2024/20241104-download-stats/</link><pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20241104-download-stats/</guid><description>&lt;p>2024-11-04 by Frank Delporte&lt;/p>
&lt;p>As an open-source project it&amp;rsquo;s very difficult to understand how much it&amp;rsquo;s used &amp;ldquo;in the wild&amp;rdquo;. The only stats we have, are the number of downloads from the Maven repository. So end of October I made a few screenshots to share here with the statistics including September 2024.&lt;/p>
&lt;p>These are the numbers for all Pi4J libraries combined. Is this much? I have no clue as I can&amp;rsquo;t compare it with a similar project. ;-)&lt;/p></description></item><item><title>Signed versus unsigned values</title><link>https://pi4j.com/blog/2024/20240927-bits-bytes-signed-unsigned/</link><pubDate>Fri, 27 Sep 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240927-bits-bytes-signed-unsigned/</guid><description>&lt;p>2024-09-27, by Frank Delporte&lt;/p>
&lt;p>When using bits and bytes to control electronic components, the conversion from a byte to, e.g., logging output can be a bit confusing as Java uses signed values. This means a byte value has a range of -128 till 127, while you would expect 0 (0x00) till 255 (0xFF).&lt;/p>
&lt;p>For example, the hex value &lt;code>0x8F&lt;/code> (&lt;code>10001111&lt;/code>) is handled like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">var&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">byte&lt;/span>) Integer.&lt;span style="color:#a6e22e">parseInt&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;10001111&amp;#34;&lt;/span>, 2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Byte value 10001111: &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Output&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Byte value 10001111: &lt;span style="color:#f92672">-&lt;/span>113
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can use &lt;code>Byte.toUnsignedInt(b)&lt;/code> to get the expected, unsigned value:&lt;/p></description></item><item><title>Bosch sensor gas measurement</title><link>https://pi4j.com/blog/2024/20240517_bosch_sensor_gas_measurement/</link><pubDate>Fri, 17 May 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240517_bosch_sensor_gas_measurement/</guid><description>&lt;p>2024-05-17, by Frank Delporte&lt;/p>
&lt;p>Bosch has several sensors which are extremely small to measure temperature, humidity, pressure, and gas. We also have several example implementations documented on the Pi4J website:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://pi4j.com/examples/jbang/bme280_temperature_humidity_pressure/">BME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang&lt;/a>.&lt;/li>
&lt;li>&lt;a href="https://pi4j.com/examples/communityimplementation/bmp280/">BMP280 Sensor&lt;/a>, example implementation by Thomas Aarts.&lt;/li>
&lt;li>&lt;a href="https://pi4j.com/blog/2024/20240417_led_matrix_max7219_spi_web/">LED Matrix with SPI MAX7219&lt;/a>, work-in-progress for a weather station.&lt;/li>
&lt;li>&lt;a href="https://pi4j.com/featured-projects/sensor-drivers/">Sensor drivers&lt;/a>, project by Juraj Veverka.&lt;/li>
&lt;/ul>
&lt;p>You can find easy-to-use boards with such a sensor, for instance, on:&lt;/p></description></item><item><title>Interview Tom Aarts</title><link>https://pi4j.com/blog/2024/20240425_interview_tom_aarts/</link><pubDate>Thu, 25 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240425_interview_tom_aarts/</guid><description>&lt;p>2024-04-25, by Frank Delporte&lt;/p>
&lt;p>&lt;strong>Tom Aarts&lt;/strong> started contributing to the Pi4J project when he did his first commit in the &lt;a href="https://github.com/Pi4J/pi4j-example-devices/" target="_blank" rel="noopener">pi4j-example-devices repository&lt;/a>. At this moment, you can find example implementations for a long list of devices (see screenshot below), using V2 of Pi4J. While creating these implementations he found and fixed some missing pieces and bugs in the core library. See, for instance, this &lt;a href="https://pi4j.com/blog/2024/20240423_pwm_rpi5/" target="_blank" rel="noopener">blog post about the ongoing PWM improvements for the Raspberry Pi 5&lt;/a>. Furthermore, you can find Tom often in assisting users who &lt;a href="https://github.com/Pi4J/pi4j/issues" target="_blank" rel="noopener">filed a Pi4J V2 issue&lt;/a> or &lt;a href="https://github.com/Pi4J/pi4j/discussions" target="_blank" rel="noopener">started a discussion&lt;/a>.&lt;/p></description></item><item><title>PWM Hardware Support on RPi5</title><link>https://pi4j.com/blog/2024/20240423_pwm_rpi5/</link><pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240423_pwm_rpi5/</guid><description>&lt;p>2024-04-23, by Tom Aarts&lt;/p>
&lt;p>The next version of Pi4J (are now already in 2.5.2-SNAPSHOT) will add PWM support via a new provider &lt;code>linuxfs-pwm&lt;/code>. The previous PWM PiGpio provider does not support the Raspberry Pi 5 RP1 chip. To use this new provider, changes are required in your &lt;code>pom.xml&lt;/code> dependencies and Java code. The details of using this new provider are explained in the Pi4J documentation in &lt;a href="https://pi4j.com/documentation/io-examples/pwm/">Pulse Width Modulation&lt;/a>. In this blog post, I want to provide extra details and an example implementation. This post reference changes when using the Bookworm OS on a Raspberry Pi 5. If you are using the &lt;code>linuxfs-pwm&lt;/code> provider on a Raspberry Pi 4, consult the &lt;a href="https://pi4j.com/documentation/io-examples/pwm/">Pulse Width Modulation&lt;/a> for &lt;code>config.sys&lt;/code> and channel differences.&lt;/p></description></item><item><title>Interview Robert von Burg</title><link>https://pi4j.com/blog/2024/20240419_interview_robert_von_burg/</link><pubDate>Fri, 19 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240419_interview_robert_von_burg/</guid><description>&lt;p>2024-04-19, by Frank Delporte&lt;/p>
&lt;p>The Pi4J project has two important Roberts. The first one is &lt;strong>Robert Savage&lt;/strong> (living in the US), who started the Pi4J development. You can read more about him and the reason Pi4J was created in &lt;a href="https://foojay.io/today/interviews-with-robert-savage-and-johan-vos-on-the-state-of-java-on-raspberry-pi/" target="_blank" rel="noopener">this interview on Foojay&lt;/a>. He also created V2 of Pi4J, but hasn&amp;rsquo;t been involved a lot in the project since its release. Luckily, we have another Robert in &lt;a href="https://pi4j.com/about/team/" target="_blank" rel="noopener">the Pi4J team&lt;/a>! &lt;strong>Robert von Burg&lt;/strong> (living in Switzerland), also known as &lt;strong>Eitch&lt;/strong>, is the &lt;a href="https://github.com/Pi4J/pi4j" target="_blank" rel="noopener">main maintainer now of the Pi4J V2 sources&lt;/a> and takes care of the releases.&lt;/p></description></item><item><title>Ongoing I2C Improvements</title><link>https://pi4j.com/blog/2024/20240418_i2c_improvements/</link><pubDate>Thu, 18 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240418_i2c_improvements/</guid><description>&lt;p>2024-04-17, by Frank Delporte&lt;/p>
&lt;p>Robert von Burg is working on improvements of the I2C implementation in Pi4J in preparation for the next release. The changes are in &lt;a href="https://github.com/Pi4J/pi4j/pull/351/files" target="_blank" rel="noopener">pull request #351&lt;/a>. It&amp;rsquo;s still work-in-progress but will bring these improvements:&lt;/p>
&lt;ul>
&lt;li>New &lt;code>I2C.execute(Callable)&lt;/code> method to allow to atomically execute multiple I2C calls in a thread in a safe way.&lt;/li>
&lt;li>New &lt;code>I2C.writeRead(byte[], byte[])&lt;/code> method to atomically perform a &lt;code>write&lt;/code>, immediately followed by a &lt;code>read&lt;/code> on the I2C bus.&lt;/li>
&lt;li>Fix an issue where the &lt;code>LinuxFsI2CBus&lt;/code> was closed when closing an I2C device. This can lead to errors as another device might still be open on the same bus, and an operation on the underlying &lt;code>RandomAccessFile&lt;/code> would lead to exceptions.&lt;/li>
&lt;li>Fix a workaround that required an &lt;code>I2C.read()&lt;/code> on a newly created &lt;code>LinuxFsI2C&lt;/code> device, if the first call was an &lt;code>ioctl&lt;/code>. The device was not selected prior to the &lt;code>ioctl&lt;/code> call.&lt;/li>
&lt;li>Additional code cleanup and more to come&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>This kind of methods is hard to test in unit tests as they interact with real components and need to handle the data and I2C devices depending on the interaction. As a solution, Robert is using a &lt;a href="https://github.com/eitch/pi4j-test/tree/feature/eitch-leds" target="_blank" rel="noopener">test project&lt;/a> that has an implementation for an OLED display over I2C, using these commands.&lt;/p></description></item><item><title>LED Matrix with SPI MAX7219</title><link>https://pi4j.com/blog/2024/20240417_led_matrix_max7219_spi_web/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240417_led_matrix_max7219_spi_web/</guid><description>&lt;p>2024-04-18, by Frank Delporte&lt;/p>
&lt;p>Roberto Marquez shared a project with us that uses Java to interface with a MAX7219 SPI device to control an LED matrix. It&amp;rsquo;s inspired by the blog &lt;a href="https://www.hackerspacetech.com/raspberry-pi-and-spi-8x8-led-matrix-example-with-java-and-pi4j/" target="_blank" rel="noopener">Raspberry Pi and SPI 8Ã—8 LED matrix example with Java and Pi4j&lt;/a>, but differs in that it is Web-enabled via Spring Boot. This project is the starting point to create a weather station in combination with the BMP280, see &lt;a href="https://pi4j.com/examples/jbang/bme280_temperature_humidity_pressure/" target="_blank" rel="noopener">BME280 Sensor (temp, humidity, pressure) via Pi4J, I2C, and JBang&lt;/a>.&lt;/p></description></item><item><title>Alexander Liggesmeyer and RPi5</title><link>https://pi4j.com/blog/2024/20240318_interview_alexander_liggesmeyer/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2024/20240318_interview_alexander_liggesmeyer/</guid><description>&lt;p>2024-03-18, by Frank Delporte&lt;/p>
&lt;h2 id="interview-with-alexander-liggesmeyer-about-pi4j-for-raspberry-pi-5">Interview with Alexander Liggesmeyer about Pi4J for Raspberry Pi 5&lt;/h2>
&lt;p>Today, &lt;a href="https://pi4j.com/about/release-notes/">version 2.5.0 of Pi4J got released with many changes, fixes and improvements&lt;/a>. The most important one being support for the &lt;a href="https://www.raspberrypi.com/products/raspberry-pi-5/" target="_blank" rel="noopener">Raspberry Pi 5&lt;/a>. Short after the release of this new board, &lt;a href="https://github.com/Pi4J/pi4j/issues/321" target="_blank" rel="noopener">several issues were raised on GitHub&lt;/a> as Pi4J was not compatible. The Raspberry Pi 5 uses a completely new way to interact with the GPIOs: the &lt;a href="https://www.raspberrypi.com/documentation/microcontrollers/rp1.html" target="_blank" rel="noopener">RP1 chip&lt;/a>. Thanks to this chip, GPIO, SPI, I2C, USB, ethernet,&amp;hellip; are seperated from the SoC to make it easier to develop newer boards. But this new approach wasn&amp;rsquo;t supported by the PiGpio library used in Pi4J V2&amp;hellip; Until Alexander Liggesmeyer took up the challenge to find a solution!&lt;/p></description></item><item><title>LED strip with Pi4J and JBang</title><link>https://pi4j.com/blog/2022/20221128_led_strip_with_jbang/</link><pubDate>Mon, 28 Nov 2022 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2022/20221128_led_strip_with_jbang/</guid><description>&lt;p>2022-11-28, by Robert von Burg&lt;/p>
&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>In an earlier post, JBang and Pi4J were used to control a LED and button connected to a Raspberry Pi.&lt;/p>
&lt;p>This week Robert von Burg, one of the main contributors of the Pi4J project, &lt;a href="https://mstdn.gsi.li/@eitch/109324090007015888" target="_blank" rel="noopener">shared on Mastodon&lt;/a> another project where a LED strip is controlled via I2C.&lt;/p>
&lt;p>This is the result, notice the Foojay.io startup artwork ðŸ˜‰&lt;/p>

 &lt;div
 style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
 &lt;iframe
 src="https://player.vimeo.com/video/771087170?dnt=0"
 style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allow="fullscreen">
 &lt;/iframe>
 &lt;/div>

&lt;h2 id="wiring">Wiring&lt;/h2>
&lt;p>The Raspberry Pi in the video is attached to a custom PCB used by Robert in &lt;a href="https://pi4j.com/featured-projects/soft-real-time-plc-written-in-strolch/" target="_blank" rel="noopener">medical cabinets&lt;/a>.&lt;/p></description></item><item><title>Kotlin on the Raspberry Pi</title><link>https://pi4j.com/blog/2022/20221117_kotlin_on_raspberrypi/</link><pubDate>Thu, 17 Nov 2022 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2022/20221117_kotlin_on_raspberrypi/</guid><description>&lt;p>2022-11-17, by Muhammad Hashim&lt;/p>
&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>Pi4J is considered the project that brought the JVM to the RaspberryPi.&lt;/p>
&lt;p>It has been up for more than a decade allowing developers to write sophisticated, high-level, yet simple software on the RaspberryPi.&lt;/p>
&lt;p>And weâ€™re glad to make it even more simpler and powerful!&lt;/p>
&lt;p>For quite some years now Kotlin has been a most welcome language in the JVM ecosystem and the modern development toolchain.&lt;/p></description></item><item><title>Getting Started Template</title><link>https://pi4j.com/blog/2022/20220113_javafx_pi4j_template/</link><pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate><guid>https://pi4j.com/blog/2022/20220113_javafx_pi4j_template/</guid><description>&lt;p>2022-01-13, by Frank Delporte&lt;/p>
&lt;h2 id="intro">Intro&lt;/h2>
&lt;p>The Pi4J project wants to be the starting point for everyone who wants to use Java on the Raspberry Pi, being it a headless, JavaFX-user interface and/or GPIO-controller project.&lt;/p>
&lt;p>Pi4J is intended to provide a friendly object-oriented I/O API and implementation libraries for Java Programmers to access the full I/O capabilities of the Raspberry Pi platform. This project abstracts the low-level native integration and interrupt monitoring to enable Java programmers to focus on implementing their application business logic.&lt;/p></description></item></channel></rss>